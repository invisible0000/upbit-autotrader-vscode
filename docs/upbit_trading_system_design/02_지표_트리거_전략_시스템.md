# 자동 매매 프로그램 개발 기획 v2 - 2부: 지표, 트리거, 전략 시스템

## 1. 개요

1부에서 정의한 아키텍처를 기반으로, 2부에서는 사용자의 아이디어를 시스템이 이해할 수 있는 논리 단위로 변환하는 과정을 설계한다. 이는 **지표(Variable) → 트리거(Trigger) → 전략(Strategy)** 으로 구체화되는 핵심 단계이다.

---

## 2. 통합 지표(Trading Variable) 관리 시스템

시스템에서 사용되는 모든 변수(기술적 지표, 가격 데이터 등)는 **`IndicatorDefinition`** 클래스로 표준화하고, **`IndicatorRegistry`** 를 통해 중앙에서 관리하여 일관성과 확장성을 확보한다.

### 2.1. `IndicatorDefinition` 클래스
지표 하나에 대한 모든 메타데이터와 계산 로직을 담는 설계도 역할을 한다.

```python
from dataclasses import dataclass, field
from typing import List, Dict, Callable, Any, Literal

@dataclass
class IndicatorParam:
    name: str
    type: str  # "int", "float", "enum"
    default: Any
    required: bool
    values: List[str] = field(default_factory=list) # enum 타입일 경우

@dataclass
class IndicatorDefinition:
    name: str  # 예: "BOLLINGER_BAND"
    params_schema: List[IndicatorParam]
    plot_category: str  # 1차: "Price Overlay" / "Subplot"
    scale_category: str # 2차: "Price" / "0-100" / "Volume"
    compat_group: str   # 3차: "Price" / "Oscillator" / "Volume" (비교 가능성 검증용)
    output_names: List[str] # 다중 출력 지원. 예: ['upper', 'middle', 'lower']
    calculation_func: Callable # 실제 계산 함수
    provider: Literal['IndicatorCalculator', 'TradingEngine'] # 계산 주체
```

### 2.2. `IndicatorRegistry` 클래스
시스템의 모든 `IndicatorDefinition`을 로드하고 관리하는 중앙 레지스트리.

```python
class IndicatorRegistry:
    def __init__(self):
        self.definitions: Dict[str, IndicatorDefinition] = {}

    def load_definitions_from_db(self, db_connection):
        """DB에서 모든 지표의 메타데이터를 로드"""
        pass

    def register_calculation_functions(self, function_map: Dict[str, Callable]):
        """코드에 정의된 계산 함수를 메타데이터와 연결"""
        pass

    def get_definition(self, name: str) -> IndicatorDefinition:
        """이름으로 지표 정의 조회"""
        return self.definitions.get(name.upper())
```

### 2.3. 계산 주체 분리 (`provider` 필드)
*   **`IndicatorCalculator`**: 과거 데이터만으로 계산 가능한 **상태 없는(stateless)** 지표(RSI, 이동평균 등)를 계산한다.
*   **`TradingEngine`**: 포지션 진입 후의 상태(예: 진입 후 최고가)를 알아야만 계산 가능한 **상태 있는(stateful)** 변수(추적 손절 값 등)를 계산한다.

---

## 3. 트리거 시스템

### 3.1. 트리거 빌더 (`TriggerBuilderWidget`)
사용자가 GUI를 통해 'A가 B를 C한다' 형태의 논리 조건을 생성하고 DB에 저장하는 인터페이스.

*   **동적 UI**: 사용자가 지표를 선택하면, `IndicatorRegistry`에서 해당 지표의 파라미터 정보를 조회하여 필요한 입력 위젯(SpinBox, ComboBox 등)을 동적으로 생성한다.
*   **실시간 호환성 검증**: 기준 변수(A)와 대상 변수(B)가 선택되는 즉시 `compat_group`을 비교하여 논리적으로 비교 불가능한 조합(예: 가격과 거래량)일 경우 경고를 표시하고 저장/테스트 버튼을 비활성화한다.

### 3.2. 트리거 평가 엔진 (`TriggerEvaluator`)
`Trigger` 객체(규칙)와 `DataFrame`(데이터)을 받아 특정 시점에서 규칙의 참/거짓을 판결하는 두뇌.

```python
class TriggerEvaluator:
    def __init__(self, calculator: IndicatorCalculator):
        self.calculator = calculator

    def evaluate_at_index(self, trigger: Trigger, df: pd.DataFrame, index: int) -> bool:
        """특정 캔들(index)을 기준으로 트리거 조건을 평가"""
        # 1. 기준 변수(A)와 대상 값(B)의 현재, 이전 값을 추출
        # 2. NaN 값 처리
        # 3. 비교 연산자(comparison_operator)에 따라 논리 판결
        #    (예: 'cross_up' -> 이전에는 A<=B 였다가 현재 A>B 인지 확인)
        pass
```

---

## 4. 전략 시스템

### 4.1. 전략 메이커 (`StrategyMakerWidget`)
저장된 트리거들을 레고 블록처럼 조합하여 진입/청산 규칙을 포함하는 완전한 매매 **전략**을 생성/편집하는 UI.

*   **UI/UX**: 좌측에는 사용 가능한 트리거 목록, 우측에는 '진입 조건'과 '청산 조건' 영역을 두어 드래그 앤 드롭으로 트리거를 추가할 수 있게 한다.
*   **논리 조합**: 각 조건 영역 내에서 트리거들을 AND 또는 OR 논리로 묶을 수 있는 옵션을 제공한다.
*   **파라미터 오버라이드**: 전략에 추가된 트리거의 파라미터를 원본 트리거와 다르게, 이 전략 내에서만 적용되도록 수정하는 기능을 제공한다. 이는 트리거의 재사용성을 극대화한다.
*   **조건부 활성화 (Conditional Activation)**: 특정 청산 트리거(예: 추적 손절)는 '진입 성공 후'에만 활성화되도록 설정하는 옵션을 제공한다.

### 4.2. 전략 평가 엔진 (`StrategyEvaluator`)
`Strategy` 객체와 `DataFrame`을 받아, 해당 전략의 최종 진입/청산 신호 발생 여부를 종합적으로 판단한다.

```python
class StrategyEvaluator:
    def __init__(self, trigger_evaluator: TriggerEvaluator):
        self.trigger_evaluator = trigger_evaluator

    def evaluate_entry_signals(self, strategy: Strategy, df: pd.DataFrame, index: int) -> bool:
        """전략의 모든 진입 트리거를 평가하고, AND/OR 논리에 따라 최종 진입 신호를 반환"""
        pass

    def evaluate_exit_signals(self, strategy: Strategy, df: pd.DataFrame, index: int, position_state: dict) -> bool:
        """전략의 모든 청산 트리거를 평가하고, AND/OR 논리에 따라 최종 청산 신호를 반환"""
        # position_state: 추적 손절 등 상태 기반 변수 계산에 필요한 실시간 포지션 정보
        pass
```

### 4.3. 미니 차트 시뮬레이터 (`MiniChartWidget`)
사용자가 생성한 트리거와 전략이 의도대로 동작하는지 과거 데이터의 특정 구간에서 즉각적으로 시각화하여 검증하는 도구.

*   **데이터 소스**: '급등', '급락', '횡보' 등 미리 분류된 다양한 시장 상황별 데이터 세그먼트를 제공하여 여러 시나리오에서 테스트할 수 있게 한다.
*   **동적 플로팅**: `IndicatorRegistry`의 `plot_category`와 `scale_category`를 참조하여, 가격 차트에 오버레이할 지표(이동평균선 등)와 별도의 서브플롯에 그릴 지표(RSI 등)를 자동으로 구분하여 시각화한다.
*   **신호 시각화**: 트리거의 진입/청산 신호가 발생하는 캔들에 화살표 등 시각적 표식을 추가하여 사용자가 논리의 정확성을 직관적으로 확인할 수 있게 한다.
