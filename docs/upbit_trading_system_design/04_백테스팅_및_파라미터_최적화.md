# 자동 매매 프로그램 개발 기획 v2 - 4부: 백테스팅 및 파라미터 최적화

## 1. 개요

4부의 목표는 사용자가 만든 전략의 과거 성과를 과학적으로 검증하는 **백테스팅 엔진**과, 주어진 전략 내에서 최적의 성과를 내는 파라미터 조합을 시스템이 스스로 찾아내는 **최적화 엔진**을 설계하는 것이다. 이 엔진들은 실시간 트레이딩 엔진과 완전히 분리되어 안전하게 실행된다.

---

## 2. 최적화 엔진 아키텍처

최적화 엔진은 대량의 계산을 효율적으로 처리하기 위해 병렬 처리 아키텍처를 기반으로 설계된다.

*   **병렬 처리 프로세스 풀**:
    *   Python의 `concurrent.futures.ProcessPoolExecutor`를 활용하여 CPU 코어 수에 맞춰 워커(Worker) 프로세스 풀을 생성하고 관리한다.
    *   유전 알고리즘의 '평가(Evaluation)' 단계에서, 한 세대(Generation)에 속한 수많은 염색체(파라미터 조합)들을 각 워커 프로세스에 분배하여 **동시에 백테스팅을 실행**한다. 이는 전체 최적화 시간을 획기적으로 단축시킨다.

*   **프로세스 독립적 데이터 로딩**:
    *   메인 프로세스는 각 워커에게 대용량 시계열 데이터(DataFrame) 전체를 넘기는 대신, '전략 정의', '테스트할 파라미터 조합', '필요한 데이터의 시간 범위' 등 최소한의 정보만 전달한다.
    *   각 워커 프로세스는 작업을 시작할 때 자신만의 DB 커넥션을 생성하고, `market_data.sqlite3`에서 필요한 데이터를 직접 조회하여 메모리에 로드한다. 이 방식은 프로세스 간 데이터 전송 오버헤드를 최소화하여 병렬 처리 효율을 극대화한다.

---

## 3. 데이터 모델 확장

파라미터 최적화를 지원하기 위해 기존 데이터 모델을 확장하고 신규 테이블을 추가한다.

### 3.1. `strategies` 테이블 수정 (파라미터 변수화)
`entry_triggers`, `exit_triggers`에 저장되는 JSON 구조를 확장하여 최적화할 파라미터의 범위와 단계를 정의한다.

**기존 `overridden_params`:**
`"params": {"period": 20}`

**확장된 `overridden_params`:**
```json
"params": {
    "period": {
        "is_optimizable": true,
        "start": 10,
        "end": 50,
        "step": 5
    }
}
```

### 3.2. `strategies.sqlite3` 신규 테이블 추가

*   **`optimization_jobs`**: 최적화 작업의 목록과 상태, 설정을 관리한다.
    *   **컬럼**: `job_id`(PK), `strategy_id`, `status`(pending, running, completed 등), `start_time`, `end_time`, `ga_settings`(JSON - 세대 수, 집단 크기, 적합도 함수식 등)

*   **`optimization_results`**: 각 최적화 작업의 상세 결과를 저장한다.
    *   **컬럼**: `result_id`(PK), `job_id`(FK), `best_params`(JSON - 최적 파라미터 조합), `fitness_score`(REAL), `performance_metrics`(JSON - 수익률, MDD 등 상세 성과)

---

## 4. 백테스팅 엔진 (`Backtester`)

최적화의 핵심은 동일한 전략을 수많은 파라미터 조합으로 빠르게 테스트하는 것이다. `Backtester`는 이 역할을 수행하며, 유전 알고리즘의 **'적합도 함수(Fitness Function)'** 가 된다.

*   **입력**: `Strategy` 객체, 테스트할 파라미터 조합(dict), 과거 시세 데이터(DataFrame)
*   **프로세스**:
    1.  입력받은 파라미터 조합을 `Strategy` 객체에 적용한다.
    2.  과거 데이터 전체를 순회하며 `StrategyEvaluator`를 통해 가상 매매를 실행한다. (UI 렌더링 과정 없이 계산에만 집중)
    3.  수수료, 슬리피지(선택적)를 반영하여 최종 손익 및 성과 지표(총수익률, MDD, 승률 등)를 계산한다.
*   **출력 (사용자 정의 적합도 함수)**:
    *   단일 지표(예: 수익률)만 사용하면 위험한 파라미터가 선택될 수 있다. 이를 방지하기 위해 사용자가 직접 적합도 함수를 정의하는 기능을 도입한다.
    *   `optimization_jobs` 테이블의 `ga_settings` JSON에 `fitness_formula` 필드를 추가한다.
    *   사용자는 UI에서 `0.6 * total_return + 0.4 * (1 - max_drawdown)` 과 같은 수식을 입력할 수 있다.
    *   `Backtester`는 백테스팅 완료 후, 이 수식에 따라 각 성과 지표를 조합하여 최종 `fitness_score`를 계산한다. 이 방식은 사용자가 '안정성'과 '수익성' 사이의 균형을 직접 조절하게 하는 강력한 기능이다.

---

## 5. 유전 알고리즘 (Genetic Algorithm) 적용

단순한 그리드 서치를 넘어 효율적으로 최적의 해를 찾기 위해 유전 알고리즘을 적용한다.

*   **염색체 (Chromosome)**: 하나의 백테스트를 실행할 수 있는 완전한 파라미터 조합. 각 유전자(Gene)의 키는 `{instance_id}_{parameter_name}` 규칙으로 생성하여 고유성을 보장한다.
    *   **예시**: `{'sma_trigger_abc-123_period': 20, 'rsi_trigger_def-456_period': 14}`

*   **진화 과정**:
    1.  **초기화 (Initialization)**: 사용자가 정의한 파라미터 범위 내에서 무작위로 염색체들을 생성하여 초기 집단을 구성한다.
    2.  **평가 (Evaluation)**: 집단의 모든 염색체에 대해 `Backtester`를 병렬 실행하여 각 염색체의 적합도 점수를 계산한다.
    3.  **선택 (Selection)**: 적합도 점수가 높은 우수 개체들이 다음 세대에 살아남을 확률이 높아진다. (예: 룰렛 휠 선택)
    4.  **교차 (Crossover)**: 선택된 두 부모 염색체의 유전자를 섞어 새로운 자손 염색체를 생성한다.
    5.  **변이 (Mutation)**: 자손 염색체의 유전자 일부를 무작위로 살짝 변경하여 집단의 다양성을 유지하고 지역 최적해(local optima)에 빠지는 것을 방지한다.
    6.  **반복**: 2~5번 과정을 지정된 세대 수만큼 반복하거나, 적합도 점수가 일정 수준 이상으로 수렴할 때까지 반복한다.
    7.  **결과**: 모든 세대가 끝난 후, 가장 높은 적합도 점수를 기록한 염색체가 최적의 파라미터 조합으로 선정된다.
