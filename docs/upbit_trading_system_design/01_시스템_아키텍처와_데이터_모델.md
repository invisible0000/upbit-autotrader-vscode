# 자동 매매 프로그램 개발 기획 v2 - 1부: 시스템 아키텍처와 데이터 모델

## 1. 프로젝트 목표 및 개발 원칙

### 1.1. 프로젝트 목표
'전략 중심의 자동 매매 프레임워크'를 구축한다. 이는 사용자의 매매 아이디어를 체계적으로 자산화하고, 과학적으로 검증하며, 안정적으로 실제 매매에 적용할 수 있는 지속 가능한 시스템을 만드는 것을 목표로 한다.

### 1.2. 개발 원칙
1.  **전략 우선주의 (Strategy-First)**: 모든 기능은 '사용자가 더 나은 전략을 만들고 검증하는 데 도움이 되는가?'라는 질문에서 출발한다.
2.  **모듈성 및 확장성 (Modularity & Scalability)**: 각 컴포넌트는 명확한 책임을 가지며 독립적으로 개발 및 테스트가 가능해야 한다. 향후 새로운 기능 추가가 용이한 구조를 지향한다.
3.  **안정성 및 오류 내성 (Stability & Fault Tolerance)**: 자동 매매 시스템의 핵심은 수익이 아니라 '손실 방지'와 '예측 가능한 동작'이다. 예외 상황에 대한 명확한 처리 로직을 최우선으로 고려한다.

---

## 2. 시스템 아키텍처

시스템은 5개의 핵심 모듈과 3개의 SQLite 데이터베이스로 구성된다. 각 모듈은 명확히 정의된 인터페이스를 통해 상호작용한다.

### 2.1. 아키텍처 다이어그램
```
+----------------------------------------------------------------+
|                        UI (PyQt6)                              |
| [Trigger Builder] [Strategy Maker] [Dashboard] [Mini-Chart]    |
+--------------------------------+-------------------------------+
         ^ (Load/Save)           | (Create/Test Strategy)
         |                       v
+--------+-----------------------+----------------+
|      Data Handler              |      Strategy Management Engine |
| (3x SQLite DBs)                |      (The Brain)                |
+--------------------------------+-------------------------------+
                                 | (Evaluate Signal)
                                 v
                        +--------+-------+
                        | Trading Engine |
                        | (The Hands)    |
                        +----------------+
                                 ^
                                 v
                        +----------------+
                        |  API Wrapper   |
                        +----------------+
                                 ^
                                 v
                        +----------------+
                        | Upbit Exchange |
                        +----------------+
```

### 2.2. 모듈별 책임 정의

1.  **UI (User Interface)**
    *   **책임**: 사용자 입력을 받아 하위 엔진에 작업을 요청하고, 엔진의 응답을 시각적으로 표시한다. **직접적인 계산이나 매매 로직을 포함하지 않는다.**
    *   **핵심 클래스**: `MainWindow`, `TriggerBuilderWidget`, `StrategyMakerWidget`, `DashboardWidget`, `MiniChartWidget`

2.  **Strategy Management Engine (두뇌)**
    *   **책임**: 지표 계산, 트리거 조건 평가, 전략의 진입/청산 신호 종합 판단.
    *   **핵심 클래스**: `IndicatorCalculator`, `TriggerEvaluator`, `StrategyEvaluator`

3.  **Trading Engine (손과 발)**
    *   **책임**: 포지션의 생명주기(생성, 감시, 종료)를 관리하고, `Strategy Management Engine`의 판단에 따라 실제 주문을 실행한다.
    *   **핵심 클래스**: `PositionManager`, `OrderExecutor`

4.  **API Wrapper (통신 전문가)**
    *   **책임**: Upbit 거래소와의 모든 통신(REST API, WebSocket)을 전담한다. API 키를 안전하게 관리하고 요청을 서명하는 유일한 모듈이다.
    *   **핵심 클래스**: `UpbitRestApiClient`, `UpbitWebsocketClient`

5.  **Data Handler (기록 보관소)**
    *   **책임**: 3개의 SQLite 데이터베이스와의 모든 상호작용(CRUD)을 전담하는 Repository 역할을 수행한다. 스레드별로 독립적인 DB 커넥션을 관리하여 동시성 문제를 해결한다.
    *   **핵심 클래스**: `DatabaseManager`

---

## 3. 데이터베이스 설계 (3중 DB 구조)

### 3.1. settings.sqlite3 (앱 설정 및 스키마)
*   **목적**: 프로그램의 전반적인 설정과 데이터베이스 테이블 스키마 정보를 관리한다.
*   **주요 테이블**: `app_settings`, `table_schemas`
*   **보안**: API 키는 DB가 아닌 **환경 변수** 또는 **.env 파일**을 통해 관리한다.

### 3.2. strategies.sqlite3 (사용자 데이터 및 매매 기록)
*   **목적**: 사용자의 핵심 자산인 트리거, 전략, 포지션, 모든 매매 기록을 저장한다.
*   **주요 테이블**: `triggers`, `strategies`, `positions`, `trades`, `system_events`

### 3.3. market_data.sqlite3 (과거 시세 데이터)
*   **목적**: 백테스팅 및 분석에 사용될 과거 OHLCV 데이터를 저장하고 관리한다.
*   **주요 테이블**: `ohlcv_data` (복합 기본 키: `market`, `interval`, `timestamp`)
*   **성능**: `(market, interval, timestamp)` 복합 인덱스를 생성하여 시계열 데이터 조회 성능을 극대화한다.

---

## 4. 핵심 데이터 모델 정의

시스템의 모든 정보는 아래 데이터 모델을 기반으로 구조화되며, 복잡한 객체는 JSON으로 직렬화하여 TEXT 컬럼에 저장한다.

### 4.1. Trigger 모델
| 필드명 | 데이터 타입 | 필수 | 설명 |
| :--- | :--- | :--- | :--- |
| `trigger_id` | TEXT | O | 트리거 고유 식별자 (PK) |
| `trigger_name` | TEXT | O | 사용자가 식별하는 이름 |
| `description` | TEXT | X | 상세 설명 |
| `base_variable` | TEXT | O | 기준 변수 정보 (JSON) |
| `comparison_operator` | TEXT | O | 비교 연산자 |
| `target_value` | TEXT | O | 대상 값 정보 (JSON) |

### 4.2. Strategy 모델
| 필드명 | 데이터 타입 | 필수 | 설명 |
| :--- | :--- | :--- | :--- |
| `strategy_id` | TEXT | O | 전략 고유 식별자 (PK) |
| `strategy_name` | TEXT | O | 사용자가 식별하는 이름 |
| `entry_triggers` | TEXT | O | 진입 트리거 목록 (JSON) |
| `entry_logic` | TEXT | O | 진입 트리거 조합 논리 (AND/OR) |
| `exit_triggers` | TEXT | O | 청산 트리거 목록 (JSON) |
| `exit_logic` | TEXT | O | 청산 트리거 조합 논리 (AND/OR) |
| `version` | INTEGER | O | 전략 수정 이력 추적용 버전 |

### 4.3. Position 모델
| 필드명 | 데이터 타입 | 필수 | 설명 |
| :--- | :--- | :--- | :--- |
| `position_id` | TEXT | O | 포지션 고유 식별자 (PK) |
| `strategy_snapshot` | TEXT | O | 실행 시점의 Strategy 객체 전체 스냅샷 (JSON) |
| `market` | TEXT | O | 매매 대상 마켓 |
| `status` | TEXT | O | `pending`, `active`, `closing`, `closed`, `error` |
| `initial_capital` | REAL | O | 최초 투입 원금 |
| `total_realized_pnl` | REAL | O | 누적 실현 손익 |

*   **상태 복원**: 프로그램 재시작 시, `trades` 테이블의 거래 기록을 **유일한 진실의 원천(Single Source of Truth)**으로 삼아 메모리상의 포지션 상태(보유 수량, 평단가 등)를 정확하게 재구성한다. 이는 시스템 안정성의 핵심이다.
*   **데이터 무결성**: 거래 체결 시, `trades` 테이블에 **기록을 먼저** 하고, 성공이 확인된 후에만 메모리상의 포지션을 업데이트하여 데이터 유실을 방지한다.
