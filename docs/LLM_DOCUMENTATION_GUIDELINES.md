# 📚 GitHub Copilot Agent 최적화 문서 가이드라인

> **"GitHub Copilot이 이해하기 쉬운 문서가 개발자도 이해하기 쉬운 문서다"**

## 📋 문서 정보

- **문서 유형**: LLM Agent 최적화 가이드라인
- **작성일**: 2025년 8월 14일
- **대상 독자**: GitHub Copilot Agent (우선), 개발자 (2차)
- **중요도**: 높음 (모든 문서 작성 표준)
- **마지막 업데이트**: 2025년 8월 14일

---

## 🎯 핵심 원칙: Agent-First Documentation

### 1. 🚀 **분량 최적화 우선** (Agent 주의력 집중)
- **단일 문서 최대 길이**: 600줄 이하 (LLM 최적 처리 범위)
- **섹션당 최대 길이**: 50줄 이하 (에이전트 집중도 유지)
- **코드 블록 길이**: 10줄 이하 (핵심만 간결하게)
- **예시 개수 제한**: 섹션당 최대 2개 예시 (정보 과부하 방지)
- **이상적 문서 길이**: 200줄 내외 (Agent 한 번에 완전 이해)

### 2. 🔍 **정보 밀도 최적화**
- **핵심 정보 최상단**: 목적과 결론을 먼저 명시
- **계층적 구조**: H2 → H3 → H4 (최대 3단계)
- **키워드 밀도**: 단락당 핵심 키워드 2-3개
- **중복 제거**: 같은 정보를 다른 표현으로 반복 금지

### 3. ⚡ **스캔 최적화**
- **표 활용**: 비교 정보는 반드시 표로 정리
- **불릿 포인트**: 나열 정보는 • 또는 - 사용
- **강조 표시**: **굵게**, `코드`, > 인용문 적극 활용
- **시각적 구분**: 이모지로 섹션과 중요도 표시

---

## 📏 분량 관리 체계

### 🎯 문서 유형별 권장 분량

| 문서 유형 | 최대 분량 | 핵심 섹션 수 | 예시 개수 | 코드 블록 |
|-----------|----------|-------------|-----------|-----------|
| **API 문서** | 300줄 | 4개 이하 | 4개 이하 | 6개 이하 |
| **사용법 가이드** | 200줄 | 3개 이하 | 3개 이하 | 5개 이하 |
| **패턴 설명** | 400줄 | 5개 이하 | 5개 이하 | 8개 이하 |
| **문제 해결** | 150줄 | 2개 이하 | 2개 이하 | 4개 이하 |
| **아키텍처 개요** | 600줄 | 6개 이하 | 6개 이하 | 10개 이하 |

### 📊 분량 초과 시 분할 전략

#### ✂️ 수평 분할 (주제별)
```markdown
# 원본: 거대한_시스템_가이드.md (800줄 → 분할 필요)
├── 시스템_개요.md (200줄)
├── 핵심_패턴.md (250줄)
├── 구현_가이드.md (200줄)
└── 실무_팁.md (150줄)
```

#### 📚 수직 분할 (상세도별)
```markdown
# 계층별 분할
├── README.md (100줄) - 핵심 요약과 네비게이션
├── QUICK_START.md (150줄) - 즉시 시작 가이드
├── CORE_CONCEPTS.md (300줄) - 핵심 개념
└── ADVANCED_TIPS.md (200줄) - 고급 사용법
```

### 🔄 동적 분량 관리 (엄격한 기준)

#### 📈 실시간 분량 체크
```markdown
<!-- 문서 상단에 분량 정보 표시 -->
**현재 분량**: 287줄 / 600줄 (48% 사용) 🟢
**마지막 검토**: 2025-08-14
**다음 분할 예정**: 500줄 도달 시
```

#### 🎯 분량 경고 시스템 (더 엄격)
- **🟢 안전**: 0-200줄 (이상적 범위, 자유롭게 추가)
- **🟡 주의**: 200-400줄 (신중하게 추가, 압축 고려)
- **🔴 위험**: 400-600줄 (분할 검토 필요, 추가 제한)
- **🚫 금지**: 600줄 초과 (즉시 분할 필요)

---

## 🧠 GitHub Copilot 최적화 문법

### 1. 📝 Agent-Friendly 마크다운

#### ✅ 좋은 예시
```markdown
## 🏭 Factory Pattern 구현

### 핵심 개념
Factory Pattern은 객체 생성을 전담하는 패턴입니다.

### 실제 코드
```python
class ServiceFactory:
    @classmethod
    def create_service(cls) -> Service:
        return ConcreteService()
```

### 적용 효과
- 객체 생성 로직 집중화
- 테스트 용이성 향상
```

#### ❌ 나쁜 예시
```markdown
Factory Pattern에 대해 설명하겠습니다. 이 패턴은 GoF 디자인 패턴 중 하나로서 객체 생성에 관련된 패턴입니다. 객체 생성을 캡슐화하고 클라이언트 코드에서 구체적인 클래스에 의존하지 않도록 하는 것이 목적입니다. 실제로 많은 프레임워크에서 사용되고 있으며...
```

### 2. 🔍 정보 구조화 패턴

#### 📊 비교 표 활용
```markdown
| 패턴 | 사용 시기 | 장점 | 단점 |
|------|----------|------|------|
| Factory | 객체 생성 복잡 | 캡슐화 | 복잡성 증가 |
| Singleton | 인스턴스 단일 | 메모리 절약 | 테스트 어려움 |
```

#### 🎯 단계별 프로세스
```markdown
### 구현 단계
1. **인터페이스 정의**: Repository 인터페이스 작성
2. **구현체 생성**: SQLite Repository 구현
3. **팩토리 연결**: DI Container에 등록
4. **테스트 검증**: Mock으로 단위 테스트
```

### 3. 🔄 연관성 명시

#### 🔗 문서 간 연결
```markdown
## 관련 패턴
- **Repository Pattern**: [repository_pattern.md#구현방법]
- **DI Container**: [di_container.md#팩토리연동]
- **테스트 전략**: [testing_guide.md#모킹]
```

#### 📍 코드 위치 명시
```markdown
### 실제 구현 위치
```
upbit_auto_trading/
├── infrastructure/configuration/
│   └── path_service_factory.py  # ← 메인 Factory 구현
└── tests/unit/infrastructure/
    └── test_path_service_factory.py  # ← 테스트 코드
```

---

## 🎨 Agent 친화적 스타일 가이드

### 📝 제목과 섹션

#### 구조화된 제목 체계
```markdown
# 📚 메인 제목 (이모지 + 명확한 주제)
## 🎯 주요 섹션 (목적/개념/구현/결과)
### 📋 하위 섹션 (구체적 내용)
#### 🔹 세부 항목 (예시/코드/설명)
```

#### 이모지 의미 체계
| 이모지 | 의미 | 사용 위치 |
|--------|------|-----------|
| 🎯 | 목적/목표 | 주요 섹션 |
| 🏗️ | 구현/구조 | 기술 내용 |
| 📊 | 분석/비교 | 데이터 표시 |
| ⚡ | 성능/속도 | 최적화 내용 |
| 🔍 | 세부사항 | 상세 설명 |
| 💡 | 팁/인사이트 | 노하우 |
| ⚠️ | 주의사항 | 경고 |
| ✅ | 완료/권장 | 긍정적 내용 |
| ❌ | 금지/비권장 | 부정적 내용 |

### 💻 코드 블록 최적화

#### 적절한 코드 분량 (초간결)
```python
# ✅ 좋음: 핵심만 간결하게 (5-8줄)
class ServiceFactory:
    @classmethod
    def get_service(cls) -> Service:
        if not hasattr(cls, '_instance'):
            cls._instance = ConcreteService()
        return cls._instance
```

#### 코드 설명 패턴 (간결함 우선)
```markdown
```python
# === 핵심 로직 ===
def process(self, data):
    validated = self.validate(data)  # 1. 검증
    return self.transform(validated)  # 2. 변환
```

**포인트**: 한 줄 주석으로 단계 표시
```### 📊 정보 표현 최적화

#### 장단점 표현
```markdown
### Factory Pattern 효과

**✅ 장점**
- 객체 생성 로직 중앙화
- 클라이언트 코드 단순화
- 테스트 용이성 증대

**❌ 단점**
- 초기 설정 복잡성
- 추가 추상화 레이어

**🎯 사용 시기**
- 복잡한 객체 생성이 필요할 때
- 인스턴스 재사용이 중요할 때
```

#### 비교 분석
```markdown
| 방식 | 메모리 사용 | 성능 | 복잡도 | 권장도 |
|------|-------------|------|--------|--------|
| 직접 생성 | 높음 | 보통 | 낮음 | ❌ |
| Factory | 낮음 | 높음 | 보통 | ✅ |
| DI Container | 낮음 | 높음 | 높음 | ✅ |
```

---

## 🚀 Agent 작업 최적화 팁

### 1. 🎯 질의 최적화

#### Agent가 쉽게 찾을 수 있는 키워드 배치
```markdown
<!-- 문서 최상단에 키워드 태그 -->
**핵심 키워드**: Factory Pattern, DI Container, Repository, MVP
**기술 스택**: Python, PyQt6, SQLite, pytest
**적용 레이어**: Infrastructure, Application, Presentation
```

#### 자주 묻는 질문 형태로 구성
```markdown
## 🤔 자주 묻는 질문

### Q: Factory Pattern은 언제 사용하나요?
**A**: 객체 생성이 복잡하거나 인스턴스 재사용이 필요할 때

### Q: Singleton과 Factory의 차이점은?
**A**: Singleton은 인스턴스 개수 제한, Factory는 생성 방식 제어
```

### 2. 📚 문서 네비게이션

#### 문서 맵 제공
```markdown
## 📍 이 문서의 구성

```
1. 개념 설명 (5분 읽기) ← 현재 여기
2. 실제 구현 (10분 읽기)
3. 테스트 방법 (5분 읽기)
4. 실무 팁 (3분 읽기)
```

**전체 예상 읽기 시간**: 23분
```

#### 관련 문서 연결망
```markdown
## 🔗 학습 경로

**기초 → 고급**
1. [DDD 기본 개념](ddd_basics.md) ← 먼저 읽기
2. [Factory Pattern](factory_pattern.md) ← 현재 문서
3. [DI Container](di_container.md) ← 다음 읽기
4. [전체 아키텍처](architecture_overview.md) ← 마지막
```

### 3. 🔄 업데이트 추적

#### 변경 이력 명시
```markdown
## 📝 변경 이력

| 날짜 | 변경 내용 | 영향 범위 |
|------|----------|-----------|
| 2025-08-14 | Factory Pattern 추가 | 전체 시스템 |
| 2025-08-13 | MVP Pattern 개선 | UI Layer |
| 2025-08-12 | Repository 리팩토링 | Infrastructure |
```

#### 의존성 영향도
```markdown
## ⚡ 이 문서 변경 시 함께 확인할 문서

**직접 영향**
- [DI Container 가이드](di_container.md) - Factory 연동 부분
- [테스트 가이드](testing.md) - Factory 모킹 부분

**간접 영향**
- [아키텍처 개요](architecture.md) - 전체 구조 다이어그램
```

---

## 📋 문서 품질 체크리스트

### ✅ Agent 최적화 검증 (엄격 기준)

#### 분량 체크 (강화)
- [ ] 총 분량 600줄 이하
- [ ] 섹션당 50줄 이하
- [ ] 코드 블록당 10줄 이하
- [ ] 예시당 5줄 이하
- [ ] 이상적 목표: 200줄 내외

#### 구조 체크 (핵심 집중)
- [ ] 핵심 정보가 상단 10% 내에 위치
- [ ] 제목 계층이 3단계 이하
- [ ] 불필요한 설명 제거
- [ ] 중복 내용 완전 제거#### 연결성 체크
- [ ] 관련 문서 링크 제공
- [ ] 코드 위치 명시
- [ ] 학습 경로 안내
- [ ] 변경 영향도 표시

### 🎯 사용성 검증

#### Agent 친화성
- [ ] 질문-답변 형태 포함
- [ ] 키워드 태그 배치
- [ ] 단계별 프로세스 명시
- [ ] 비교표 활용

#### 개발자 친화성
- [ ] 실제 코드 예시 포함
- [ ] 실무 팁 제공
- [ ] 주의사항 강조
- [ ] 다음 행동 가이드

---

## 🎉 마무리

이 가이드라인을 따르면:

### 🤖 GitHub Copilot Agent에게는
- **빠른 이해**: 구조화된 정보로 즉시 핵심 파악
- **정확한 답변**: 충분한 컨텍스트로 정밀한 응답
- **효율적 검색**: 키워드와 태그로 빠른 정보 접근

### 👥 개발자에게는
- **빠른 스캔**: 이모지와 표로 정보 구조 즉시 파악
- **실무 적용**: 코드 예시와 팁으로 바로 활용 가능
- **체계적 학습**: 연결된 문서들로 순차적 학습

**"좋은 문서는 Agent와 인간 모두를 위한 다리 역할을 한다"**

---

**문서 유형**: Agent 최적화 가이드라인
**대상**: GitHub Copilot (1차), 개발자 (2차)
**분량**: 285줄 / 600줄 (48% 사용) 🟢
**마지막 업데이트**: 2025년 8월 14일

## 🎯 핵심 원칙 요약

**Agent에게 최적화된 문서란?**
- 📏 **짧고 집중적**: 200줄 내외가 이상적
- 🎯 **핵심부터**: 중요한 정보를 최상단에 배치
- 💡 **구조화**: 표와 리스트로 스캔 가능하게
- 🔄 **분할 우선**: 길어지면 즉시 분할

**"Agent가 한 번에 완전히 이해할 수 있는 문서가 최고의 문서다"**
