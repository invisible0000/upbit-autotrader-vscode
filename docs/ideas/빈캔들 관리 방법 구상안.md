# ğŸ“Š ë¹ˆìº”ë“¤ ê´€ë¦¬ ë°©ë²• êµ¬ìƒì•ˆ

> **ëª©í‘œ**: ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì—ì„œ ê±°ë˜ ì¤‘ë‹¨ êµ¬ê°„ì˜ ë¹ˆ ìº”ë“¤ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë°©ì•ˆ ì„¤ê³„
> **ì‘ì„±ì¼**: 2025ë…„ 9ì›” 17ì¼
> **ë²„ì „**: v1.0
> **ê¸°ë°˜**: CandleDataProvider v6.0 + SqliteCandleRepository ìµœì í™” êµ¬ì¡°

---

## ğŸ¯ 1. ë¬¸ì œ ì •ì˜ ë° ë°°ê²½

### 1.1 í˜„ì¬ ìƒí™© ë¶„ì„

**í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë°œê²¬ì‚¬í•­**:
```
ì´ ìº”ë“¤: 200,000ê°œ
ì‹œê°„ ë²”ìœ„: 200,383ë¶„
ì˜ˆìƒ ìº”ë“¤: 200,384ê°œ
ì™„ì „ì„±: 99.8% (384ê°œ ëˆ„ë½)

Gap í˜„í™©:
- ì´ Gap ê°œìˆ˜: 303ê°œ
- ëˆ„ë½ëœ ì‹œê°„: ì•½ 380ë¶„ (6.3ì‹œê°„)
- ìµœëŒ€ Gap: 358ë¶„ (ì•½ 6ì‹œê°„)
```

### 1.2 ë¹ˆ ìº”ë“¤ì´ ë°œìƒí•˜ëŠ” ì›ì¸

#### **A. ì‹œì¥ íŠ¹ì„±ì— ë”°ë¥¸ ìì—°ì  ë°œìƒ**
- **ì£¼ìš” ì½”ì¸ (BTC, ETH)**: ë“œë¬¼ì§€ë§Œ ì‹œìŠ¤í…œ ì ê²€, ë„¤íŠ¸ì›Œí¬ ì´ìŠˆ ì‹œ ë°œìƒ
- **ë§ˆì´ë„ˆ ì½”ì¸**: ê±°ë˜ëŸ‰ ë¶€ì¡±ìœ¼ë¡œ ë¹ˆë²ˆí•œ ê±°ë˜ ì¤‘ë‹¨
- **íŠ¹ì • ì‹œê°„ëŒ€**: ìƒˆë²½ ì‹œê°„, ì£¼ë§, ê³µíœ´ì¼ ë“± ê±°ë˜ í™œë™ ì €ì¡° ì‹œê°„

#### **B. ê¸°ìˆ ì  ìš”ì¸**
- **ì—…ë¹„íŠ¸ ì„œë²„ ì ê²€**: ì •ê¸°/ê¸´ê¸‰ ì ê²€ ì‹œ ê±°ë˜ ì¼ì‹œ ì¤‘ë‹¨
- **ë„¤íŠ¸ì›Œí¬ ì§€ì—°**: API ìˆ˜ì§‘ ì‹¤íŒ¨ë¡œ ì¸í•œ ë°ì´í„° ì†ì‹¤
- **ì‹œìŠ¤í…œ ì¬ì‹œì‘**: ìë™ë§¤ë§¤ í”„ë¡œê·¸ë¨ ì¬ì‹œì‘ ì¤‘ ëˆ„ë½

#### **C. íƒ€ì„í”„ë ˆì„ë³„ ë°œìƒ ë¹ˆë„**
- **1ì´ˆë´‰**: ë§ˆì´ë„ˆ ì½”ì¸ì—ì„œ ë§¤ìš° ë¹ˆë²ˆ (ê±°ë˜ ì—†ëŠ” ì´ˆ ë‹¤ìˆ˜)
- **1ë¶„ë´‰**: ë§ˆì´ë„ˆ ì½”ì¸ì—ì„œ ê°„í—ì  ë°œìƒ
- **ì‹œê°„ë´‰/ì¼ë´‰**: ê·¹íˆ ë“œë¬¼ì§€ë§Œ ì¥ê¸° ì ê²€ ì‹œ ë°œìƒ

### 1.3 ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ì˜ í•„ìš”ì„±

#### **ğŸ¯ ìë™ë§¤ë§¤ ì „ëµì— ë¯¸ì¹˜ëŠ” ì˜í–¥**

1. **ê¸°ìˆ ì  ì§€í‘œ ì™œê³¡**
   ```python
   # ë¬¸ì œ: Gapìœ¼ë¡œ ì¸í•œ ì§€í‘œ ê³„ì‚° ì˜¤ë¥˜
   sma_20 = calculate_sma(candles[-20:])  # Gap ë•Œë¬¸ì— ì‹¤ì œë¡œëŠ” 25ë¶„ê°„ ë°ì´í„°
   rsi = calculate_rsi(candles)           # ì—°ì†ì„± ê°€ì • ìœ„ë°˜ìœ¼ë¡œ ë¶€ì •í™•
   ```

2. **ë°±í…ŒìŠ¤íŒ… ì •í™•ë„ ì €í•˜**
   ```python
   # ë¬¸ì œ: ì‹¤ì œì™€ ë‹¤ë¥¸ ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½
   backtest_result = run_backtest(incomplete_candles)  # í˜„ì‹¤ê³¼ ê´´ë¦¬ëœ ê²°ê³¼
   ```

3. **ì‹¤ì‹œê°„ ì „ëµ ì‹¤í–‰ ì˜¤ë¥˜**
   ```python
   # ë¬¸ì œ: ì˜ˆìƒ ì‹œì ì— ìº”ë“¤ì´ ì—†ì–´ì„œ ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨
   if current_time_candle is None:
       strategy.skip_current_signal()  # ê¸°íšŒ ì†ì‹¤
   ```

#### **ğŸ“Š ë°ì´í„° ë¶„ì„ ê´€ì ì˜ ë¬¸ì œ**

1. **ì‹œê³„ì—´ ì—°ì†ì„± ìœ„ë°˜**: ì¼ì •í•œ ê°„ê²©ì´ ë³´ì¥ë˜ì§€ ì•ŠìŒ
2. **í†µê³„ì  í¸í–¥**: Gapì´ ìˆëŠ” êµ¬ê°„ì˜ ë³€ë™ì„±ì´ ê³¼ì†Œí‰ê°€ë¨
3. **íŒ¨í„´ ì¸ì‹ ì˜¤ë¥˜**: Gap ì „í›„ ê¸‰ê²©í•œ ë³€í™”ë¥¼ ì˜ëª»ëœ íŒ¨í„´ìœ¼ë¡œ ì¸ì‹

---

## ğŸ—ï¸ 2. í˜„ì¬ ì•„í‚¤í…ì²˜ ë¶„ì„

### 2.1 CandleDataProvider v6.0 êµ¬ì¡°

```python
# í˜„ì¬ ë°ì´í„° í”Œë¡œìš°
ì—…ë¹„íŠ¸ API â†’ CandleDataProvider â†’ OverlapAnalyzer â†’ Repository â†’ SQLite

í•µì‹¬ íŠ¹ì§•:
âœ… ì„±ëŠ¥ ìµœì í™”: ë©”ëª¨ë¦¬ 90% ì ˆì•½
âœ… ì§ì ‘ ì €ì¥: API Dict â†’ DB (ë³€í™˜ ìƒëµ)
âœ… ê²¹ì¹¨ ë¶„ì„: API í˜¸ì¶œ ìµœì í™”
âŒ ë¹ˆ ìº”ë“¤ ë¯¸ì²˜ë¦¬: Gap êµ¬ê°„ ê·¸ëŒ€ë¡œ ë°©ì¹˜
```

### 2.2 SqliteCandleRepository ìµœì í™” êµ¬ì¡°

```python
# ì—°ì†ì„± ë¶„ì„ ë©”ì„œë“œ (ì´ë¯¸ êµ¬í˜„ë¨)
async def find_last_continuous_time()    # ì—°ì† êµ¬ê°„ ëì  íƒì§€
async def is_continue_till_end()        # ë²”ìœ„ ë‚´ ì™„ì „ ì—°ì†ì„± í™•ì¸
async def count_candles_in_range()      # Gap í¬ê¸° ê³„ì‚°
async def has_data_at_time()            # íŠ¹ì • ì‹œì  ë°ì´í„° ì¡´ì¬ í™•ì¸

ì„±ëŠ¥ íŠ¹ì§•:
âœ… LEAD ìœˆë„ìš° í•¨ìˆ˜: 309ë°° ì„±ëŠ¥ í–¥ìƒ
âœ… ì¸ë±ìŠ¤ ìµœì í™”: PRIMARY KEY + timestamp ì¸ë±ìŠ¤
âœ… ë§¤ê°œë³€ìˆ˜í™” ì¿¼ë¦¬: SQL injection ë°©ì§€ + í”Œëœ ìºì‹±
```

### 2.3 ê¸°ì¡´ êµ¬ì¡°ì˜ ì¥ì ê³¼ í•œê³„

#### **ì¥ì **
- **ê³ ì„±ëŠ¥**: ì‹¤ì œ ìº”ë“¤ ìˆ˜ì§‘ê³¼ ì €ì¥ì´ ë§¤ìš° íš¨ìœ¨ì 
- **ì•ˆì •ì„±**: ê²¹ì¹¨ ë¶„ì„ìœ¼ë¡œ API í˜¸ì¶œ ìµœì†Œí™”
- **í™•ì¥ì„±**: Repository íŒ¨í„´ìœ¼ë¡œ ë‹¤ë¥¸ êµ¬í˜„ì²´ êµì²´ ê°€ëŠ¥

#### **í•œê³„**
- **Gap ì¸ì‹ ë¶ˆê°€**: ë¹ˆ êµ¬ê°„ì„ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì§€ ëª»í•¨
- **ì—°ì†ì„± ë³´ì¥ ì—†ìŒ**: ì €ì¥ëœ ë°ì´í„°ë§Œìœ¼ë¡œëŠ” ì™„ì „í•œ ì‹œê³„ì—´ êµ¬ì„± ë¶ˆê°€
- **ì „ëµ í˜¸í™˜ì„±**: ê¸°ì¡´ ì „ëµë“¤ì´ ì—°ì†ì„±ì„ ê°€ì •í•˜ê³  ê°œë°œë¨

---

## ğŸ’¡ 3. ë¹ˆ ìº”ë“¤ ê´€ë¦¬ ë°©ì•ˆ ì„¤ê³„

### 3.1 í•µì‹¬ ì„¤ê³„ ì›ì¹™

1. **ê¸°ì¡´ êµ¬ì¡° ë³´ì¡´**: CandleDataProvider v6.0ì˜ ì„±ëŠ¥ ìµœì í™” ìœ ì§€
2. **ì„ íƒì  ì²˜ë¦¬**: í•„ìš”í•œ ê²½ìš°ì—ë§Œ ë¹ˆ ìº”ë“¤ ìƒì„± (ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”)
3. **íˆ¬ëª…ì„±**: ê¸°ì¡´ ì½”ë“œê°€ ë¹ˆ ìº”ë“¤ì„ ì˜ì‹í•˜ì§€ ì•Šì•„ë„ ë™ì‘
4. **ì„±ëŠ¥ ìš°ì„ **: ë©”ëª¨ë¦¬ì™€ DB ì €ì¥ ê³µê°„ íš¨ìœ¨ì„± ê·¹ëŒ€í™”

### 3.2 3ê°€ì§€ êµ¬í˜„ ë°©ì•ˆ ë¹„êµ

| ë°©ì•ˆ | êµ¬í˜„ ë³µì¡ë„ | ì„±ëŠ¥ | í˜¸í™˜ì„± | ì ìš© ì‹œê¸° |
|------|------------|------|--------|-----------|
| **A. Merge ë°©ì‹** | ì¤‘ê°„ | ë†’ìŒ | ì™„ì „ | ì¦‰ì‹œ ì ìš© |
| **B. Repository í™•ì¥** | ë‚®ìŒ | ì¤‘ê°„ | ë†’ìŒ | ë‹¨ê³„ì  ì ìš© |
| **C. ì»¬ëŸ¼ ìµœì í™”** | ë†’ìŒ | ìµœê³  | ì œí•œì  | ì¥ê¸° ê³„íš |

---

## ğŸ”§ 4. ë°©ì•ˆ A: Merge ë°©ì‹ (ê¶Œì¥)

### 4.1 í•µì‹¬ ì•„ì´ë””ì–´

**API ì‘ë‹µ ë‹¨ê³„ì—ì„œ ë¹ˆ ìº”ë“¤ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ë³‘í•©**

```python
# ë°ì´í„° í”Œë¡œìš° í™•ì¥
ì—…ë¹„íŠ¸ API â†’ [Gap ê°ì§€ + ë¹ˆ ìº”ë“¤ ìƒì„±] â†’ Merge â†’ ê¸°ì¡´ ì €ì¥ ë¡œì§

í•µì‹¬ ì¥ì :
âœ… Repository ë ˆì´ì–´ ë¬´ìˆ˜ì •
âœ… ê¸°ì¡´ ì €ì¥/ì¡°íšŒ ë¡œì§ 100% ì¬í™œìš©
âœ… ë©”ëª¨ë¦¬ ê¸°ë°˜ ê³ ì† ì²˜ë¦¬
âœ… ì„ íƒì  í™œì„±í™” ê°€ëŠ¥
```

### 4.2 CandleData ëª¨ë¸ ìµœì†Œ í™•ì¥

```python
@dataclass
class CandleData:
    # ê¸°ì¡´ ëª¨ë“  í•„ë“œ (market, opening_price, high_price, ...)
    blank_copy_from_utc: Optional[str] = None  # ë¹ˆ ìº”ë“¤ ì‹ë³„ì (NEW)

    def to_db_dict(self) -> dict:
        """DB ì €ì¥ìš© ë”•ì…”ë„ˆë¦¬ ë³€í™˜ (ë¹ˆ ìº”ë“¤ ìµœì í™”)"""
        if self.blank_copy_from_utc is not None:
            # ë¹ˆ ìº”ë“¤: í•„ìˆ˜ í•„ë“œë§Œ, ë‚˜ë¨¸ì§€ëŠ” NULL
            return {
                "candle_date_time_utc": self.candle_date_time_utc,
                "blank_copy_from_utc": self.blank_copy_from_utc,
                "market": None,
                "opening_price": None,
                # ... ëª¨ë“  ê±°ë˜ ë°ì´í„°ëŠ” NULL
            }
        else:
            # ì‹¤ì œ ìº”ë“¤: ê¸°ì¡´ ë¡œì§ ì™„ì „íˆ ê·¸ëŒ€ë¡œ
            return {
                "candle_date_time_utc": self.candle_date_time_utc,
                "market": self.market,
                "opening_price": self.opening_price,
                # ... ëª¨ë“  ì‹¤ì œ ê±°ë˜ ë°ì´í„°
                "blank_copy_from_utc": None
            }

    def is_empty_candle(self) -> bool:
        """ë¹ˆ ìº”ë“¤ ì—¬ë¶€ í™•ì¸"""
        return self.blank_copy_from_utc is not None

    @classmethod
    def create_empty_candle(cls, target_time: datetime, reference_utc: str, timeframe: str):
        """ë¹ˆ ìº”ë“¤ ìƒì„± íŒ©í† ë¦¬ ë©”ì„œë“œ"""
        return cls(
            candle_date_time_utc=target_time.strftime('%Y-%m-%dT%H:%M:%S'),
            market=None,
            opening_price=None,
            high_price=None,
            low_price=None,
            trade_price=None,
            timestamp=None,
            candle_acc_trade_price=None,
            candle_acc_trade_volume=None,
            blank_copy_from_utc=reference_utc,
            symbol=None,
            timeframe=timeframe
        )
```

### 4.3 Gap ê°ì§€ ë° ë¹ˆ ìº”ë“¤ ìƒì„± ë¡œì§

```python
class EmptyCandleProcessor:
    """ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ì „ë‹´ í´ë˜ìŠ¤ (CandleDataProviderì— í†µí•©)"""

    def __init__(self, timeframe: str):
        self.timeframe = timeframe
        self.gap_threshold_ms = self._get_gap_threshold(timeframe)

    def _get_gap_threshold(self, timeframe: str) -> int:
        """íƒ€ì„í”„ë ˆì„ë³„ Gap ì„ê³„ê°’ (ë°€ë¦¬ì´ˆ)"""
        thresholds = {
            '1s': 1500,      # 1.5ì´ˆ
            '1m': 90000,     # 90ì´ˆ
            '3m': 270000,    # 270ì´ˆ
            '5m': 450000,    # 450ì´ˆ
            '15m': 1350000,  # 22.5ë¶„
            '1h': 5400000,   # 90ë¶„
            '1d': 129600000, # 36ì‹œê°„
        }
        return thresholds.get(timeframe, 90000)

    def detect_gaps_in_api_response(self, api_candles: List[Dict]) -> List[Tuple]:
        """API ì‘ë‹µ ìº”ë“¤ë“¤ ì‚¬ì´ì˜ Gap ê°ì§€"""
        if len(api_candles) < 2:
            return []

        # ì—…ë¹„íŠ¸ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ í™•ì¸ (ìµœì‹  â†’ ê³¼ê±°)
        sorted_candles = sorted(api_candles,
                               key=lambda x: x["candle_date_time_utc"],
                               reverse=True)

        gaps = []
        for i in range(len(sorted_candles) - 1):
            current_time = self._parse_utc_time(sorted_candles[i]["candle_date_time_utc"])
            next_time = self._parse_utc_time(sorted_candles[i + 1]["candle_date_time_utc"])

            # ì˜ˆìƒ ë‹¤ìŒ ìº”ë“¤ ì‹œê°„
            expected_next = TimeUtils.get_previous_candle_time(current_time, self.timeframe)

            # Gap ê°ì§€: ì‹¤ì œ ë‹¤ìŒ ìº”ë“¤ì´ ì˜ˆìƒë³´ë‹¤ ê³¼ê±°ì— ìˆìŒ
            if next_time < expected_next:
                gaps.append((
                    next_time,        # Gap ì‹œì‘ (ê³¼ê±°)
                    expected_next,    # Gap ì¢…ë£Œ (ë¯¸ë˜)
                    sorted_candles[i + 1]["candle_date_time_utc"]  # ì°¸ì¡° ìº”ë“¤
                ))

        return gaps

    def generate_empty_candles_from_gaps(self, gaps: List[Tuple]) -> List[CandleData]:
        """Gap êµ¬ê°„ì—ì„œ ë¹ˆ ìº”ë“¤ë“¤ ìƒì„±"""
        all_empty_candles = []

        for gap_start, gap_end, reference_utc in gaps:
            current_time = TimeUtils.get_next_candle_time(gap_start, self.timeframe)

            while current_time < gap_end:
                empty_candle = CandleData.create_empty_candle(
                    target_time=current_time,
                    reference_utc=reference_utc,
                    timeframe=self.timeframe
                )
                all_empty_candles.append(empty_candle)

                current_time = TimeUtils.get_next_candle_time(current_time, self.timeframe)

        return all_empty_candles

    def merge_real_and_empty_candles(self, api_candles: List[Dict],
                                     empty_candles: List[CandleData]) -> List[CandleData]:
        """ì‹¤ì œ ìº”ë“¤ê³¼ ë¹ˆ ìº”ë“¤ ë³‘í•©"""
        # 1. API ì‘ë‹µì„ CandleData ê°ì²´ë¡œ ë³€í™˜
        real_candle_objects = [
            CandleData.from_upbit_api(candle_dict, self.timeframe)
            for candle_dict in api_candles
        ]

        # 2. ì‹¤ì œ + ë¹ˆ ìº”ë“¤ ë³‘í•©
        all_candles = real_candle_objects + empty_candles

        # 3. ì—…ë¹„íŠ¸ í‘œì¤€ ì •ë ¬ ìœ ì§€ (ìµœì‹  â†’ ê³¼ê±°)
        sorted_candles = sorted(
            all_candles,
            key=lambda x: x.candle_date_time_utc,
            reverse=True
        )

        return sorted_candles

    def process_api_response(self, api_candles: List[Dict]) -> List[CandleData]:
        """API ì‘ë‹µ ì „ì²´ ì²˜ë¦¬ (Gap ê°ì§€ â†’ ë¹ˆ ìº”ë“¤ ìƒì„± â†’ ë³‘í•©)"""
        if len(api_candles) < 2:
            # Gap ê²€ì‚¬ ë¶ˆê°€ëŠ¥í•œ ê²½ìš° ê¸°ì¡´ ë¡œì§
            return [CandleData.from_upbit_api(candle, self.timeframe)
                    for candle in api_candles]

        # 1. Gap ê°ì§€
        gaps = self.detect_gaps_in_api_response(api_candles)

        if not gaps:
            # Gap ì—†ìœ¼ë©´ ê¸°ì¡´ ë¡œì§
            return [CandleData.from_upbit_api(candle, self.timeframe)
                    for candle in api_candles]

        # 2. ë¹ˆ ìº”ë“¤ ìƒì„±
        empty_candles = self.generate_empty_candles_from_gaps(gaps)

        # 3. ë³‘í•© ë° ì •ë ¬
        merged_candles = self.merge_real_and_empty_candles(api_candles, empty_candles)

        logger.info(f"ë¹ˆ ìº”ë“¤ ë³‘í•© ì™„ë£Œ: ì‹¤ì œ {len(api_candles)}ê°œ + ë¹ˆ {len(empty_candles)}ê°œ")

        return merged_candles
```

### 4.4 CandleDataProvider í†µí•©

```python
class CandleDataProvider:
    """v6.0 + ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ê¸°ëŠ¥ í™•ì¥"""

    def __init__(self, repository, upbit_client, overlap_analyzer,
                 chunk_size=200, enable_empty_candle_processing=True):
        # ê¸°ì¡´ ì´ˆê¸°í™” ì½”ë“œ...

        self.enable_empty_candle_processing = enable_empty_candle_processing
        self.empty_processors = {}  # timeframeë³„ í”„ë¡œì„¸ì„œ ìºì‹œ

    def _get_empty_candle_processor(self, timeframe: str) -> EmptyCandleProcessor:
        """íƒ€ì„í”„ë ˆì„ë³„ ë¹ˆ ìº”ë“¤ í”„ë¡œì„¸ì„œ ìºì‹œ"""
        if timeframe not in self.empty_processors:
            self.empty_processors[timeframe] = EmptyCandleProcessor(timeframe)
        return self.empty_processors[timeframe]

    async def _process_chunk_with_empty_candles(self,
                                                chunk_info: ChunkInfo,
                                                state: CollectionState,
                                                is_first_chunk: bool,
                                                request_type: RequestType) -> tuple[int, Optional[str]]:
        """ì²­í¬ ì²˜ë¦¬ + ë¹ˆ ìº”ë“¤ í†µí•© (ê¸°ì¡´ _process_chunk_direct_storage í™•ì¥)"""

        # === ê¸°ì¡´ ê²¹ì¹¨ ë¶„ì„ ë¡œì§ (ì™„ì „íˆ ë™ì¼) ===
        overlap_result = None
        chunk_end = None
        if not (is_first_chunk and request_type in [RequestType.COUNT_ONLY, RequestType.END_ONLY]):
            chunk_start = chunk_info.to
            chunk_end = self._calculate_chunk_end_time(chunk_info)
            overlap_result = await self._analyze_chunk_overlap(
                state.symbol, state.timeframe, chunk_start, chunk_end
            )

        # === API ë°ì´í„° ìˆ˜ì§‘ (ê¸°ì¡´ê³¼ ë™ì¼) ===
        if overlap_result and hasattr(overlap_result, 'status'):
            # ê²¹ì¹¨ ë¶„ì„ ê²°ê³¼ì— ë”°ë¥¸ API í˜¸ì¶œ
            api_candles = await self._handle_overlap_api_fetch(chunk_info, overlap_result, chunk_end)
        else:
            # í´ë°±: ì „ì²´ API í˜¸ì¶œ
            api_candles = await self._fetch_chunk_from_api(chunk_info)

        # === ğŸ†• ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ (ìƒˆë¡œìš´ ì „ì²˜ë¦¬ ë¡œì§) ===
        final_candles = api_candles  # ê¸°ë³¸ê°’

        if self.enable_empty_candle_processing and len(api_candles) >= 2:
            processor = self._get_empty_candle_processor(state.timeframe)
            final_candles = processor.process_api_response(api_candles)
            logger.debug(f"ë¹ˆ ìº”ë“¤ ì²˜ë¦¬: {len(api_candles)}ê°œ â†’ {len(final_candles)}ê°œ")

        # === ê¸°ì¡´ ì €ì¥ ë¡œì§ (ì™„ì „íˆ ë™ì¼, Repository ë¬´ë³€ê²½) ===
        saved_count = await self.repository.save_candle_chunk(
            state.symbol, state.timeframe, final_candles  # ì‹¤ì œ+ë¹ˆ ìº”ë“¤ í˜¼í•©
        )

        # ì—°ì†ì„±ì„ ìœ„í•œ ë§ˆì§€ë§‰ ìº”ë“¤ ì‹œê°„ ì¶”ì¶œ
        last_candle_time = None
        if final_candles:
            last_candle_time = final_candles[-1].candle_date_time_utc

        return saved_count, last_candle_time

    async def mark_chunk_completed(self, request_id: str) -> bool:
        """ì²­í¬ ì™„ë£Œ ì²˜ë¦¬ - ë¹ˆ ìº”ë“¤ í†µí•© ë²„ì „"""
        # ê¸°ì¡´ ìƒíƒœ ê´€ë¦¬ ë¡œì§...

        try:
            # ğŸ†• ë¹ˆ ìº”ë“¤ í†µí•© ì²˜ë¦¬
            saved_count, last_candle_time = await self._process_chunk_with_empty_candles(
                state.current_chunk, state, is_first_chunk, request_type
            )

            # ê¸°ì¡´ ì™„ë£Œ ì²˜ë¦¬ ë¡œì§ (ì™„ì „íˆ ë™ì¼)...

        except Exception as e:
            # ê¸°ì¡´ ì—ëŸ¬ ì²˜ë¦¬...
```

### 4.5 DB ìŠ¤í‚¤ë§ˆ í™•ì¥

```sql
-- ê¸°ì¡´ í…Œì´ë¸”ì— ë¹ˆ ìº”ë“¤ ì‹ë³„ ì»¬ëŸ¼ ì¶”ê°€
ALTER TABLE candles_KRW_BTC_1m
ADD COLUMN blank_copy_from_utc TEXT NULL;

-- ë¹ˆ ìº”ë“¤ ì¡°íšŒ ìµœì í™” ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_empty_candles_KRW_BTC_1m
ON candles_KRW_BTC_1m(blank_copy_from_utc)
WHERE blank_copy_from_utc IS NOT NULL;

-- ë°ì´í„° ì˜ˆì‹œ
candle_date_time_utc    | market  | opening_price | blank_copy_from_utc
2025-09-09T01:00:00    | KRW-BTC | 67500.0       | NULL              -- ì‹¤ì œ ìº”ë“¤
2025-09-09T00:59:00    | NULL    | NULL          | 2025-09-09T01:00:00  -- ë¹ˆ ìº”ë“¤
2025-09-09T00:58:00    | NULL    | NULL          | 2025-09-09T01:00:00  -- ë¹ˆ ìº”ë“¤
2025-09-09T00:57:00    | KRW-BTC | 67480.0       | NULL              -- ì‹¤ì œ ìº”ë“¤
```

---

## âš¡ 5. ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 5.1 ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±

```python
# ë¹ˆ ìº”ë“¤ì€ ìµœì†Œí•œì˜ ë°ì´í„°ë§Œ ì €ì¥
empty_candle_size = 2 * í•„ë“œ  # candle_date_time_utc + blank_copy_from_utc
real_candle_size = 10+ * í•„ë“œ  # ëª¨ë“  ê±°ë˜ ë°ì´í„°

ë©”ëª¨ë¦¬ ì ˆì•½ë¥  = (10 - 2) / 10 = 80%

# ì‹¤ì œ ì‚¬ë¡€: 380ë¶„ Gap = 380ê°œ ë¹ˆ ìº”ë“¤
ê¸°ì¡´ ì €ì¥ ê³µê°„: 380 Ã— ì „ì²´ í•„ë“œ í¬ê¸°
ë¹ˆ ìº”ë“¤ ì €ì¥ ê³µê°„: 380 Ã— 2ê°œ í•„ë“œ = ê¸°ì¡´ì˜ 20%
```

### 5.2 DB ì €ì¥ ìµœì í™”

```sql
-- ì‹¤ì œ ìº”ë“¤ë§Œ ì¡°íšŒ (ê°€ì¥ ë¹ˆë²ˆí•œ ì‚¬ìš©)
SELECT * FROM candles
WHERE candle_date_time_utc BETWEEN ? AND ?
  AND blank_copy_from_utc IS NULL;  -- ë¹ˆ ìº”ë“¤ ì œì™¸

-- ë¹ˆ ìº”ë“¤ í¬í•¨ ì „ì²´ ì¡°íšŒ (ì‹œê³„ì—´ ë¶„ì„ìš©)
SELECT * FROM candles
WHERE candle_date_time_utc BETWEEN ? AND ?
ORDER BY candle_date_time_utc DESC;

-- ë¹ˆ ìº”ë“¤ í†µê³„ ì¡°íšŒ
SELECT COUNT(*) as empty_count,
       COUNT(DISTINCT blank_copy_from_utc) as gap_count
FROM candles
WHERE blank_copy_from_utc IS NOT NULL;
```

### 5.3 ì²˜ë¦¬ ì„±ëŠ¥ ìµœì í™”

```python
# Gap ê°ì§€: O(n) ì‹œê°„ ë³µì¡ë„
def detect_gaps_optimized(candles: List[Dict]) -> List[Tuple]:
    """ì„ í˜• ì‹œê°„ Gap ê°ì§€"""
    gaps = []
    prev_time = None

    for candle in sorted_candles:
        current_time = parse_time(candle["candle_date_time_utc"])

        if prev_time:
            expected_time = TimeUtils.get_previous_candle_time(prev_time, timeframe)
            if current_time < expected_time:
                gaps.append((current_time, expected_time, candle["candle_date_time_utc"]))

        prev_time = current_time

    return gaps

# ë¹ˆ ìº”ë“¤ ìƒì„±: ë°°ì¹˜ ì²˜ë¦¬ ìµœì í™”
def generate_empty_candles_batch(gaps: List[Tuple]) -> List[CandleData]:
    """ë°°ì¹˜ ë°©ì‹ ë¹ˆ ìº”ë“¤ ìƒì„±"""
    empty_candles = []

    for gap_start, gap_end, reference_utc in gaps:
        # TimeUtils.generate_time_series() í™œìš©í•œ ë°°ì¹˜ ìƒì„±
        time_series = TimeUtils.generate_time_series(gap_start, gap_end, timeframe)

        for target_time in time_series:
            empty_candle = CandleData.create_empty_candle(target_time, reference_utc, timeframe)
            empty_candles.append(empty_candle)

    return empty_candles
```

---

## ğŸ”„ 6. êµ¬í˜„ ê³„íš ë° ë§ˆì´ê·¸ë ˆì´ì…˜

### 6.1 Phase 1: ëª¨ë¸ í™•ì¥ (1ì¼)

```python
# ì‘ì—… ëª©ë¡
âœ… CandleDataì— blank_copy_from_utc í•„ë“œ ì¶”ê°€
âœ… to_db_dict() ë©”ì„œë“œ ì¡°ê±´ë¶€ ì²˜ë¦¬ ë¡œì§
âœ… is_empty_candle(), create_empty_candle() ë©”ì„œë“œ ì¶”ê°€
âœ… ê¸°ë³¸ ìœ ë‹› í…ŒìŠ¤íŠ¸ ì‘ì„±
```

### 6.2 Phase 2: EmptyCandleProcessor êµ¬í˜„ (2ì¼)

```python
# ì‘ì—… ëª©ë¡
âœ… Gap ê°ì§€ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
âœ… ë¹ˆ ìº”ë“¤ ìƒì„± ë¡œì§ êµ¬í˜„
âœ… ì‹¤ì œ+ë¹ˆ ìº”ë“¤ ë³‘í•© ë¡œì§ êµ¬í˜„
âœ… íƒ€ì„í”„ë ˆì„ë³„ ì„ê³„ê°’ ì„¤ì •
âœ… ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (1000ê°œ ìº”ë“¤ ê¸°ì¤€)
```

### 6.3 Phase 3: CandleDataProvider í†µí•© (1ì¼)

```python
# ì‘ì—… ëª©ë¡
âœ… enable_empty_candle_processing ì˜µì…˜ ì¶”ê°€
âœ… _process_chunk_with_empty_candles ë©”ì„œë“œ êµ¬í˜„
âœ… ê¸°ì¡´ mark_chunk_completed ìˆ˜ì • ìµœì†Œí™”
âœ… í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸ (ê¸°ì¡´ ê¸°ëŠ¥ ì˜í–¥ ì—†ìŒ í™•ì¸)
```

### 6.4 Phase 4: DB ë§ˆì´ê·¸ë ˆì´ì…˜ (0.5ì¼)

```sql
-- ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸
ALTER TABLE candles_KRW_BTC_1m ADD COLUMN blank_copy_from_utc TEXT NULL;
ALTER TABLE candles_KRW_ETH_1m ADD COLUMN blank_copy_from_utc TEXT NULL;
-- ... ëª¨ë“  í…Œì´ë¸”ì— ì ìš©

CREATE INDEX idx_empty_candles_KRW_BTC_1m
ON candles_KRW_BTC_1m(blank_copy_from_utc)
WHERE blank_copy_from_utc IS NOT NULL;
-- ... ëª¨ë“  í…Œì´ë¸”ì— ì¸ë±ìŠ¤ ìƒì„±
```

### 6.5 Phase 5: í†µí•© í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ (1ì¼)

```python
# í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
âœ… ê¸°ì¡´ ê¸°ëŠ¥ í˜¸í™˜ì„± (ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ OFF)
âœ… Gapì´ ì—†ëŠ” ì •ìƒ ì¼€ì´ìŠ¤ (ì˜¤ë²„í—¤ë“œ í™•ì¸)
âœ… ì‘ì€ Gapì´ ìˆëŠ” ì¼€ì´ìŠ¤ (1-5ë¶„ Gap)
âœ… í° Gapì´ ìˆëŠ” ì¼€ì´ìŠ¤ (1ì‹œê°„+ Gap)
âœ… ë§ˆì´ë„ˆ ì½”ì¸ 1ì´ˆë´‰ ì‹œë‚˜ë¦¬ì˜¤
âœ… ëŒ€ëŸ‰ ë°ì´í„° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
```

---

## ğŸ“Š 7. ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ ë° í™œìš© ë°©ì•ˆ

### 7.1 ë°±í…ŒìŠ¤íŒ… ì •í™•ë„ í–¥ìƒ

```python
# Before: Gapìœ¼ë¡œ ì¸í•œ ë¶€ì •í™•í•œ ë°±í…ŒìŠ¤íŒ…
def backtest_with_gaps():
    candles = get_candles("KRW-BTC", "1m", count=10000)  # Gap í¬í•¨
    sma_20 = calculate_sma(candles[-20:])  # ì‹¤ì œë¡œëŠ” 25ë¶„ ë°ì´í„°
    return simulate_trading(candles, sma_20)  # ë¶€ì •í™•í•œ ê²°ê³¼

# After: ì™„ì „í•œ ì‹œê³„ì—´ë¡œ ì •í™•í•œ ë°±í…ŒìŠ¤íŒ…
def backtest_with_complete_series():
    candles = get_candles_with_empty("KRW-BTC", "1m", count=10000)  # ì™„ì „í•œ ì‹œê³„ì—´
    sma_20 = calculate_sma(candles[-20:])  # ì •í™•íˆ 20ë¶„ ë°ì´í„°
    return simulate_trading(candles, sma_20)  # ì •í™•í•œ ê²°ê³¼
```

### 7.2 ì‹¤ì‹œê°„ ì „ëµ ì‹¤í–‰ ì•ˆì •ì„±

```python
# Before: Gapìœ¼ë¡œ ì¸í•œ ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨
def execute_strategy_with_gaps():
    try:
        current_candle = get_latest_candle("KRW-BTC", "1m")
        if current_candle is None:  # Gap ë°œìƒ
            logger.warning("ìº”ë“¤ ì—†ìŒ, ì „ëµ ì‹¤í–‰ ê±´ë„ˆëœ€")
            return None
        return strategy.execute(current_candle)
    except Exception:
        return None

# After: ì™„ì „í•œ ì‹œê³„ì—´ë¡œ ì•ˆì •ì  ì „ëµ ì‹¤í–‰
def execute_strategy_with_complete_series():
    current_candle = get_latest_candle_with_empty("KRW-BTC", "1m")
    # ë¹ˆ ìº”ë“¤ì´ë¼ë„ ì‹œê³„ì—´ì€ ìœ ì§€ë¨
    return strategy.execute_safe(current_candle)
```

### 7.3 ë§ˆì´ë„ˆ ì½”ì¸ 1ì´ˆë´‰ ì§€ì›

```python
# ë§ˆì´ë„ˆ ì½”ì¸ì˜ ì‚°ë°œì  ê±°ë˜ íŒ¨í„´ ì²˜ë¦¬
def collect_minor_coin_data():
    provider = CandleDataProvider(
        enable_empty_candle_processing=True  # ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ í™œì„±í™”
    )

    # 1ì´ˆë´‰ ìˆ˜ì§‘ (ë§ì€ Gap ì˜ˆìƒ)
    candles = await provider.get_candles("KRW-MINOR", "1s", count=3600)  # 1ì‹œê°„

    # ê²°ê³¼: ì‹¤ì œ ê±°ë˜ + ë¹ˆ ìº”ë“¤ë¡œ ì™„ì „í•œ 3600ê°œ ì‹œê³„ì—´
    assert len(candles) == 3600
    assert all(c.is_consecutive() for c in candles)
```

---

## ğŸ›ï¸ 8. ì„¤ì • ë° ì œì–´ ì˜µì…˜

### 8.1 ì „ì—­ ì„¤ì •

```python
# config/candle_config.yaml
empty_candle_processing:
  enabled: true

  # íƒ€ì„í”„ë ˆì„ë³„ í™œì„±í™”
  timeframes:
    "1s": true   # 1ì´ˆë´‰: í•„ìˆ˜ (ë§ˆì´ë„ˆ ì½”ì¸)
    "1m": true   # 1ë¶„ë´‰: ê¶Œì¥
    "5m": false  # 5ë¶„ë´‰: ì„ íƒì 
    "1h": false  # ì‹œê°„ë´‰: ë¶ˆí•„ìš”
    "1d": false  # ì¼ë´‰: ë¶ˆí•„ìš”

  # ì„±ëŠ¥ ì œì–´
  max_gap_size_minutes: 1440  # ìµœëŒ€ ì²˜ë¦¬í•  Gap í¬ê¸° (24ì‹œê°„)
  batch_size: 1000           # ë¹ˆ ìº”ë“¤ ë°°ì¹˜ ìƒì„± í¬ê¸°
```

### 8.2 ëŸ°íƒ€ì„ ì œì–´

```python
# ë™ì  í™œì„±í™”/ë¹„í™œì„±í™”
provider = CandleDataProvider()

# íŠ¹ì • ìš”ì²­ì—ì„œë§Œ ë¹ˆ ìº”ë“¤ ì²˜ë¦¬
candles_with_empty = await provider.get_candles(
    "KRW-BTC", "1m", count=1000,
    enable_empty_processing=True  # ì´ ìš”ì²­ë§Œ ì ìš©
)

# ì „ì—­ ì„¤ì • ë³€ê²½
provider.set_empty_candle_processing(False)  # ì„ì‹œ ë¹„í™œì„±í™”
```

### 8.3 ì¡°íšŒ ì˜µì…˜

```python
# Repository ë ˆë²¨ ì¡°íšŒ ì œì–´
repository = SqliteCandleRepository(db_manager)

# ì‹¤ì œ ìº”ë“¤ë§Œ ì¡°íšŒ (ê¸°ë³¸ ë™ì‘)
real_only = await repository.get_candles_by_range(
    "KRW-BTC", "1m", start_time, end_time,
    include_empty_candles=False  # ê¸°ë³¸ê°’
)

# ë¹ˆ ìº”ë“¤ í¬í•¨ ì „ì²´ ì¡°íšŒ (ì‹œê³„ì—´ ë¶„ì„ìš©)
complete_series = await repository.get_candles_by_range(
    "KRW-BTC", "1m", start_time, end_time,
    include_empty_candles=True
)

# ë¹ˆ ìº”ë“¤ë§Œ ì¡°íšŒ (ë””ë²„ê¹…/í†µê³„ìš©)
empty_only = await repository.get_empty_candles_by_range(
    "KRW-BTC", "1m", start_time, end_time
)
```

---

## âœ… 9. í•µì‹¬ ì¥ì  ë° ê¸°ëŒ€ íš¨ê³¼

### 9.1 ì•„í‚¤í…ì²˜ì  ì¥ì 

- **ê¸°ì¡´ ì½”ë“œ ë³´ì¡´**: Repository ë ˆì´ì–´ 100% ë¬´ë³€ê²½
- **ì„ íƒì  ì ìš©**: í•„ìš”í•œ ê²½ìš°ì—ë§Œ í™œì„±í™”ë¡œ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”
- **íˆ¬ëª…í•œ ì²˜ë¦¬**: ê¸°ì¡´ ì „ëµ ì½”ë“œê°€ ë¹ˆ ìº”ë“¤ì„ ì˜ì‹í•˜ì§€ ì•Šì•„ë„ ë™ì‘
- **í™•ì¥ ê°€ëŠ¥**: ë‹¤ë¥¸ ë°ì´í„° ë³´ê°• ë¡œì§ë„ ê°™ì€ íŒ¨í„´ìœ¼ë¡œ ì¶”ê°€ ê°€ëŠ¥

### 9.2 ì„±ëŠ¥ì  ì¥ì 

- **ë©”ëª¨ë¦¬ íš¨ìœ¨**: ë¹ˆ ìº”ë“¤ì€ ì‹¤ì œ ìº”ë“¤ ëŒ€ë¹„ 20% ì €ì¥ê³µê°„ë§Œ ì‚¬ìš©
- **ì²˜ë¦¬ ì†ë„**: ë©”ëª¨ë¦¬ ê¸°ë°˜ Gap ê°ì§€ë¡œ ë°€ë¦¬ì´ˆ ë‹¨ìœ„ ì²˜ë¦¬
- **DB ìµœì í™”**: ê¸°ì¡´ ì¸ë±ìŠ¤ í™œìš© + ë¹ˆ ìº”ë“¤ ì „ìš© ì¸ë±ìŠ¤ë¡œ ë¹ ë¥¸ ì¡°íšŒ
- **ìºì‹± íš¨ê³¼**: íƒ€ì„í”„ë ˆì„ë³„ í”„ë¡œì„¸ì„œ ìºì‹œë¡œ ì¤‘ë³µ ê³„ì‚° ì œê±°

### 9.3 ë¹„ì¦ˆë‹ˆìŠ¤ì  ì¥ì 

- **ì „ëµ ì •í™•ë„**: ì™„ì „í•œ ì‹œê³„ì—´ë¡œ ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° ì •í™•ë„ í–¥ìƒ
- **ë°±í…ŒìŠ¤íŒ… ì‹ ë¢°ì„±**: ì‹¤ì œ ê±°ë˜ í™˜ê²½ê³¼ ë™ì¼í•œ ì¡°ê±´ì—ì„œ ì‹œë®¬ë ˆì´ì…˜
- **ë§ˆì´ë„ˆ ì½”ì¸ ì§€ì›**: 1ì´ˆë´‰ ê±°ë˜ê°€ ê°€ëŠ¥í•œ ì™„ì „í•œ ì¸í”„ë¼ êµ¬ì¶•
- **ìš´ì˜ ì•ˆì •ì„±**: Gapìœ¼ë¡œ ì¸í•œ ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨ ë°©ì§€

---

## ğŸš€ 10. ê²°ë¡  ë° ë‹¤ìŒ ë‹¨ê³„

### 10.1 í•µì‹¬ ê°€ì¹˜ ì œì•ˆ

ì´ **Merge ë°©ì‹ ë¹ˆ ìº”ë“¤ ì²˜ë¦¬**ëŠ” ë‹¤ìŒ 3ê°€ì§€ í•µì‹¬ ê°€ì¹˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤:

1. **ì™„ì „ì„±**: ëª¨ë“  ì‹œì ì— ëŒ€í•´ ì¼ê´€ëœ ìº”ë“¤ ë°ì´í„° ë³´ì¥
2. **íš¨ìœ¨ì„±**: ê¸°ì¡´ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ ì§€í•˜ë©´ì„œ ì¶”ê°€ ê¸°ëŠ¥ ì œê³µ
3. **íˆ¬ëª…ì„±**: ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ì´ í–¥ìƒëœ ë°ì´í„° í’ˆì§ˆ ì œê³µ

### 10.2 ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ íš¨ê³¼

**í˜„ì¬ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê¸°ì¤€**:
- Gap 303ê°œ â†’ 0ê°œë¡œ ì™„ì „ í•´ê²°
- ëˆ„ë½ ì‹œê°„ 380ë¶„ â†’ ì™„ì „í•œ ì‹œê³„ì—´ë¡œ ë³µì›
- ë°ì´í„° ì™„ì „ì„± 99.8% â†’ 100% ë‹¬ì„±

### 10.3 ì‹¤í–‰ ê³„íš

**Week 1-2**: Phase 1-3 (ëª¨ë¸ + í”„ë¡œì„¸ì„œ + í†µí•©)
**Week 3**: Phase 4-5 (DB ë§ˆì´ê·¸ë ˆì´ì…˜ + í…ŒìŠ¤íŠ¸)
**Week 4**: ìš´ì˜ í™˜ê²½ ì ìš© ë° ëª¨ë‹ˆí„°ë§

### 10.4 ì„±ê³µ ì§€í‘œ

âœ… **ê¸°ëŠ¥ì  ì§€í‘œ**: Gap ê°œìˆ˜ 0ê°œ, ì‹œê³„ì—´ ì™„ì „ì„± 100%
âœ… **ì„±ëŠ¥ ì§€í‘œ**: ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€ <5%, ì²˜ë¦¬ ì‹œê°„ ì¦ê°€ <10%
âœ… **ì•ˆì •ì„± ì§€í‘œ**: ê¸°ì¡´ ê¸°ëŠ¥ í˜¸í™˜ì„± 100%, ì—ëŸ¬ìœ¨ ë³€í™” ì—†ìŒ

---

**ğŸ’¡ í•µì‹¬ ë©”ì‹œì§€**: ì´ ë°©ì•ˆì€ ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì„ **"ê±°ë˜ ì¤‘ë‹¨ì´ ìˆì–´ë„ ì™„ì „í•œ ì‹œê³„ì—´ì„ ë³´ì¥í•˜ëŠ” ê²¬ê³ í•œ ì‹œìŠ¤í…œ"**ìœ¼ë¡œ ë°œì „ì‹œí‚¤ëŠ” í•µì‹¬ ì¸í”„ë¼ì…ë‹ˆë‹¤.

ê¸°ì¡´ì˜ ë›°ì–´ë‚œ ì„±ëŠ¥ê³¼ ì•ˆì •ì„±ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë©´ì„œ, ë¹ˆ ìº”ë“¤ ë¬¸ì œë¥¼ ìš°ì•„í•˜ê²Œ í•´ê²°í•˜ì—¬ **ëª¨ë“  ìë™ë§¤ë§¤ ì „ëµì´ ì™„ì „í•œ ë°ì´í„° í™˜ê²½ì—ì„œ ë™ì‘í•  ìˆ˜ ìˆë„ë¡** ë³´ì¥í•©ë‹ˆë‹¤. ğŸ¯âœ¨
