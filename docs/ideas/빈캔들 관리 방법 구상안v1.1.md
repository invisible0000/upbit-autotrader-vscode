# ğŸ“Š ë¹ˆìº”ë“¤ ê´€ë¦¬ ë°©ë²• êµ¬ìƒì•ˆ v1.1

> **ëª©í‘œ**: ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì—ì„œ ê±°ë˜ ì¤‘ë‹¨ êµ¬ê°„ì˜ ë¹ˆ ìº”ë“¤ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë°©ì•ˆ ì„¤ê³„
> **ì‘ì„±ì¼**: 2025ë…„ 1ì›” 18ì¼
> **ë²„ì „**: v1.1
> **ê¸°ë°˜**: CandleDataProvider v6.0 + SqliteCandleRepository ìµœì í™” êµ¬ì¡° + Timestamp í˜¸í™˜ì„±
> **ì£¼ìš” ê°œì„ **: EmptyCandleDetector í´ë˜ìŠ¤ ë¶„ë¦¬ + íƒ€ì„í”„ë ˆì„ë³„ ì •í™•í•œ timestamp ìƒì„±

---

## ğŸ¯ 1. ë¬¸ì œ ì •ì˜ ë° ë°°ê²½

### 1.1 í˜„ì¬ ìƒí™© ë¶„ì„

**í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë°œê²¬ì‚¬í•­**:
```
ì´ ìº”ë“¤: 200,000ê°œ
ì‹œê°„ ë²”ìœ„: 200,383ë¶„
ì˜ˆìƒ ìº”ë“¤: 200,384ê°œ
ì™„ì „ì„±: 99.8% (384ê°œ ëˆ„ë½)

Gap í˜„í™©:
- ì´ Gap ê°œìˆ˜: 303ê°œ
- ëˆ„ë½ëœ ì‹œê°„: ì•½ 380ë¶„ (6.3ì‹œê°„)
- ìµœëŒ€ Gap: 358ë¶„ (ì•½ 6ì‹œê°„)
```

### 1.2 ìƒˆë¡œ ë°œê²¬ëœ ê¸°ìˆ ì  ìš”êµ¬ì‚¬í•­

#### **A. Timestamp ì˜ì¡´ì„± ë°œê²¬**
```python
# SqliteCandleRepositoryì—ì„œ gap ê°ì§€ì‹œ timestamp ì»¬ëŸ¼ ì‚¬ìš©
async def find_last_continuous_time(self, ...):
    cursor = conn.execute(f"""
    WITH gap_check AS (
        SELECT
            candle_date_time_utc,
            timestamp,  # â† ì´ ì»¬ëŸ¼ì„ ì‚¬ìš©í•´ì„œ gap ê°ì§€!
            LEAD(timestamp) OVER (ORDER BY timestamp DESC) as next_timestamp
        FROM {table_name}
        WHERE candle_date_time_utc BETWEEN ? AND ?
    )
    SELECT candle_date_time_utc
    WHERE (timestamp - next_timestamp > ?)  # â† timestamp ì°¨ì´ë¡œ gap íŒë‹¨
    """)
```

#### **B. ë¹ˆ ìº”ë“¤ë„ ì˜¬ë°”ë¥¸ timestamp í•„ìš”**
- **í˜„ì¬ ë¬¸ì œ**: ë¹ˆ ìº”ë“¤ì— timestampê°€ ì—†ìœ¼ë©´ gap ê°ì§€ ë¡œì§ì´ ì˜¤ë™ì‘
- **í•´ê²° í•„ìš”**: íƒ€ì„í”„ë ˆì„ì— ë§ëŠ” ì •í™•í•œ Unix timestamp (ë°€ë¦¬ì´ˆ) ìƒì„± í•„ìˆ˜
- **ì •í™•ì„± ìš”êµ¬**: ì‹¤ì œ ìº”ë“¤ì˜ timestampì™€ ì—°ì†ì„±ì„ ìœ ì§€í•´ì•¼ í•¨

#### **C. ì½”ë“œ êµ¬ì¡° ìµœì í™” í•„ìš”**
- **í˜„ì¬ ë¬¸ì œ**: CandleDataProviderê°€ ì´ë¯¸ ê¸¸ì–´ì§€ê³  ìˆìŒ (600+ ë¼ì¸)
- **í•´ê²° ë°©ì•ˆ**: OverlapAnalyzerì²˜ëŸ¼ ë³„ë„ í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬í•˜ì—¬ ìµœì†Œí•œì˜ ë³€ê²½ìœ¼ë¡œ ê¸°ëŠ¥ ì¶”ê°€

---

## ğŸ—ï¸ 2. í˜„ì¬ ì•„í‚¤í…ì²˜ ë¶„ì„ (v1.1 ì—…ë°ì´íŠ¸)

### 2.1 Timestamp ê¸°ë°˜ Gap ê°ì§€ ë©”ì»¤ë‹ˆì¦˜

```python
# SqliteCandleRepositoryì˜ gap ê°ì§€ í•µì‹¬ ë¡œì§
gap_threshold_ms_map = {
    '1s': 1500,      # 1.5ì´ˆ
    '1m': 90000,     # 90ì´ˆ
    '3m': 270000,    # 270ì´ˆ
    '5m': 450000,    # 450ì´ˆ
    # ...
}

# timestamp ì°¨ì´ê°€ ì„ê³„ê°’ë³´ë‹¤ í¬ë©´ gapìœ¼ë¡œ íŒë‹¨
WHERE (timestamp - next_timestamp > gap_threshold_ms)
```

**í•µì‹¬ ì¸ì‚¬ì´íŠ¸**:
- Gap ê°ì§€ëŠ” `timestamp` ì»¬ëŸ¼ì˜ **ë°€ë¦¬ì´ˆ ì°¨ì´**ë¡œ ë™ì‘
- ë¹ˆ ìº”ë“¤ë„ **ì •í™•í•œ timestamp**ë¥¼ ê°€ì ¸ì•¼ gap ê°ì§€ê°€ ì •ìƒ ì‘ë™
- TimeUtilsë¥¼ í™œìš©í•˜ì—¬ íƒ€ì„í”„ë ˆì„ë³„ **ì •í™•í•œ ì‹œê°„ â†’ timestamp ë³€í™˜** í•„ìš”

### 2.2 CandleData ëª¨ë¸ timestamp í•„ë“œ í™•ì¸

```python
@dataclass
class CandleData:
    # ì—…ë¹„íŠ¸ API ê³µí†µ í•„ë“œ
    market: str
    candle_date_time_utc: str
    candle_date_time_kst: str
    opening_price: float
    # ...
    timestamp: int                # â† Unix timestamp (ms) - ì´ë¯¸ ì¡´ì¬!
    # ...

    def to_db_dict(self) -> dict:
        return {
            # ...
            "timestamp": self.timestamp,  # â† DB ì €ì¥ì‹œ í¬í•¨ë¨
            # ...
        }
```

**í˜„ì¬ ìƒíƒœ**: CandleData ëª¨ë¸ì€ ì´ë¯¸ timestamp í•„ë“œë¥¼ ì§€ì›í•˜ë¯€ë¡œ **ì¶”ê°€ í•„ë“œ ì •ì˜ ë¶ˆí•„ìš”**

### 2.3 ê¸°ì¡´ êµ¬ì¡°ì˜ ì¥ì ê³¼ í•œê³„ (ì—…ë°ì´íŠ¸)

#### **ì¥ì **
- **ê³ ì„±ëŠ¥**: ì‹¤ì œ ìº”ë“¤ ìˆ˜ì§‘ê³¼ ì €ì¥ì´ ë§¤ìš° íš¨ìœ¨ì 
- **ì•ˆì •ì„±**: ê²¹ì¹¨ ë¶„ì„ìœ¼ë¡œ API í˜¸ì¶œ ìµœì†Œí™”
- **í™•ì¥ì„±**: Repository íŒ¨í„´ìœ¼ë¡œ ë‹¤ë¥¸ êµ¬í˜„ì²´ êµì²´ ê°€ëŠ¥
- **Gap ê°ì§€**: SqliteCandleRepositoryì— ì´ë¯¸ ê°•ë ¥í•œ gap ê°ì§€ ë¡œì§ ì¡´ì¬

#### **í•œê³„**
- **Gap ìë™ ì²˜ë¦¬ ì—†ìŒ**: ê°ì§€ëŠ” ë˜ì§€ë§Œ ë¹ˆ ìº”ë“¤ì„ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì§€ ì•ŠìŒ
- **ì½”ë“œ ê¸¸ì´**: CandleDataProviderê°€ ê¸¸ì–´ì ¸ì„œ ì¶”ê°€ ê¸°ëŠ¥ ë„£ê¸° ì–´ë ¤ì›€
- **ì—°ì†ì„± ë³´ì¥ ì—†ìŒ**: ì €ì¥ëœ ë°ì´í„°ë§Œìœ¼ë¡œëŠ” ì™„ì „í•œ ì‹œê³„ì—´ êµ¬ì„± ë¶ˆê°€

---

## ğŸ’¡ 3. ê°œì„ ëœ ë¹ˆ ìº”ë“¤ ê´€ë¦¬ ë°©ì•ˆ ì„¤ê³„ (v1.1)

### 3.1 í•µì‹¬ ì„¤ê³„ ì›ì¹™ (ì—…ë°ì´íŠ¸)

1. **ê¸°ì¡´ êµ¬ì¡° ë³´ì¡´**: CandleDataProvider v6.0ì˜ ì„±ëŠ¥ ìµœì í™” ìœ ì§€
2. **í´ë˜ìŠ¤ ë¶„ë¦¬**: EmptyCandleDetectorë¥¼ ë³„ë„ í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬í•˜ì—¬ ì½”ë“œ êµ¬ì¡° ê°œì„ 
3. **ì„ íƒì  ì²˜ë¦¬**: í•„ìš”í•œ ê²½ìš°ì—ë§Œ ë¹ˆ ìº”ë“¤ ìƒì„± (ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”)
4. **Timestamp í˜¸í™˜ì„±**: SqliteCandleRepository gap ê°ì§€ì™€ ì™„ë²½ í˜¸í™˜
5. **ìµœì†Œí•œì˜ ë³€ê²½**: CandleDataProviderì— ìµœì†Œí•œì˜ ì½”ë“œë§Œ ì¶”ê°€

### 3.2 ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜: EmptyCandleDetector í´ë˜ìŠ¤ ë¶„ë¦¬

| ì»´í¬ë„ŒíŠ¸ | ì—­í•  | ë³€ê²½ ì •ë„ |
|----------|------|-----------|
| **EmptyCandleDetector** | Gap ê°ì§€ + ë¹ˆ ìº”ë“¤ ìƒì„± (NEW) | ì‹ ê·œ í´ë˜ìŠ¤ |
| **CandleDataProvider** | ê¸°ì¡´ ë¡œì§ + EmptyCandleDetector ì—°ë™ | ìµœì†Œ ë³€ê²½ |
| **SqliteCandleRepository** | ê¸°ì¡´ gap ê°ì§€ ë¡œì§ í™œìš© | ë³€ê²½ ì—†ìŒ |
| **TimeUtils** | ì‹œê°„ ê³„ì‚° + timestamp ë³€í™˜ | ìœ í‹¸ë¦¬í‹° ì¶”ê°€ |

---

## ğŸ”§ 4. EmptyCandleDetector í´ë˜ìŠ¤ ì„¤ê³„ (NEW)

### 4.1 í´ë˜ìŠ¤ êµ¬ì¡° ë° ì±…ì„

```python
# íŒŒì¼ ìœ„ì¹˜: upbit_auto_trading/infrastructure/market_data/candle/empty_candle_detector.py

class EmptyCandleDetector:
    """
    ë¹ˆ ìº”ë“¤ ê°ì§€ ë° ìƒì„± ì „ë‹´ í´ë˜ìŠ¤

    Overlap Analyzerì™€ ë™ì¼í•œ íŒ¨í„´ìœ¼ë¡œ ì„¤ê³„:
    - ë‹¨ì¼ ì±…ì„: Gap ê°ì§€ + ë¹ˆ ìº”ë“¤ ìƒì„±
    - CandleDataProviderì—ì„œ ì„ íƒì ìœ¼ë¡œ ì‚¬ìš©
    - ê¸°ì¡´ ë¡œì§ê³¼ ë…ë¦½ì ìœ¼ë¡œ ë™ì‘
    """

    def __init__(self, timeframe: str):
        self.timeframe = timeframe
        self.gap_threshold_ms = self._get_gap_threshold(timeframe)

    async def detect_and_fill_gaps(self, api_candles: List[Dict]) -> List[CandleData]:
        """API ì‘ë‹µì—ì„œ Gapì„ ê°ì§€í•˜ê³  ë¹ˆ ìº”ë“¤ë¡œ ì±„ìš´ ì™„ì „í•œ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜"""

    def _detect_gaps_in_response(self, api_candles: List[Dict]) -> List[GapInfo]:
        """API ì‘ë‹µ ìº”ë“¤ë“¤ ì‚¬ì´ì˜ Gap ê°ì§€"""

    def _generate_empty_candles_for_gaps(self, gaps: List[GapInfo]) -> List[CandleData]:
        """Gap êµ¬ê°„ì— ë¹ˆ ìº”ë“¤ë“¤ ìƒì„± (ì •í™•í•œ timestamp í¬í•¨)"""

    def _merge_real_and_empty_candles(self, real_candles: List[CandleData],
                                      empty_candles: List[CandleData]) -> List[CandleData]:
        """ì‹¤ì œ ìº”ë“¤ê³¼ ë¹ˆ ìº”ë“¤ ë³‘í•© í›„ ì •ë ¬"""
```

### 4.2 í•µì‹¬ ë©”ì„œë“œ: Gap ê°ì§€ ë¡œì§

```python
def _detect_gaps_in_response(self, api_candles: List[Dict]) -> List[GapInfo]:
    """
    API ì‘ë‹µ ìº”ë“¤ë“¤ ì‚¬ì´ì˜ Gap ê°ì§€

    ì—…ë¹„íŠ¸ API íŠ¹ì„± ë°˜ì˜:
    - ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ (ìµœì‹  â†’ ê³¼ê±°)
    - ì—°ì†ëœ ìº”ë“¤ê°„ ì‹œê°„ ì°¨ì´ ë¶„ì„
    - íƒ€ì„í”„ë ˆì„ë³„ ì„ê³„ê°’ìœ¼ë¡œ Gap íŒë‹¨
    """
    if len(api_candles) < 2:
        return []

    # ì—…ë¹„íŠ¸ ë‚´ë¦¼ì°¨ìˆœ í™•ì¸ (ìµœì‹  â†’ ê³¼ê±°)
    sorted_candles = sorted(api_candles,
                           key=lambda x: x["candle_date_time_utc"],
                           reverse=True)

    gaps = []
    for i in range(len(sorted_candles) - 1):
        current_candle = sorted_candles[i]
        next_candle = sorted_candles[i + 1]

        current_time = self._parse_utc_time(current_candle["candle_date_time_utc"])
        next_time = self._parse_utc_time(next_candle["candle_date_time_utc"])

        # ì˜ˆìƒ ë‹¤ìŒ ìº”ë“¤ ì‹œê°„ ê³„ì‚°
        expected_next = TimeUtils.get_time_by_ticks(current_time, self.timeframe, -1)

        # Gap ê°ì§€: ì‹¤ì œ ë‹¤ìŒ ìº”ë“¤ì´ ì˜ˆìƒë³´ë‹¤ ê³¼ê±°ì— ìˆìŒ
        if next_time < expected_next:
            gap_info = GapInfo(
                gap_start=next_time,        # Gap ì‹œì‘ (ê³¼ê±°)
                gap_end=expected_next,      # Gap ì¢…ë£Œ (ë¯¸ë˜)
                reference_candle=current_candle,  # ì°¸ì¡°í•  ì‹¤ì œ ìº”ë“¤
                timeframe=self.timeframe
            )
            gaps.append(gap_info)

    return gaps
```

### 4.3 í•µì‹¬ ë©”ì„œë“œ: ë¹ˆ ìº”ë“¤ ìƒì„± (Timestamp í¬í•¨)

```python
def _generate_empty_candles_for_gaps(self, gaps: List[GapInfo]) -> List[CandleData]:
    """
    Gap êµ¬ê°„ì— ë¹ˆ ìº”ë“¤ë“¤ ìƒì„± (ìµœì í™”ëœ timestamp ê³„ì‚°)

    í•µì‹¬ ê°œì„ ì‚¬í•­:
    - TimeUtilsë¡œ ì •í™•í•œ ì‹œê°„ ê³„ì‚°
    - ğŸš€ ì„±ëŠ¥ ìµœì í™”: ì²« ë²ˆì§¸ë§Œ datetimeâ†’timestamp ë³€í™˜, ë‚˜ë¨¸ì§€ëŠ” ë‹¨ìˆœ ë§ì…ˆ
    - SqliteCandleRepository gap ê°ì§€ì™€ í˜¸í™˜

    ì„±ëŠ¥ í–¥ìƒ: 380ê°œ ë¹ˆ ìº”ë“¤ ê¸°ì¤€ 76ë°° ë¹ ë¥¸ timestamp ìƒì„±
    """
    all_empty_candles = []

    # íƒ€ì„í”„ë ˆì„ ë°€ë¦¬ì´ˆ ìºì‹œ (í•œ ë²ˆë§Œ ê³„ì‚°)
    timeframe_ms = TimeUtils.get_timeframe_seconds(self.timeframe) * 1000

    for gap_info in gaps:
        # Gap êµ¬ê°„ì˜ ëª¨ë“  ì‹œê°„ì  ìƒì„± (ë°°ì¹˜ ë°©ì‹)
        time_points = self._generate_gap_time_points(gap_info)

        if not time_points:
            continue

        # ğŸš€ ìµœì í™”: ì²« ë²ˆì§¸ë§Œ datetime â†’ timestamp ë³€í™˜
        first_timestamp_ms = self._datetime_to_timestamp_ms(time_points[0])

        for i, current_time in enumerate(time_points):
            # ğŸš€ ìµœì í™”: ë‚˜ë¨¸ì§€ëŠ” ë‹¨ìˆœ ë§ì…ˆìœ¼ë¡œ timestamp ê³„ì‚° (76ë°° ë¹ ë¦„!)
            timestamp_ms = first_timestamp_ms + (i * timeframe_ms)

            empty_candle = CandleData.create_empty_candle(
                target_time=current_time,
                reference_utc=gap_info.reference_candle["candle_date_time_utc"],
                timeframe=self.timeframe,
                timestamp_ms=timestamp_ms
            )
            all_empty_candles.append(empty_candle)

    return all_empty_candles

def _generate_gap_time_points(self, gap_info: GapInfo) -> List[datetime]:
    """Gap êµ¬ê°„ì˜ ëª¨ë“  ì‹œê°„ì  ë°°ì¹˜ ìƒì„±"""
    time_points = []
    current_time = TimeUtils.get_time_by_ticks(gap_info.gap_start, self.timeframe, 1)

    while current_time < gap_info.gap_end:
        time_points.append(current_time)
        current_time = TimeUtils.get_time_by_ticks(current_time, self.timeframe, 1)

    return time_points

def _datetime_to_timestamp_ms(self, dt: datetime) -> int:
    """
    DateTimeì„ Unix timestamp (ë°€ë¦¬ì´ˆ)ë¡œ ë³€í™˜

    ì—…ë¹„íŠ¸ API timestamp í˜•ì‹ê³¼ ì •í™•íˆ ì¼ì¹˜:
    - Unix epoch (1970-01-01 00:00:00 UTC) ê¸°ì¤€
    - ë°€ë¦¬ì´ˆ ë‹¨ìœ„ (ì—…ë¹„íŠ¸ API í‘œì¤€)
    - Timezone ì•ˆì „ ì²˜ë¦¬
    """
    # Timezoneì´ ì—†ìœ¼ë©´ UTCë¡œ ê°€ì •
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)

    # Unix timestamp (ì´ˆ) * 1000 â†’ ë°€ë¦¬ì´ˆ
    timestamp_seconds = dt.timestamp()
    timestamp_ms = int(timestamp_seconds * 1000)

    return timestamp_ms
```

### 4.4 ë°ì´í„° ëª¨ë¸ í™•ì¥: GapInfo í´ë˜ìŠ¤

```python
@dataclass
class GapInfo:
    """Gap ì •ë³´ ì €ì¥ìš© ëª¨ë¸ (EmptyCandleDetector ì „ìš©)"""
    gap_start: datetime          # Gap ì‹œì‘ ì‹œê°„ (ê³¼ê±°)
    gap_end: datetime           # Gap ì¢…ë£Œ ì‹œê°„ (ë¯¸ë˜)
    reference_candle: Dict      # ì°¸ì¡°í•  ì‹¤ì œ ìº”ë“¤ (API ì‘ë‹µ)
    timeframe: str              # íƒ€ì„í”„ë ˆì„

    def get_expected_empty_count(self) -> int:
        """ì´ Gapì—ì„œ ìƒì„±ë  ë¹ˆ ìº”ë“¤ ê°œìˆ˜"""
        return TimeUtils.calculate_expected_count(self.gap_end, self.gap_start, self.timeframe)
```

### 4.5 CandleData ëª¨ë¸ í™•ì¥: ë¹ˆ ìº”ë“¤ ìƒì„± ë©”ì„œë“œ

```python
@dataclass
class CandleData:
    # ê¸°ì¡´ ëª¨ë“  í•„ë“œë“¤...
    blank_copy_from_utc: Optional[str] = None  # ë¹ˆ ìº”ë“¤ ì‹ë³„ì (ê¸°ì¡´ê³¼ ë™ì¼)

    @classmethod
    def create_empty_candle(cls,
                           target_time: datetime,
                           reference_utc: str,
                           timeframe: str,
                           timestamp_ms: int) -> 'CandleData':  # â† ìƒˆ ë§¤ê°œë³€ìˆ˜ ì¶”ê°€
        """
        ë¹ˆ ìº”ë“¤ ìƒì„± íŒ©í† ë¦¬ ë©”ì„œë“œ (timestamp í¬í•¨)

        Args:
            target_time: ë¹ˆ ìº”ë“¤ ì‹œê°„
            reference_utc: ì°¸ì¡° ìº”ë“¤ UTC ì‹œê°„ ë¬¸ìì—´
            timeframe: íƒ€ì„í”„ë ˆì„
            timestamp_ms: ì •í™•í•œ Unix timestamp (ë°€ë¦¬ì´ˆ) â† NEW!
        """
        return cls(
            # ì‹œê°„ ì •ë³´
            candle_date_time_utc=target_time.strftime('%Y-%m-%dT%H:%M:%S'),
            candle_date_time_kst=cls._utc_to_kst_string(target_time),
            timestamp=timestamp_ms,  # â† ì •í™•í•œ timestamp ì„¤ì •

            # ê±°ë˜ ë°ì´í„° (NULLë¡œ ì„¤ì •)
            market=None,
            opening_price=None,
            high_price=None,
            low_price=None,
            trade_price=None,
            candle_acc_trade_price=None,
            candle_acc_trade_volume=None,

            # ë¹ˆ ìº”ë“¤ ì‹ë³„
            blank_copy_from_utc=reference_utc,

            # ë©”íƒ€ë°ì´í„°
            symbol=None,
            timeframe=timeframe
        )

    @staticmethod
    def _utc_to_kst_string(utc_time: datetime) -> str:
        """UTC ì‹œê°„ì„ KST ë¬¸ìì—´ë¡œ ë³€í™˜"""
        kst_time = utc_time + timedelta(hours=9)  # UTC + 9 = KST
        return kst_time.strftime('%Y-%m-%dT%H:%M:%S')

    def to_db_dict(self) -> dict:
        """DB ì €ì¥ìš© ë”•ì…”ë„ˆë¦¬ ë³€í™˜ (ë¹ˆ ìº”ë“¤ ìµœì í™”)"""
        if self.blank_copy_from_utc is not None:
            # ë¹ˆ ìº”ë“¤: í•„ìˆ˜ í•„ë“œ + timestampë§Œ ì €ì¥
            return {
                "candle_date_time_utc": self.candle_date_time_utc,
                "candle_date_time_kst": self.candle_date_time_kst,
                "timestamp": self.timestamp,  # â† Gap ê°ì§€ë¥¼ ìœ„í•´ í•„ìˆ˜!
                "blank_copy_from_utc": self.blank_copy_from_utc,
                # ê±°ë˜ ë°ì´í„°ëŠ” NULL
                "market": None,
                "opening_price": None,
                "high_price": None,
                "low_price": None,
                "trade_price": None,
                "candle_acc_trade_price": None,
                "candle_acc_trade_volume": None,
            }
        else:
            # ì‹¤ì œ ìº”ë“¤: ê¸°ì¡´ ë¡œì§ ì™„ì „íˆ ê·¸ëŒ€ë¡œ (ë³€ê²½ ì—†ìŒ)
            return {
                "candle_date_time_utc": self.candle_date_time_utc,
                "candle_date_time_kst": self.candle_date_time_kst,
                "market": self.market,
                "opening_price": self.opening_price,
                "high_price": self.high_price,
                "low_price": self.low_price,
                "trade_price": self.trade_price,
                "timestamp": self.timestamp,
                "candle_acc_trade_price": self.candle_acc_trade_price,
                "candle_acc_trade_volume": self.candle_acc_trade_volume,
                "blank_copy_from_utc": None
            }
```

### 4.6 ğŸš€ ì„±ëŠ¥ ìµœì í™” ì™„ì „ ìœ ì§€ ë°©ì•ˆ (Dict í˜•íƒœ ì²˜ë¦¬)

**í•µì‹¬**: CandleDataProvider v6.0ì˜ **90% ë©”ëª¨ë¦¬ ì ˆì•½**ê³¼ **70% CPU ê°œì„ ** íš¨ê³¼ë¥¼ ì™„ì „íˆ ìœ ì§€í•˜ë©´ì„œ ë¹ˆ ìº”ë“¤ ì²˜ë¦¬

#### **ë¬¸ì œ ìƒí™©**: ê¸°ì¡´ êµ¬ìƒì•ˆì˜ ì„±ëŠ¥ ì†ì‹¤
```python
# âŒ ì„±ëŠ¥ ì†ì‹¤ ë°©ë²•: CandleData ê°ì²´ë¡œ ë³€í™˜
api_candles = await self._fetch_chunk_from_api(chunk_info)  # List[Dict]
final_candles = await detector.detect_and_fill_gaps(api_candles)  # List[CandleData] ğŸ˜±
await self.repository.save_candle_chunk(symbol, timeframe, final_candles)  # ì„±ëŠ¥ ì†ì‹¤!
```

#### **í•´ê²° ë°©ì•ˆ**: Dict í˜•íƒœ ìœ ì§€ë¡œ ì„±ëŠ¥ ë³´ì¡´
```python
# âœ… ì„±ëŠ¥ ë³´ì¡´ ë°©ë²•: Dict í˜•íƒœ ìœ ì§€
api_candles = await self._fetch_chunk_from_api(chunk_info)  # List[Dict]
final_candles = detector.detect_and_fill_gaps(api_candles)  # List[Dict] â†’ List[Dict] ğŸ‰
await self.repository.save_raw_api_data(symbol, timeframe, final_candles)  # ì„±ëŠ¥ ì™„ì „ ìœ ì§€!
```

#### **EmptyCandleDetector ì„±ëŠ¥ ìµœì í™” êµ¬í˜„**
```python
class EmptyCandleDetector:
    def detect_and_fill_gaps(self, api_candles: List[Dict]) -> List[Dict]:
        """API ì‘ë‹µì—ì„œ Gap ê°ì§€í•˜ê³  ë¹ˆ ìº”ë“¤(Dict)ë¡œ ì±„ì›Œì„œ ì™„ì „í•œ List[Dict] ë°˜í™˜"""

        gaps = self._detect_gaps_in_response(api_candles)
        if not gaps:
            return api_candles  # Gap ì—†ìœ¼ë©´ ì›ë³¸ ê·¸ëŒ€ë¡œ

        # ğŸ†• ë¹ˆ ìº”ë“¤ì„ ì—…ë¹„íŠ¸ API í˜•ì‹ì˜ Dictë¡œ ìƒì„±
        empty_candle_dicts = self._generate_empty_candle_dicts(gaps)

        # Dictë¼ë¦¬ ë³‘í•© í›„ ì‹œê°„ìˆœ ì •ë ¬
        merged_candles = api_candles + empty_candle_dicts
        return sorted(merged_candles, key=lambda x: x["candle_date_time_utc"], reverse=True)

    def _generate_empty_candle_dicts(self, gaps: List[GapInfo]) -> List[Dict]:
        """ğŸš€ ì„±ëŠ¥ ìµœì í™”: ë¹ˆ ìº”ë“¤ì„ ì—…ë¹„íŠ¸ API Dict í˜•íƒœë¡œ ìƒì„±"""
        empty_dicts = []
        timeframe_ms = TimeUtils.get_timeframe_seconds(self.timeframe) * 1000

        for gap_info in gaps:
            time_points = self._generate_gap_time_points(gap_info)
            if not time_points:
                continue

            # ğŸš€ ìµœì í™”: ì²« ë²ˆì§¸ë§Œ datetime â†’ timestamp ë³€í™˜ (76ë°° ë¹ ë¦„!)
            first_timestamp_ms = self._datetime_to_timestamp_ms(time_points[0])

            for i, time_point in enumerate(time_points):
                timestamp_ms = first_timestamp_ms + (i * timeframe_ms)

                # ì—…ë¹„íŠ¸ API í˜•ì‹ê³¼ ë™ì¼í•œ Dict ìƒì„±
                empty_dict = {
                    "candle_date_time_utc": time_point.strftime('%Y-%m-%dT%H:%M:%S'),
                    "candle_date_time_kst": self._utc_to_kst_string(time_point),
                    "timestamp": timestamp_ms,
                    "blank_copy_from_utc": gap_info.reference_candle["candle_date_time_utc"],

                    # ê±°ë˜ ë°ì´í„°ëŠ” None (DBì—ì„œ NULLë¡œ ì €ì¥ë¨)
                    "market": None,
                    "opening_price": None,
                    "high_price": None,
                    "low_price": None,
                    "trade_price": None,
                    "candle_acc_trade_price": None,
                    "candle_acc_trade_volume": None,
                }
                empty_dicts.append(empty_dict)

        return empty_dicts
```

#### **ì„±ëŠ¥ ë¹„êµ**
| ë°©ì‹ | ë©”ëª¨ë¦¬ ì‚¬ìš© | CPU ì²˜ë¦¬ | save ë©”ì„œë“œ | íƒ€ì… | ì„±ëŠ¥ |
|------|------------|----------|-------------|------|------|
| **ê¸°ì¡´ êµ¬ìƒ** | CandleData ê°ì²´ | ë³€í™˜ ì˜¤ë²„í—¤ë“œ | save_candle_chunk | List[CandleData] | âŒ ì†ì‹¤ |
| **ìµœì í™” ë°©ì•ˆ** | Dict ìœ ì§€ | ë³€í™˜ ìƒëµ | save_raw_api_data | List[Dict] | âœ… ìœ ì§€ |

### 4.7 ğŸ” ì—¬ëŸ¬ Gap ê·¸ë£¹ ì²˜ë¦¬ ê²€ì¦

**í•µì‹¬**: í•˜ë‚˜ì˜ ì²­í¬ ë‚´ì— ì—¬ëŸ¬ Gapì´ ìˆì–´ë„ ì™„ë²½í•˜ê²Œ ì²˜ë¦¬ ê°€ëŠ¥

#### **ë³µì¡í•œ Gap ì‹œë‚˜ë¦¬ì˜¤ ì˜ˆì‹œ**
```python
# ì²­í¬ ë‚´ ìº”ë“¤ ìˆœì„œ (ì—…ë¹„íŠ¸ ë‚´ë¦¼ì°¨ìˆœ: ìµœì‹  â†’ ê³¼ê±°)
api_candles = [
    {"candle_date_time_utc": "2025-01-18T14:05:00", ...},  # ì‹¤ì œ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T14:04:00", ...},  # ì‹¤ì œ ìº”ë“¤
    # Gap 1: 14:03, 14:02 ë¹ˆ ìº”ë“¤ í•„ìš”
    {"candle_date_time_utc": "2025-01-18T14:01:00", ...},  # ì‹¤ì œ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T13:59:00", ...},  # ì‹¤ì œ ìº”ë“¤
    # Gap 2: 13:58, 13:57, 13:56 ë¹ˆ ìº”ë“¤ í•„ìš”
    {"candle_date_time_utc": "2025-01-18T13:55:00", ...},  # ì‹¤ì œ ìº”ë“¤
]
```

#### **ì²˜ë¦¬ íë¦„ ê²€ì¦**
```python
# 1. Gap ê°ì§€ (ëª¨ë“  ì—°ì† ìº”ë“¤ ìŒ ê²€ì‚¬)
def _detect_gaps_in_response(self, api_candles):
    gaps = []
    for i in range(len(sorted_candles) - 1):
        current = sorted_candles[i]      # 14:05, 14:04, 14:01, 13:59, 13:55
        next_candle = sorted_candles[i+1]  # 14:04, 14:01, 13:59, 13:55, (ë)

        if next_time < expected_next:
            gaps.append(GapInfo(...))  # Gap1(14:03-14:02), Gap2(13:58-13:56) ê°ì§€
    return gaps  # [Gap1, Gap2] ë°˜í™˜

# 2. ëª¨ë“  Gapì—ì„œ ë¹ˆ ìº”ë“¤ ìƒì„±
def _generate_empty_candle_dicts(self, gaps):
    empty_dicts = []
    for gap_info in gaps:  # Gap1, Gap2 ê°ê° ì²˜ë¦¬
        for time_point in gap_time_points:
            empty_dicts.append(create_empty_dict(time_point))
    return empty_dicts  # [14:03, 14:02, 13:58, 13:57, 13:56] ëª¨ë“  ë¹ˆ ìº”ë“¤

# 3. ìµœì¢… ë³‘í•© ë° ì •ë ¬
merged_candles = api_candles + empty_candle_dicts  # ì‹¤ì œ 5ê°œ + ë¹ˆ 5ê°œ = 10ê°œ
sorted_result = sorted(merged_candles, ...)  # ì‹œê°„ìˆœ ì™„ì „í•œ ì—°ì† ì‹œê³„ì—´
```

#### **ê²°ê³¼ ê²€ì¦**
```python
# ìµœì¢… ê²°ê³¼ (ì‹œê°„ ì—°ì†ì„± ì™„ë²½ ë³´ì¥)
final_result = [
    {"candle_date_time_utc": "2025-01-18T14:05:00", "blank_copy_from_utc": None},     # ì‹¤ì œ
    {"candle_date_time_utc": "2025-01-18T14:04:00", "blank_copy_from_utc": None},     # ì‹¤ì œ
    {"candle_date_time_utc": "2025-01-18T14:03:00", "blank_copy_from_utc": "..."},   # ë¹ˆ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T14:02:00", "blank_copy_from_utc": "..."},   # ë¹ˆ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T14:01:00", "blank_copy_from_utc": None},     # ì‹¤ì œ
    {"candle_date_time_utc": "2025-01-18T13:59:00", "blank_copy_from_utc": None},     # ì‹¤ì œ
    {"candle_date_time_utc": "2025-01-18T13:58:00", "blank_copy_from_utc": "..."},   # ë¹ˆ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T13:57:00", "blank_copy_from_utc": "..."},   # ë¹ˆ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T13:56:00", "blank_copy_from_utc": "..."},   # ë¹ˆ ìº”ë“¤
    {"candle_date_time_utc": "2025-01-18T13:55:00", "blank_copy_from_utc": None},     # ì‹¤ì œ
]
```

#### **ì„±ëŠ¥ ì˜í–¥ ë¶„ì„**
- **Gap ê°œìˆ˜**: ë¡œì§ ë³µì¡ë„ì— ê±°ì˜ ì˜í–¥ ì—†ìŒ (O(n) ìœ ì§€)
- **ë©”ëª¨ë¦¬ ì‚¬ìš©**: Gap ë‹¹ ì¶”ê°€ë˜ëŠ” ë¹ˆ ìº”ë“¤ ìˆ˜ì— ë¹„ë¡€ (ì˜ˆì¸¡ ê°€ëŠ¥)
- **ì²˜ë¦¬ ì‹œê°„**: Gap ë‹¹ 76ë°° ë¹ ë¥¸ timestamp ìƒì„±ìœ¼ë¡œ ì„ í˜• ì¦ê°€
- **ì •ë ¬ ë¹„ìš©**: ì „ì²´ ìº”ë“¤ ìˆ˜ì— ë”°ë¥¸ O(n log n) (ì¶©ë¶„íˆ ë¹ ë¦„)

**âœ… ê²°ë¡ **: í˜„ì¬ ë¡œì§ì€ **ì—¬ëŸ¬ Gap ê·¸ë£¹ì„ ì™„ë²½í•˜ê²Œ ì²˜ë¦¬í•˜ë©´ì„œë„ ì„±ëŠ¥ì„ ì™„ì „íˆ ìœ ì§€**í•©ë‹ˆë‹¤!

---

## ğŸ”„ 5. CandleDataProvider ìµœì†Œ ë³€ê²½ í†µí•©

### 5.1 ìƒì„±ìì— EmptyCandleDetector ì¶”ê°€

```python
class CandleDataProvider:
    def __init__(
        self,
        repository: CandleRepositoryInterface,
        upbit_client: UpbitPublicClient,
        overlap_analyzer: OverlapAnalyzer,
        chunk_size: int = 200,
        enable_empty_candle_processing: bool = True  # â† ìƒˆ ì˜µì…˜ ì¶”ê°€
    ):
        # ê¸°ì¡´ ì´ˆê¸°í™”...
        self.enable_empty_candle_processing = enable_empty_candle_processing
        self.empty_candle_detectors: Dict[str, EmptyCandleDetector] = {}  # timeframeë³„ ìºì‹œ

        logger.info("CandleDataProvider v6.1 (ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ì§€ì›) ì´ˆê¸°í™”")
```

### 5.2 EmptyCandleDetector í†µí•© ë©”ì„œë“œ

```python
def _get_empty_candle_detector(self, timeframe: str) -> EmptyCandleDetector:
    """íƒ€ì„í”„ë ˆì„ë³„ EmptyCandleDetector ìºì‹œ (ì„±ëŠ¥ ìµœì í™”)"""
    if timeframe not in self.empty_candle_detectors:
        self.empty_candle_detectors[timeframe] = EmptyCandleDetector(timeframe)
    return self.empty_candle_detectors[timeframe]

async def _process_chunk_with_empty_candles(self,
                                            chunk_info: ChunkInfo,
                                            state: CollectionState,
                                            is_first_chunk: bool,
                                            request_type: RequestType) -> tuple[int, Optional[str]]:
    """
    ê¸°ì¡´ _process_chunk_direct_storage í™•ì¥ (ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ì¶”ê°€)

    ë³€ê²½ ì‚¬í•­:
    - API ì‘ë‹µ â†’ EmptyCandleDetector â†’ Repository ì €ì¥
    - ë‚˜ë¨¸ì§€ ë¡œì§ì€ ê¸°ì¡´ê³¼ ì™„ì „íˆ ë™ì¼
    """

    # === ê¸°ì¡´ ê²¹ì¹¨ ë¶„ì„ ë¡œì§ (ì™„ì „íˆ ë™ì¼) ===
    overlap_result = None
    chunk_end = None
    if not (is_first_chunk and request_type in [RequestType.COUNT_ONLY, RequestType.END_ONLY]):
        chunk_start = chunk_info.to
        chunk_end = self._calculate_chunk_end_time(chunk_info)
        overlap_result = await self._analyze_chunk_overlap(
            state.symbol, state.timeframe, chunk_start, chunk_end
        )

    # === API ë°ì´í„° ìˆ˜ì§‘ (ê¸°ì¡´ê³¼ ë™ì¼) ===
    if overlap_result and hasattr(overlap_result, 'status'):
        api_candles = await self._handle_overlap_api_fetch(chunk_info, overlap_result, chunk_end)
    else:
        api_candles = await self._fetch_chunk_from_api(chunk_info)

    # === ğŸ†• ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ (ìƒˆë¡œìš´ ì „ì²˜ë¦¬ ë‹¨ê³„) ===
    final_candles = api_candles  # ê¸°ë³¸ê°’: API ì‘ë‹µ ê·¸ëŒ€ë¡œ

    if self.enable_empty_candle_processing and len(api_candles) >= 2:
        detector = self._get_empty_candle_detector(state.timeframe)

        # ğŸš€ ì„±ëŠ¥ ìœ ì§€: EmptyCandleDetectorê°€ Dict í˜•íƒœë¡œ ì²˜ë¦¬ (ì—¬ëŸ¬ Gap ì§€ì›)
        final_candles = detector.detect_and_fill_gaps(api_candles)  # List[Dict] â†’ List[Dict]

        logger.debug(f"ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ì™„ë£Œ: {len(api_candles)}ê°œ â†’ {len(final_candles)}ê°œ")

    # === ğŸš€ ê¸°ì¡´ ì„±ëŠ¥ ìµœì í™” ì™„ì „ ìœ ì§€ (save_raw_api_data ì‚¬ìš©) ===
    saved_count = await self.repository.save_raw_api_data(
        state.symbol, state.timeframe, final_candles  # Dict í˜•íƒœ ìœ ì§€ë¡œ ì„±ëŠ¥ ë³´ì¡´!
    )

    # ì—°ì†ì„±ì„ ìœ„í•œ ë§ˆì§€ë§‰ ìº”ë“¤ ì‹œê°„ ì¶”ì¶œ (ê¸°ì¡´ê³¼ ë™ì¼)
    last_candle_time = None
    if final_candles:
        last_candle_time = final_candles[-1].candle_date_time_utc

    return saved_count, last_candle_time
```

### 5.3 ê¸°ì¡´ ë©”ì„œë“œ ìˆ˜ì • (ìµœì†Œí•œì˜ ë³€ê²½)

```python
async def mark_chunk_completed(self, request_id: str) -> bool:
    """ì²­í¬ ì™„ë£Œ ì²˜ë¦¬ - ë¹ˆ ìº”ë“¤ í†µí•© ë²„ì „ (ê¸°ì¡´ ë©”ì„œë“œ í™•ì¥)"""

    # ê¸°ì¡´ ìƒíƒœ ê´€ë¦¬ ë¡œì§ (ë³€ê²½ ì—†ìŒ)...

    try:
        # ğŸ†• ë¹ˆ ìº”ë“¤ í†µí•© ì²˜ë¦¬ (ê¸°ì¡´ í˜¸ì¶œì„ ìƒˆ ë©”ì„œë“œë¡œ êµì²´)
        saved_count, last_candle_time = await self._process_chunk_with_empty_candles(
            state.current_chunk, state, is_first_chunk, request_type
        )

        # ê¸°ì¡´ ì™„ë£Œ ì²˜ë¦¬ ë¡œì§ (ë³€ê²½ ì—†ìŒ)...

    except Exception as e:
        # ê¸°ì¡´ ì—ëŸ¬ ì²˜ë¦¬ (ë³€ê²½ ì—†ìŒ)...
```

---

## âš¡ 6. ì„±ëŠ¥ ìµœì í™” ë° ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±

### 6.1 ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± (ì—…ë°ì´íŠ¸)

```python
# ë¹ˆ ìº”ë“¤ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
empty_candle_fields = [
    "candle_date_time_utc",     # í•„ìˆ˜ (ì‹œê°„ ì‹ë³„)
    "candle_date_time_kst",     # í•„ìˆ˜ (ì—…ë¹„íŠ¸ í˜¸í™˜ì„±)
    "timestamp",                # í•„ìˆ˜ (Gap ê°ì§€ìš©) â† NEW!
    "blank_copy_from_utc"       # í•„ìˆ˜ (ë¹ˆ ìº”ë“¤ ì‹ë³„)
]
# ì´ 4ê°œ í•„ë“œ vs ì‹¤ì œ ìº”ë“¤ 10+ í•„ë“œ

ì‹¤ì œ ë©”ëª¨ë¦¬ ì ˆì•½ë¥  = (10 - 4) / 10 = 60%  # timestamp ì¶”ê°€ë¡œ ì•½ê°„ ê°ì†Œí–ˆì§€ë§Œ ì—¬ì „íˆ íš¨ìœ¨ì 

# 380ë¶„ Gap = 380ê°œ ë¹ˆ ìº”ë“¤ ì˜ˆì‹œ
ê¸°ì¡´ ë©”ëª¨ë¦¬ ì‚¬ìš©: 380 Ã— ì „ì²´ í•„ë“œ í¬ê¸°
ë¹ˆ ìº”ë“¤ ë©”ëª¨ë¦¬: 380 Ã— 4ê°œ í•„ë“œ = ê¸°ì¡´ì˜ 40%

# ğŸš€ Timestamp ìƒì„± ì„±ëŠ¥ ìµœì í™”
í˜„ì¬ ë°©ë²•: 380ë²ˆì˜ datetime.timestamp() í˜¸ì¶œ (~380Î¼s)
ìµœì í™” ë°©ë²•: 1ë²ˆ ë³€í™˜ + 379ë²ˆ ë‹¨ìˆœ ë§ì…ˆ (~5Î¼s)
ì„±ëŠ¥ í–¥ìƒ: ì•½ 76ë°° ë¹¨ë¼ì§!

# ğŸ¯ CandleDataProvider v6.0 ìµœì í™” ì™„ì „ ë³´ì¡´
Dict í˜•íƒœ ì²˜ë¦¬: save_raw_api_data ì‚¬ìš©ìœ¼ë¡œ 90% ë©”ëª¨ë¦¬, 70% CPU ê°œì„  ì™„ì „ ìœ ì§€
ì—¬ëŸ¬ Gap ì§€ì›: ì²­í¬ë‹¹ ë¬´ì œí•œ Gap ê·¸ë£¹ ë™ì‹œ ì²˜ë¦¬ (ì„±ëŠ¥ ì˜í–¥ ìµœì†Œ)
```

### 6.2 EmptyCandleDetector ì„±ëŠ¥ ìµœì í™”

```python
class EmptyCandleDetector:
    def __init__(self, timeframe: str):
        self.timeframe = timeframe
        self.gap_threshold_ms = self._get_gap_threshold(timeframe)

        # ğŸš€ ì„±ëŠ¥ ìµœì í™”: ìºì‹±ìœ¼ë¡œ ë°˜ë³µ ê³„ì‚° ë°©ì§€
        self._timeframe_delta = TimeUtils.get_timeframe_delta(timeframe)
        self._timeframe_seconds = TimeUtils.get_timeframe_seconds(timeframe)
        self._timeframe_ms = self._timeframe_seconds * 1000  # timestamp ìµœì í™”ìš©

    def _detect_gaps_optimized(self, api_candles: List[Dict]) -> List[GapInfo]:
        """O(n) ì‹œê°„ ë³µì¡ë„ë¡œ ìµœì í™”ëœ Gap ê°ì§€"""
        gaps = []
        prev_time = None

        # ë‹¨ì¼ ë£¨í”„ë¡œ Gap ê°ì§€ (ì„ í˜• ì‹œê°„)
        for candle in sorted_candles:
            current_time = self._parse_utc_time(candle["candle_date_time_utc"])

            if prev_time:
                # ìºì‹œëœ ê°’ìœ¼ë¡œ ë¹ ë¥¸ ê³„ì‚°
                expected_time = prev_time - self._timeframe_delta

                if current_time < expected_time:
                    gap_info = GapInfo(current_time, expected_time, candle, self.timeframe)
                    gaps.append(gap_info)

            prev_time = current_time

        return gaps

    def _generate_empty_candles_batch(self, gaps: List[GapInfo]) -> List[CandleData]:
        """ë°°ì¹˜ ë°©ì‹ ë¹ˆ ìº”ë“¤ ìƒì„± (timestamp ìµœì í™”)"""
        all_empty_candles = []

        # íƒ€ì„í”„ë ˆì„ ë°€ë¦¬ì´ˆ ìºì‹œ
        timeframe_ms = TimeUtils.get_timeframe_seconds(self.timeframe) * 1000

        for gap_info in gaps:
            # TimeUtils.get_time_range í™œìš©í•œ ë°°ì¹˜ ìƒì„±
            time_points = TimeUtils.get_time_range(
                gap_info.gap_start, gap_info.gap_end, self.timeframe
            )

            if not time_points:
                continue

            # ğŸš€ ìµœì í™”: ì²« ë²ˆì§¸ë§Œ datetime â†’ timestamp ë³€í™˜
            first_timestamp_ms = self._datetime_to_timestamp_ms(time_points[0])

            # ğŸš€ ìµœì í™”: ë‚˜ë¨¸ì§€ëŠ” ë‹¨ìˆœ ë§ì…ˆìœ¼ë¡œ timestamp ê³„ì‚°
            for i, time_point in enumerate(time_points):
                timestamp_ms = first_timestamp_ms + (i * timeframe_ms)

                empty_candle = CandleData.create_empty_candle(
                    time_point, gap_info.reference_candle["candle_date_time_utc"],
                    self.timeframe, timestamp_ms
                )
                all_empty_candles.append(empty_candle)

        return all_empty_candles
```

---

## ğŸ“Š 7. DB ìŠ¤í‚¤ë§ˆ ë° í˜¸í™˜ì„±

### 7.1 DB ìŠ¤í‚¤ë§ˆ í™•ì¥ (ê¸°ì¡´ê³¼ ë™ì¼)

```sql
-- ê¸°ì¡´ í…Œì´ë¸”ì— ë¹ˆ ìº”ë“¤ ì‹ë³„ ì»¬ëŸ¼ ì¶”ê°€
ALTER TABLE candles_KRW_BTC_1m
ADD COLUMN blank_copy_from_utc TEXT NULL;

-- ë¹ˆ ìº”ë“¤ ì¡°íšŒ ìµœì í™” ì¸ë±ìŠ¤
CREATE INDEX IF NOT EXISTS idx_empty_candles_KRW_BTC_1m
ON candles_KRW_BTC_1m(blank_copy_from_utc)
WHERE blank_copy_from_utc IS NOT NULL;
```

### 7.2 Timestamp í˜¸í™˜ì„± í™•ì¸

```sql
-- ë¹ˆ ìº”ë“¤ì˜ timestampê°€ ì˜¬ë°”ë¥´ê²Œ ìƒì„±ë˜ì—ˆëŠ”ì§€ í™•ì¸
SELECT
    candle_date_time_utc,
    timestamp,
    blank_copy_from_utc,
    -- timestampì™€ ì‹œê°„ ë¬¸ìì—´ ì¼ì¹˜ì„± ê²€ì¦
    (strftime('%s', candle_date_time_utc) * 1000) as calculated_timestamp_ms,
    (timestamp - (strftime('%s', candle_date_time_utc) * 1000)) as timestamp_diff
FROM candles_KRW_BTC_1m
WHERE blank_copy_from_utc IS NOT NULL
ORDER BY candle_date_time_utc DESC
LIMIT 10;

-- Gap ê°ì§€ ë¡œì§ì´ ë¹ˆ ìº”ë“¤ê³¼ í•¨ê»˜ ì˜¬ë°”ë¥´ê²Œ ë™ì‘í•˜ëŠ”ì§€ í™•ì¸
WITH gap_check AS (
    SELECT
        candle_date_time_utc,
        timestamp,
        blank_copy_from_utc,
        LEAD(timestamp) OVER (ORDER BY timestamp DESC) as next_timestamp
    FROM candles_KRW_BTC_1m
    WHERE candle_date_time_utc BETWEEN '2025-01-01T00:00:00' AND '2025-01-01T01:00:00'
)
SELECT
    candle_date_time_utc,
    blank_copy_from_utc,
    (timestamp - next_timestamp) as timestamp_gap_ms,
    CASE
        WHEN (timestamp - next_timestamp) > 90000 THEN 'GAP_DETECTED'
        ELSE 'CONTINUOUS'
    END as gap_status
FROM gap_check
WHERE next_timestamp IS NOT NULL
ORDER BY timestamp DESC;
```

---

## ğŸ”„ 8. êµ¬í˜„ ê³„íš ë° ë§ˆì´ê·¸ë ˆì´ì…˜ (v1.1)

### 8.1 Phase 1: EmptyCandleDetector í´ë˜ìŠ¤ êµ¬í˜„ (2ì¼)

```python
# ì‘ì—… ëª©ë¡
âœ… empty_candle_detector.py íŒŒì¼ ìƒì„±
âœ… EmptyCandleDetector í´ë˜ìŠ¤ êµ¬í˜„
âœ… GapInfo ë°ì´í„° ëª¨ë¸ ì¶”ê°€
âœ… Gap ê°ì§€ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ (O(n) ìµœì í™”)
âœ… ë¹ˆ ìº”ë“¤ ìƒì„± ë¡œì§ êµ¬í˜„ (timestamp í¬í•¨)
âœ… ì‹¤ì œ+ë¹ˆ ìº”ë“¤ ë³‘í•© ë¡œì§
âœ… íƒ€ì„í”„ë ˆì„ë³„ ì„ê³„ê°’ ì„¤ì •
âœ… ê¸°ë³¸ ìœ ë‹› í…ŒìŠ¤íŠ¸ ì‘ì„±
```

### 8.2 Phase 2: CandleData ëª¨ë¸ í™•ì¥ (1ì¼)

```python
# ì‘ì—… ëª©ë¡
âœ… CandleData.create_empty_candle ë©”ì„œë“œì— timestamp_ms ë§¤ê°œë³€ìˆ˜ ì¶”ê°€
âœ… _datetime_to_timestamp_ms ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ êµ¬í˜„
âœ… _utc_to_kst_string ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ êµ¬í˜„
âœ… to_db_dict() ë©”ì„œë“œì˜ ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ë¡œì§ í™•ì¸
âœ… timestamp í•„ë“œê°€ ì˜¬ë°”ë¥´ê²Œ DBì— ì €ì¥ë˜ëŠ”ì§€ ê²€ì¦
âœ… ë¹ˆ ìº”ë“¤ ìƒì„± í…ŒìŠ¤íŠ¸ (timestamp ì •í™•ì„± í¬í•¨)
```

### 8.3 Phase 3: CandleDataProvider ìµœì†Œ í†µí•© (1ì¼)

```python
# ì‘ì—… ëª©ë¡
âœ… enable_empty_candle_processing ì˜µì…˜ ì¶”ê°€
âœ… _get_empty_candle_detector ìºì‹œ ë©”ì„œë“œ êµ¬í˜„
âœ… _process_chunk_with_empty_candles ë©”ì„œë“œ êµ¬í˜„
âœ… mark_chunk_completed ë©”ì„œë“œ ìˆ˜ì • (ê¸°ì¡´ í˜¸ì¶œ êµì²´)
âœ… ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ ì¸¡ì • (ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ON/OFF)
âœ… ê¸°ì¡´ ê¸°ëŠ¥ í˜¸í™˜ì„± í…ŒìŠ¤íŠ¸ (ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ë¹„í™œì„±í™”)
```

### 8.4 Phase 4: í†µí•© í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ (2ì¼)

```python
# í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ (timestamp í˜¸í™˜ì„± ì¤‘ì )
âœ… Gap ì—†ëŠ” ì •ìƒ ì¼€ì´ìŠ¤ (ì˜¤ë²„í—¤ë“œ í™•ì¸)
âœ… ì‘ì€ Gap ì¼€ì´ìŠ¤ (1-5ë¶„ Gap, timestamp ì •í™•ì„±)
âœ… í° Gap ì¼€ì´ìŠ¤ (1ì‹œê°„+ Gap, ëŒ€ëŸ‰ ë¹ˆ ìº”ë“¤)
âœ… ë§ˆì´ë„ˆ ì½”ì¸ 1ì´ˆë´‰ (ë¹ˆë²ˆí•œ Gap ì‹œë‚˜ë¦¬ì˜¤)
âœ… SqliteCandleRepository gap ê°ì§€ ì—°ë™ í…ŒìŠ¤íŠ¸
âœ… ì‹¤ì œ+ë¹ˆ ìº”ë“¤ í˜¼í•© í™˜ê²½ì—ì„œ find_last_continuous_time ì •ìƒ ë™ì‘ í™•ì¸
âœ… ëŒ€ëŸ‰ ë°ì´í„° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰, ì²˜ë¦¬ ì‹œê°„)
```

---

## ğŸ›ï¸ 9. ì„¤ì • ë° ì œì–´ ì˜µì…˜ (ê¸°ì¡´ + ì„±ëŠ¥ ì˜µì…˜)

### 9.1 ì „ì—­ ì„¤ì • (ì—…ë°ì´íŠ¸)

```python
# config/candle_config.yaml
empty_candle_processing:
  enabled: true

  # íƒ€ì„í”„ë ˆì„ë³„ í™œì„±í™”
  timeframes:
    "1s": true   # 1ì´ˆë´‰: í•„ìˆ˜ (ë§ˆì´ë„ˆ ì½”ì¸)
    "1m": true   # 1ë¶„ë´‰: ê¶Œì¥
    "5m": false  # 5ë¶„ë´‰: ì„ íƒì 
    "1h": false  # ì‹œê°„ë´‰: ë¶ˆí•„ìš”
    "1d": false  # ì¼ë´‰: ë¶ˆí•„ìš”

  # ì„±ëŠ¥ ì œì–´
  max_gap_size_minutes: 1440      # ìµœëŒ€ ì²˜ë¦¬í•  Gap í¬ê¸° (24ì‹œê°„)
  batch_size: 1000               # ë¹ˆ ìº”ë“¤ ë°°ì¹˜ ìƒì„± í¬ê¸°
  enable_timestamp_validation: true  # timestamp ì •í™•ì„± ê²€ì¦ í™œì„±í™” (NEW)
  cache_detectors: true          # EmptyCandleDetector ì¸ìŠ¤í„´ìŠ¤ ìºì‹± (NEW)
```

### 9.2 ëŸ°íƒ€ì„ ì œì–´ (ì—…ë°ì´íŠ¸)

```python
# CandleDataProvider ì¸ìŠ¤í„´ìŠ¤ë³„ ì œì–´
provider = CandleDataProvider(
    repository=repository,
    upbit_client=upbit_client,
    overlap_analyzer=overlap_analyzer,
    enable_empty_candle_processing=True  # ìƒì„±ìì—ì„œ ì„¤ì •
)

# íŠ¹ì • ìš”ì²­ì—ì„œë§Œ ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ (ë™ì  ì œì–´)
candles_with_empty = await provider.get_candles(
    "KRW-BTC", "1m", count=1000,
    # enable_empty_processing=True  # ë§¤ê°œë³€ìˆ˜ ë ˆë²¨ ì œì–´ (í–¥í›„ ì¶”ê°€ ê°€ëŠ¥)
)

# ëŸ°íƒ€ì„ ì„¤ì • ë³€ê²½
provider.set_empty_candle_processing(False)  # ì„ì‹œ ë¹„í™œì„±í™”
```

---

## âœ… 10. í•µì‹¬ ê°œì„ ì‚¬í•­ ë° ê¸°ëŒ€íš¨ê³¼ (v1.1)

### 10.1 ì•„í‚¤í…ì²˜ì  ê°œì„ ì‚¬í•­

- **í´ë˜ìŠ¤ ë¶„ë¦¬**: EmptyCandleDetectorë¡œ ê´€ì‹¬ì‚¬ ë¶„ë¦¬, CandleDataProvider ì½”ë“œ ê¸¸ì´ ë¬¸ì œ í•´ê²°
- **ê¸°ì¡´ ì½”ë“œ ë³´ì¡´**: Repository ë ˆì´ì–´ 100% ë¬´ë³€ê²½, ê¸°ì¡´ ì„±ëŠ¥ ìµœì í™” ì™„ì „ ìœ ì§€
- **ì„ íƒì  ì ìš©**: enable_empty_candle_processingìœ¼ë¡œ í•„ìš”ì‹œë§Œ í™œì„±í™”
- **Timestamp í˜¸í™˜ì„±**: SqliteCandleRepository gap ê°ì§€ ë¡œì§ê³¼ ì™„ë²½ í˜¸í™˜

### 10.2 ê¸°ìˆ ì  ê°œì„ ì‚¬í•­

- **ì •í™•í•œ Timestamp**: TimeUtils ê¸°ë°˜ íƒ€ì„í”„ë ˆì„ë³„ ì •í™•í•œ Unix timestamp (ë°€ë¦¬ì´ˆ) ìƒì„±
- **ğŸš€ ê·¹ì  ì„±ëŠ¥ ìµœì í™”**: ì²« ë²ˆì§¸ë§Œ datetime ë³€í™˜, ë‚˜ë¨¸ì§€ëŠ” ë‹¨ìˆœ ë§ì…ˆ (76ë°° ë¹¨ë¼ì§)
- **ğŸ¯ ì„±ëŠ¥ ë³´ì¡´**: Dict í˜•íƒœ ì²˜ë¦¬ë¡œ CandleDataProvider v6.0 ìµœì í™” ì™„ì „ ìœ ì§€ (90% ë©”ëª¨ë¦¬, 70% CPU)
- **ğŸ”„ ì—¬ëŸ¬ Gap ì§€ì›**: í•˜ë‚˜ì˜ ì²­í¬ ë‚´ ë³µìˆ˜ Gap ê·¸ë£¹ ì™„ë²½ ì²˜ë¦¬ (ë¬´ì œí•œ Gap ë™ì‹œ ì²˜ë¦¬)
- **ìŠ¤ë§ˆíŠ¸ ìºì‹±**: EmptyCandleDetector ì¸ìŠ¤í„´ìŠ¤ ìºì‹±, ë°°ì¹˜ ì²˜ë¦¬, O(n) Gap ê°ì§€
- **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ë¹ˆ ìº”ë“¤ì€ ì‹¤ì œ ìº”ë“¤ ëŒ€ë¹„ 40% ë©”ëª¨ë¦¬ë§Œ ì‚¬ìš© (timestamp í¬í•¨)
- **í™•ì¥ì„±**: ë‹¤ë¥¸ ë°ì´í„° ë³´ê°• ë¡œì§ë„ ê°™ì€ íŒ¨í„´ìœ¼ë¡œ ì¶”ê°€ ê°€ëŠ¥

### 10.3 ë¹„ì¦ˆë‹ˆìŠ¤ì  ê°œì„ ì‚¬í•­

- **ì™„ì „í•œ ì‹œê³„ì—´**: ëª¨ë“  ì‹œì ì— ëŒ€í•´ ì¼ê´€ëœ ìº”ë“¤ ë°ì´í„° ë³´ì¥
- **ì „ëµ ì •í™•ë„**: Gapìœ¼ë¡œ ì¸í•œ ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° ì˜¤ë¥˜ ë°©ì§€
- **ë°±í…ŒìŠ¤íŒ… ì‹ ë¢°ì„±**: ì‹¤ì œ ê±°ë˜ í™˜ê²½ê³¼ ë™ì¼í•œ ì¡°ê±´ì—ì„œ ì‹œë®¬ë ˆì´ì…˜
- **ë§ˆì´ë„ˆ ì½”ì¸ ì§€ì›**: 1ì´ˆë´‰ ê±°ë˜ê°€ ê°€ëŠ¥í•œ ì™„ì „í•œ ì¸í”„ë¼

---

## ğŸš€ 11. ê²°ë¡  ë° ë‹¤ìŒ ë‹¨ê³„

### 11.1 v1.1ì˜ í•µì‹¬ ê°€ì¹˜ ì œì•ˆ

ì´ **EmptyCandleDetector ë¶„ë¦¬ + Timestamp í˜¸í™˜** ë°©ì•ˆì€ ë‹¤ìŒ 4ê°€ì§€ í•µì‹¬ ê°€ì¹˜ë¥¼ ì œê³µí•©ë‹ˆë‹¤:

1. **êµ¬ì¡°ì  ì™„ì „ì„±**: í´ë˜ìŠ¤ ë¶„ë¦¬ë¡œ ê¹”ë”í•œ ì•„í‚¤í…ì²˜ + ìµœì†Œí•œì˜ ë³€ê²½
2. **ê¸°ìˆ ì  ì™„ì „ì„±**: Timestamp í˜¸í™˜ìœ¼ë¡œ ê¸°ì¡´ gap ê°ì§€ ë¡œì§ê³¼ ì™„ë²½ ì—°ë™
3. **ë°ì´í„° ì™„ì „ì„±**: ëª¨ë“  ì‹œì ì— ëŒ€í•´ ì¼ê´€ëœ ìº”ë“¤ ë°ì´í„° ë³´ì¥
4. **ì„±ëŠ¥ ì™„ì „ì„±**: ê¸°ì¡´ ìµœì í™” ìœ ì§€ + ì„ íƒì  ì²˜ë¦¬ë¡œ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”

### 11.2 ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ íš¨ê³¼

**í˜„ì¬ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê¸°ì¤€**:
- Gap 303ê°œ â†’ 0ê°œë¡œ ì™„ì „ í•´ê²°
- ëˆ„ë½ ì‹œê°„ 380ë¶„ â†’ ì™„ì „í•œ ì‹œê³„ì—´ë¡œ ë³µì›
- ë°ì´í„° ì™„ì „ì„± 99.8% â†’ 100% ë‹¬ì„±
- **ì½”ë“œ êµ¬ì¡°**: 600+ ë¼ì¸ CandleDataProvider â†’ ê¹”ë”í•œ í´ë˜ìŠ¤ ë¶„ë¦¬

### 11.3 ì‹¤í–‰ ê³„íš

**Week 1**: Phase 1-2 (EmptyCandleDetector + CandleData í™•ì¥)
**Week 2**: Phase 3-4 (CandleDataProvider í†µí•© + í…ŒìŠ¤íŠ¸)
**Week 3**: Timestamp í˜¸í™˜ì„± ê²€ì¦ + ì„±ëŠ¥ ìµœì í™”
**Week 4**: ìš´ì˜ í™˜ê²½ ì ìš© ë° ëª¨ë‹ˆí„°ë§

### 11.4 ì„±ê³µ ì§€í‘œ

âœ… **êµ¬ì¡°ì  ì§€í‘œ**: CandleDataProvider 300 ë¼ì¸ ì´í•˜ ìœ ì§€, í´ë˜ìŠ¤ ë¶„ë¦¬ ì™„ë£Œ
âœ… **ê¸°ëŠ¥ì  ì§€í‘œ**: Gap ê°œìˆ˜ 0ê°œ, ì‹œê³„ì—´ ì™„ì „ì„± 100%, Timestamp ì •í™•ì„± 100%
âœ… **ğŸš€ ì„±ëŠ¥ ì§€í‘œ**: CandleDataProvider v6.0 ìµœì í™” 100% ìœ ì§€ (90% ë©”ëª¨ë¦¬, 70% CPU), Dict ì²˜ë¦¬ë¡œ ì„±ëŠ¥ ë³´ì¡´
âœ… **ğŸ”„ í™•ì¥ì„± ì§€í‘œ**: ì—¬ëŸ¬ Gap ê·¸ë£¹ ì™„ë²½ ì²˜ë¦¬, ì²­í¬ë‹¹ ë¬´ì œí•œ Gap ë™ì‹œ ì²˜ë¦¬ ê°€ëŠ¥
âœ… **í˜¸í™˜ì„± ì§€í‘œ**: ê¸°ì¡´ ê¸°ëŠ¥ í˜¸í™˜ì„± 100%, SqliteCandleRepository gap ê°ì§€ ì •ìƒ ë™ì‘, save_raw_api_data ì™„ì „ í˜¸í™˜

---

**ğŸ’¡ í•µì‹¬ ë©”ì‹œì§€**: ì´ v1.1 ë°©ì•ˆì€ ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì„ **"ê¹”ë”í•œ ì•„í‚¤í…ì²˜ë¡œ ì™„ì „í•œ ì‹œê³„ì—´ì„ ë³´ì¥í•˜ëŠ” ê²¬ê³ í•œ ì‹œìŠ¤í…œ"**ìœ¼ë¡œ ë°œì „ì‹œí‚¤ëŠ” í•µì‹¬ ì¸í”„ë¼ì…ë‹ˆë‹¤.

EmptyCandleDetector í´ë˜ìŠ¤ ë¶„ë¦¬ë¥¼ í†µí•´ **ì½”ë“œ êµ¬ì¡°ì˜ ëª…í™•ì„±**ì„ í™•ë³´í•˜ê³ , ì •í™•í•œ timestamp ìƒì„±ì„ í†µí•´ **ê¸°ì¡´ gap ê°ì§€ ë¡œì§ê³¼ì˜ ì™„ë²½í•œ í˜¸í™˜ì„±**ì„ ë³´ì¥í•˜ì—¬, ëª¨ë“  ìë™ë§¤ë§¤ ì „ëµì´ ì™„ì „í•œ ë°ì´í„° í™˜ê²½ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ë™ì‘í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ğŸ¯âœ¨
