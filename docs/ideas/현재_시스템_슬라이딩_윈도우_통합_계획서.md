# ğŸ”„ í˜„ì¬ ì‹œìŠ¤í…œ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° í†µí•© ê³„íšì„œ

> **GCRA + ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë³‘ë ¬ ê´€ì°° ëª¨ë“œ êµ¬í˜„ ê³„íš**
> ê¸°ì¡´ ì‹œìŠ¤í…œ ë³´ì¡´í•˜ë©° ìƒˆ ì•Œê³ ë¦¬ì¦˜ì„ ì•ˆì „í•˜ê²Œ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì ì§„ì  í†µí•© ì „ëµ

---

## ğŸ¯ **í”„ë¡œì íŠ¸ ëª©í‘œ**

### í•µì‹¬ ì›ì¹™
ğŸ›¡ï¸ **Zero-Risk Policy** - ê¸°ì¡´ ë™ì‘í•˜ëŠ” ì‹œìŠ¤í…œì— ì ˆëŒ€ ì˜í–¥ ì—†ìŒ
ğŸ” **ê´€ì°° ìš°ì„ ** - ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ëŠ” ìˆœìˆ˜ ê´€ì°° ëª¨ë“œë¡œ ì‹œì‘
ğŸ“Š **ë°ì´í„° ê¸°ë°˜ ê²°ì •** - ì¶©ë¶„í•œ ë¹„êµ ë°ì´í„° ìˆ˜ì§‘ í›„ ì „í™˜ ê²°ì •
ğŸš€ **ì ì§„ì  ì „í™˜** - ë‹¨ê³„ë³„ ê²€ì¦ì„ í†µí•œ ì•ˆì „í•œ ë§ˆì´ê·¸ë ˆì´ì…˜

### ì„±ê³µ ì§€í‘œ
- [ ] ê¸°ì¡´ ì‹œìŠ¤í…œ 100% ë¬´ê²°ì„± ìœ ì§€
- [ ] ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì •í™•ë„ 99%+ ê²€ì¦
- [ ] ë‘ ì•Œê³ ë¦¬ì¦˜ ê°„ ì„±ëŠ¥ ì°¨ì´ ë¶„ì„ ì™„ë£Œ
- [ ] 429 ì—ëŸ¬ ë°œìƒìœ¨ ê°œì„  í™•ì¸

---

## ğŸ—ï¸ **í˜„ì¬ ìƒí™© ë¶„ì„**

### ê¸°ì¡´ ì‹œìŠ¤í…œì˜ ë›°ì–´í•œ ì¥ì ë“¤
âœ… **Lock-Free GCRA** - aiohttp íŒ¨í„´ ê¸°ë°˜ ê³ ì„±ëŠ¥ ì²˜ë¦¬
âœ… **ë™ì  ì¡°ì •** - 429 ìë™ ëŒ€ì‘, ì ì‘í˜• ì „ëµ
âœ… **ìê°€ì¹˜ìœ  íƒœìŠ¤í¬ ë§¤ë‹ˆì €** - ë°±ê·¸ë¼ìš´ë“œ ì¥ì•  ê°ì§€/ë³µêµ¬
âœ… **íƒ€ì„ì•„ì›ƒ ë³´ì¥ ë§¤ë‹ˆì €** - ë¬´í•œ ëŒ€ê¸° ë°©ì§€, ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì°¨ë‹¨
âœ… **ì›ìì  TAT ë§¤ë‹ˆì €** - Race condition ì™„ë²½ í•´ê²°
âœ… **ì´ì¤‘ ì œí•œ ì§€ì›** - RPS + RPM ë³µí•© ì œí•œ (ì›¹ì†Œì¼“)
âœ… **ì •êµí•œ ë²„ìŠ¤íŠ¸** - tau ê¸°ë°˜ GCRA, 98% ë§ˆì§„ ì ìš©
âœ… **í†µí•© ëª¨ë‹ˆí„°ë§** - ìƒì„¸ í†µê³„, êµ¬ì¡°í™”ëœ ë¡œê¹…
âœ… **Zero-429 ì •ì±…** - ì˜ˆë°©ì  ìŠ¤ë¡œí‹€ë§

### í˜„ì¬ ë¬¸ì œì 
âŒ **429 ì—ëŸ¬ ê°„í—ì  ë°œìƒ** - 7rps + 1ë²„ìŠ¤íŠ¸ ì¡°ê±´ì—ì„œë„ 429 ë°œìƒ
âŒ **ê²½ê³„ ì¡°ê±´ ì´ìŠˆ** - Fixed Windowì˜ ìœˆë„ìš° ê²½ê³„ ë²„ìŠ¤íŠ¸
âŒ **ë¶€ì •í™•í•œ ì œí•œ** - ì‹¤ì œ ì—…ë¹„íŠ¸ ì„œë²„ì˜ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì™€ ë¶ˆì¼ì¹˜

---

## ğŸ”§ **í†µí•© êµ¬í˜„ ì „ëµ**

### ë³‘ë ¬ ê´€ì°° ëª¨ë“œ ì•„í‚¤í…ì²˜
```
ê¸°ì¡´ GCRA ì‹œìŠ¤í…œ (ì‹¤ì œ ì œì–´)
â”œâ”€â”€ ëª¨ë“  ìš”ì²­ì˜ ì‹¤ì œ í—ˆìš©/ê±°ë¶€ ê²°ì •
â”œâ”€â”€ ê¸°ì¡´ ë¡œì§ 100% ë³´ì¡´
â””â”€â”€ í”„ë¡œë•ì…˜ ì•ˆì •ì„± ìœ ì§€

ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì‹œìŠ¤í…œ (ê´€ì°° ëª¨ë“œ)
â”œâ”€â”€ ëª¨ë“  ìš”ì²­ì„ ë³‘ë ¬ë¡œ ì¶”ì 
â”œâ”€â”€ í—ˆìš©/ê±°ë¶€ ê²°ì • ê³„ì‚° (ì ìš©í•˜ì§€ ì•ŠìŒ)
â”œâ”€â”€ ìƒì„¸í•œ ë¹„êµ ë¡œê¹…
â””â”€â”€ í†µê³„ ë°ì´í„° ìˆ˜ì§‘
```

### í•µì‹¬ í†µí•© ì§€ì 
**`AtomicTATManager._consume_single_token_atomic` ë©”ì„œë“œ í™•ì¥**
```python
async def _consume_single_token_atomic(self, group, config, stats, now, rate_ratio):
    # ğŸ”’ ê¸°ì¡´ GCRA ë¡œì§ (ì‹¤ì œ ì ìš©) - ì™„ì „ ë³´ì¡´
    gcra_allowed, gcra_tat = self._execute_gcra_logic(...)

    # ğŸ” ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë³‘ë ¬ ê´€ì°° (ìƒˆë¡œ ì¶”ê°€)
    sw_allowed, sw_detail = await self._observe_sliding_window(...)

    # ğŸ“Š ë¹„êµ ë¡œê¹… ë° í†µê³„ ìˆ˜ì§‘
    await self._log_algorithm_comparison(gcra_allowed, sw_allowed, ...)

    # âœ… ê¸°ì¡´ GCRA ê²°ê³¼ë§Œ ì‹¤ì œ ì ìš©
    return gcra_allowed, gcra_tat
```

---

## ğŸ“ **êµ¬í˜„ ê³„íš ìƒì„¸**

### Phase 1: ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê´€ì°° ë³€ìˆ˜ ì¶”ê°€ (1ì¼)

#### 1.1 UnifiedUpbitRateLimiter í´ë˜ìŠ¤ í™•ì¥
```python
class UnifiedUpbitRateLimiter:
    def __init__(self, ...):
        # ê¸°ì¡´ ë³€ìˆ˜ë“¤ (ì „í˜€ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ)
        # ...

        # ğŸ†• ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê´€ì°°ìš© ë³€ìˆ˜ë“¤ ì¶”ê°€
        self.sliding_window_config = {
            'enabled': True,  # ê´€ì°° ëª¨ë“œ í™œì„±í™”
            'window_size': 60.0,  # 1ë¶„ ìœˆë„ìš°
            'max_log_size': 1000,  # ë©”ëª¨ë¦¬ ì œí•œ
            'cleanup_interval': 30.0  # ì •ë¦¬ ì£¼ê¸°
        }

        # ê·¸ë£¹ë³„ ìš”ì²­ ë¡œê·¸ ì €ì¥ì†Œ
        self.sliding_window_logs: Dict[UpbitRateLimitGroup, List[Tuple[float, int]]] = {
            group: [] for group in UpbitRateLimitGroup
        }

        # í†µê³„ ë° ë¹„êµ ë°ì´í„°
        self.algorithm_comparison_stats = {
            'total_requests': 0,
            'gcra_allowed': 0,
            'sw_allowed': 0,
            'both_allowed': 0,
            'both_denied': 0,
            'gcra_only_allowed': 0,
            'sw_only_allowed': 0,
            'last_cleanup': time.monotonic()
        }
```

#### 1.2 ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ ì¶”ê°€
```python
def _update_sliding_window_log(self, group: UpbitRateLimitGroup, now: float, weight: int = 1):
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ì— ìš”ì²­ ì¶”ê°€"""

def _cleanup_sliding_window_log(self, group: UpbitRateLimitGroup, now: float):
    """ë§Œë£Œëœ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ ì •ë¦¬"""

def _calculate_sliding_window_count(self, group: UpbitRateLimitGroup, now: float) -> Tuple[int, int]:
    """í˜„ì¬ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë‚´ ìš”ì²­ ìˆ˜ ê³„ì‚°"""

def _sliding_window_would_allow(self, group: UpbitRateLimitGroup, now: float, weight: int = 1) -> Tuple[bool, Dict]:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê¸°ì¤€ í—ˆìš© ì—¬ë¶€ í™•ì¸ (ê´€ì°°ìš©)"""
```

### Phase 2: AtomicTATManager í™•ì¥ (2ì¼)

#### 2.1 ë³‘ë ¬ ê´€ì°° ë¡œì§ í†µí•©
```python
async def _consume_single_token_atomic(self, group, config, stats, now, current_rate_ratio):
    """GCRA + ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë³‘ë ¬ ì‹¤í–‰"""

    # ğŸ”’ ê¸°ì¡´ GCRA ë¡œì§ (100% ë³´ì¡´)
    current_tat = self.limiter.group_tats.get(group, now)
    base_interval = config.emission_interval
    adjusted_interval = (base_interval / current_rate_ratio) * 1.02  # 98% ë§ˆì§„
    tau = config.burst_capacity * adjusted_interval

    # GCRA ê²°ì • (ê¸°ì¡´ ë¡œì§ ê·¸ëŒ€ë¡œ)
    if current_tat <= now:
        gcra_allowed = True
        new_tat = now + adjusted_interval
        self.limiter.group_tats[group] = new_tat
        burst_remaining = config.burst_capacity
    else:
        debt_time = current_tat - now
        if debt_time <= tau:
            gcra_allowed = True
            new_tat = current_tat + adjusted_interval
            self.limiter.group_tats[group] = new_tat
            burst_remaining = max(0, config.burst_capacity - (debt_time / adjusted_interval))
        else:
            gcra_allowed = False
            new_tat = current_tat
            burst_remaining = 0

    # ğŸ” ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë³‘ë ¬ ê´€ì°° (ìƒˆë¡œ ì¶”ê°€)
    if self.limiter.sliding_window_config['enabled']:
        sw_allowed, sw_detail = await self._observe_sliding_window_decision(group, now)

        # ğŸ“Š ë¹„êµ ë°ì´í„° ìˆ˜ì§‘
        await self._collect_comparison_data(group, gcra_allowed, sw_allowed, sw_detail, burst_remaining)

        # ğŸ§¹ ì£¼ê¸°ì  ë¡œê·¸ ì •ë¦¬
        if now - self.limiter.algorithm_comparison_stats['last_cleanup'] > 30.0:
            await self._cleanup_sliding_window_logs(now)

    # âœ… ê¸°ì¡´ GCRA ê²°ê³¼ë§Œ ì‹¤ì œ ì ìš© (ë³€í™” ì—†ìŒ)
    self.atomic_stats['successful_acquisitions'] += 1 if gcra_allowed else 0
    if not gcra_allowed:
        self.atomic_stats['rejected_acquisitions'] += 1

    return gcra_allowed, new_tat
```

#### 2.2 ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê´€ì°° ë©”ì„œë“œ
```python
async def _observe_sliding_window_decision(self, group: UpbitRateLimitGroup, now: float) -> Tuple[bool, Dict]:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê²°ì • ì‹œë®¬ë ˆì´ì…˜"""

    config = self.limiter.group_configs[group]
    window_size = self.limiter.sliding_window_config['window_size']

    # 1. ë¡œê·¸ì— í˜„ì¬ ìš”ì²­ ê°€ìƒ ì¶”ê°€
    self.limiter._update_sliding_window_log(group, now, weight=1)

    # 2. í˜„ì¬ ìœˆë„ìš° ë‚´ ìš”ì²­ ìˆ˜ ê³„ì‚°
    window_start = now - window_size
    current_logs = self.limiter.sliding_window_logs[group]
    valid_requests = [
        (timestamp, weight) for timestamp, weight in current_logs
        if timestamp >= window_start
    ]

    total_weight = sum(weight for _, weight in valid_requests)

    # 3. ì œí•œ í™•ì¸ (config.rps * window_sizeë¥¼ ìµœëŒ€ ìš”ì²­ìˆ˜ë¡œ ê°€ì •)
    max_requests_in_window = int(config.rps * window_size)
    would_allow = total_weight <= max_requests_in_window

    # 4. ìƒì„¸ ì •ë³´ ìˆ˜ì§‘
    detail = {
        'window_start': window_start,
        'window_end': now,
        'total_requests': len(valid_requests),
        'total_weight': total_weight,
        'max_requests': max_requests_in_window,
        'utilization_rate': total_weight / max_requests_in_window if max_requests_in_window > 0 else 0,
        'oldest_request': min((t for t, _ in valid_requests), default=None),
        'newest_request': max((t for t, _ in valid_requests), default=None)
    }

    return would_allow, detail
```

### Phase 3: ë¹„êµ ë¡œê¹… ë° í†µê³„ ì‹œìŠ¤í…œ (1ì¼)

#### 3.1 ìƒì„¸ ë¹„êµ ë¡œê¹…
```python
async def _collect_comparison_data(self,
                                 group: UpbitRateLimitGroup,
                                 gcra_allowed: bool,
                                 sw_allowed: bool,
                                 sw_detail: Dict,
                                 burst_remaining: int):
    """ë‘ ì•Œê³ ë¦¬ì¦˜ ê²°ê³¼ ë¹„êµ ë°ì´í„° ìˆ˜ì§‘"""

    stats = self.limiter.algorithm_comparison_stats
    stats['total_requests'] += 1

    if gcra_allowed:
        stats['gcra_allowed'] += 1
    if sw_allowed:
        stats['sw_allowed'] += 1

    # ê²°ì • ì¼ì¹˜ ì—¬ë¶€ ë¶„ì„
    if gcra_allowed and sw_allowed:
        stats['both_allowed'] += 1
        result_type = "ì¼ì¹˜í—ˆìš©"
    elif not gcra_allowed and not sw_allowed:
        stats['both_denied'] += 1
        result_type = "ì¼ì¹˜ê±°ë¶€"
    elif gcra_allowed and not sw_allowed:
        stats['gcra_only_allowed'] += 1
        result_type = "GCRAë§Œí—ˆìš©"
    else:  # not gcra_allowed and sw_allowed
        stats['sw_only_allowed'] += 1
        result_type = "SWë§Œí—ˆìš©"

    # ìƒì„¸ ë¡œê¹… (ì¤‘ìš”í•œ ë¶ˆì¼ì¹˜ë§Œ)
    if gcra_allowed != sw_allowed:
        self.logger.warning(
            f"ğŸ”„ ì•Œê³ ë¦¬ì¦˜ ë¶ˆì¼ì¹˜: {group.value} {result_type} "
            f"GCRA({gcra_allowed}:ë²„ìŠ¤íŠ¸{burst_remaining}) "
            f"SW({sw_allowed}:{sw_detail['total_weight']}/{sw_detail['max_requests']} "
            f"ì´ìš©ë¥ {sw_detail['utilization_rate']:.1%})"
        )
    else:
        # ì¼ì¹˜í•˜ëŠ” ê²½ìš°ëŠ” debug ë ˆë²¨ë¡œ
        self.logger.debug(
            f"ğŸ”„ ì•Œê³ ë¦¬ì¦˜ ì¼ì¹˜: {group.value} {result_type} "
            f"SWì´ìš©ë¥ :{sw_detail['utilization_rate']:.1%} ë²„ìŠ¤íŠ¸:{burst_remaining}"
        )

    # í†µê³„ ìš”ì•½ (100íšŒë§ˆë‹¤)
    if stats['total_requests'] % 100 == 0:
        self._log_comparison_summary(stats)
```

#### 3.2 í†µê³„ ìš”ì•½ ë° ë¶„ì„
```python
def _log_comparison_summary(self, stats: Dict):
    """ë¹„êµ í†µê³„ ìš”ì•½ ë¡œê¹…"""

    total = stats['total_requests']
    if total == 0:
        return

    agreement_rate = (stats['both_allowed'] + stats['both_denied']) / total * 100
    gcra_allow_rate = stats['gcra_allowed'] / total * 100
    sw_allow_rate = stats['sw_allowed'] / total * 100

    self.logger.info(
        f"ğŸ“Š ì•Œê³ ë¦¬ì¦˜ ë¹„êµ í†µê³„ (ì´ {total}íšŒ):\n"
        f"  ì¼ì¹˜ìœ¨: {agreement_rate:.1f}% "
        f"(í—ˆìš©ì¼ì¹˜:{stats['both_allowed']} ê±°ë¶€ì¼ì¹˜:{stats['both_denied']})\n"
        f"  GCRA í—ˆìš©ë¥ : {gcra_allow_rate:.1f}% ({stats['gcra_allowed']}/{total})\n"
        f"  SW í—ˆìš©ë¥ : {sw_allow_rate:.1f}% ({stats['sw_allowed']}/{total})\n"
        f"  ë¶ˆì¼ì¹˜: GCRAë§Œí—ˆìš©:{stats['gcra_only_allowed']} SWë§Œí—ˆìš©:{stats['sw_only_allowed']}"
    )

def get_comparison_report(self) -> Dict[str, Any]:
    """ìƒì„¸ ë¹„êµ ë³´ê³ ì„œ ìƒì„±"""

    stats = self.limiter.algorithm_comparison_stats
    total = stats['total_requests']

    if total == 0:
        return {'status': 'no_data'}

    return {
        'total_requests': total,
        'agreement_rate': (stats['both_allowed'] + stats['both_denied']) / total,
        'gcra_allow_rate': stats['gcra_allowed'] / total,
        'sw_allow_rate': stats['sw_allowed'] / total,
        'consistency_analysis': {
            'both_allowed': stats['both_allowed'],
            'both_denied': stats['both_denied'],
            'gcra_only_allowed': stats['gcra_only_allowed'],
            'sw_only_allowed': stats['sw_only_allowed']
        },
        'recommendation': self._generate_migration_recommendation(stats)
    }

def _generate_migration_recommendation(self, stats: Dict) -> str:
    """ë§ˆì´ê·¸ë ˆì´ì…˜ ê¶Œì¥ì‚¬í•­ ìƒì„±"""

    total = stats['total_requests']
    if total < 1000:
        return "insufficient_data"

    agreement_rate = (stats['both_allowed'] + stats['both_denied']) / total
    sw_more_restrictive = stats['gcra_only_allowed'] > stats['sw_only_allowed']

    if agreement_rate > 0.95:
        if sw_more_restrictive:
            return "sw_ready_more_restrictive"  # SWê°€ ë” ì—„ê²© - 429 ê°ì†Œ ê¸°ëŒ€
        else:
            return "sw_ready_equivalent"  # ê±°ì˜ ë™ì¼
    elif agreement_rate > 0.90:
        return "sw_needs_tuning"  # íŠœë‹ í•„ìš”
    else:
        return "sw_not_ready"  # ì•„ì§ ì¤€ë¹„ ì•ˆë¨
```

### Phase 4: ë©”ëª¨ë¦¬ ê´€ë¦¬ ë° ìµœì í™” (1ì¼)

#### 4.1 ë¡œê·¸ ì •ë¦¬ ì‹œìŠ¤í…œ
```python
async def _cleanup_sliding_window_logs(self, now: float):
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ ì •ë¦¬"""

    window_size = self.sliding_window_config['window_size']
    max_log_size = self.sliding_window_config['max_log_size']
    cutoff_time = now - window_size

    total_cleaned = 0

    for group in UpbitRateLimitGroup:
        logs = self.sliding_window_logs[group]

        # 1. ì‹œê°„ ê¸°ë°˜ ì •ë¦¬
        original_count = len(logs)
        self.sliding_window_logs[group] = [
            (timestamp, weight) for timestamp, weight in logs
            if timestamp >= cutoff_time
        ]

        # 2. í¬ê¸° ê¸°ë°˜ ì •ë¦¬ (ë©”ëª¨ë¦¬ ì œí•œ)
        if len(self.sliding_window_logs[group]) > max_log_size:
            # ìµœì‹  ìš”ì²­ë“¤ë§Œ ìœ ì§€
            self.sliding_window_logs[group] = self.sliding_window_logs[group][-max_log_size:]

        cleaned = original_count - len(self.sliding_window_logs[group])
        total_cleaned += cleaned

    if total_cleaned > 0:
        self.logger.debug(f"ğŸ§¹ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ ì •ë¦¬: {total_cleaned}ê°œ ì—”íŠ¸ë¦¬ ì œê±°")

    # ì •ë¦¬ ì‹œê°„ ì—…ë°ì´íŠ¸
    self.algorithm_comparison_stats['last_cleanup'] = now
```

#### 4.2 ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§
```python
def get_sliding_window_memory_usage(self) -> Dict[str, Any]:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¡°íšŒ"""

    total_entries = sum(len(logs) for logs in self.sliding_window_logs.values())
    estimated_memory_mb = total_entries * 32 / 1024 / 1024  # ëŒ€ëµì  ì¶”ì •

    return {
        'total_log_entries': total_entries,
        'estimated_memory_mb': estimated_memory_mb,
        'groups': {
            group.value: len(logs)
            for group, logs in self.sliding_window_logs.items()
        },
        'config': self.sliding_window_config
    }
```

---

## ğŸ“… **êµ¬í˜„ íƒ€ì„ë¼ì¸**

### Week 1: ê´€ì°° ëª¨ë“œ êµ¬í˜„
- **Day 1**: Phase 1 - ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë³€ìˆ˜ ì¶”ê°€
- **Day 2-3**: Phase 2 - AtomicTATManager í™•ì¥
- **Day 4**: Phase 3 - ë¹„êµ ë¡œê¹… ì‹œìŠ¤í…œ
- **Day 5**: Phase 4 - ë©”ëª¨ë¦¬ ê´€ë¦¬ ë° í…ŒìŠ¤íŠ¸

### Week 2: ê²€ì¦ ë° ë¶„ì„
- **Day 1-3**: ì‹¤ì œ API í™˜ê²½ì—ì„œ ê´€ì°° ë°ì´í„° ìˆ˜ì§‘
- **Day 4**: ìˆ˜ì§‘ëœ ë°ì´í„° ë¶„ì„ ë° íŠœë‹
- **Day 5**: ì„±ëŠ¥ ì˜í–¥ ë¶„ì„ ë° ìµœì í™”

### Week 3: ê²°ì • ë° ì „í™˜ (ì„ íƒì )
- **Day 1-2**: ë§ˆì´ê·¸ë ˆì´ì…˜ ê²°ì • (ë°ì´í„° ê¸°ë°˜)
- **Day 3-4**: ì ì§„ì  ì „í™˜ (í•„ìš” ì‹œ)
- **Day 5**: ìµœì¢… ê²€ì¦ ë° ë¬¸ì„œí™”

---

## ğŸ” **í…ŒìŠ¤íŠ¸ ê³„íš**

### ê´€ì°° ëª¨ë“œ í…ŒìŠ¤íŠ¸
```python
# 1. ê¸°ë³¸ ë™ì‘ í…ŒìŠ¤íŠ¸
await limiter.acquire_permission(UpbitRateLimitGroup.REST_PUBLIC, "ticker")

# 2. ë²„ìŠ¤íŠ¸ ìƒí™© í…ŒìŠ¤íŠ¸
for i in range(10):
    result = await limiter.acquire_permission(UpbitRateLimitGroup.REST_PUBLIC, f"test_{i}")

# 3. ë¹„êµ í†µê³„ í™•ì¸
report = limiter.get_comparison_report()
print(f"ì¼ì¹˜ìœ¨: {report['agreement_rate']:.1%}")

# 4. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
memory_info = limiter.get_sliding_window_memory_usage()
print(f"ë©”ëª¨ë¦¬ ì‚¬ìš©: {memory_info['estimated_memory_mb']:.1f}MB")
```

### ì‹¤ì œ API í…ŒìŠ¤íŠ¸
```python
# rest_api_public_all_endpoint_response.py ìˆ˜ì •í•˜ì—¬ ë¹„êµ ë°ì´í„° ìˆ˜ì§‘
async def test_with_comparison_logging():
    for i in range(100):
        await upbit_client.get_ticker("KRW-BTC")

        # ë§¤ 10íšŒë§ˆë‹¤ í†µê³„ í™•ì¸
        if i % 10 == 0:
            report = rate_limiter.get_comparison_report()
            logger.info(f"ì§„í–‰: {i}/100, ì¼ì¹˜ìœ¨: {report['agreement_rate']:.1%}")
```

---

## âš ï¸ **ë¦¬ìŠ¤í¬ ë¶„ì„ ë° ëŒ€ì‘**

### ì‹ë³„ëœ ë¦¬ìŠ¤í¬ë“¤

#### ğŸ”´ High Risk
**ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€**
- **ë¦¬ìŠ¤í¬**: ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ë¡œ ì¸í•œ ë©”ëª¨ë¦¬ ì¦ê°€
- **ëŒ€ì‘**: ìµœëŒ€ ë¡œê·¸ í¬ê¸° ì œí•œ, ì£¼ê¸°ì  ì •ë¦¬, ë©”ëª¨ë¦¬ ëª¨ë‹ˆí„°ë§
- **ì„ê³„ê°’**: 50MB ì´ˆê³¼ ì‹œ ê²½ê³ , 100MB ì´ˆê³¼ ì‹œ ìë™ ë¹„í™œì„±í™”

**ì„±ëŠ¥ ì €í•˜**
- **ë¦¬ìŠ¤í¬**: ì¶”ê°€ ê³„ì‚°ìœ¼ë¡œ ì¸í•œ ì§€ì—°
- **ëŒ€ì‘**: ë¹„ë™ê¸° ì²˜ë¦¬, ìºì‹±, ë°°ì¹˜ ì •ë¦¬
- **ì„ê³„ê°’**: í‰ê·  ì‘ë‹µì‹œê°„ 10% ì¦ê°€ ì‹œ ìµœì í™”

#### ğŸŸ¡ Medium Risk
**ë¡œê¹… ì˜¤ë²„í—¤ë“œ**
- **ë¦¬ìŠ¤í¬**: ê³¼ë„í•œ ë¡œê¹…ìœ¼ë¡œ ì¸í•œ I/O ë¶€í•˜
- **ëŒ€ì‘**: ë¡œê·¸ ë ˆë²¨ ì¡°ì •, ë°°ì¹˜ ë¡œê¹…, ì¤‘ìš”í•œ ì´ë²¤íŠ¸ë§Œ ë¡œê¹…
- **ëª¨ë‹ˆí„°ë§**: ë¡œê·¸ ë³¼ë¥¨ ë° ë””ìŠ¤í¬ ì‚¬ìš©ëŸ‰ ì¶”ì 

**ë°ì´í„° ë¶„ì„ ë³µì¡ì„±**
- **ë¦¬ìŠ¤í¬**: ìˆ˜ì§‘ëœ ë°ì´í„° í•´ì„ì˜ ì–´ë ¤ì›€
- **ëŒ€ì‘**: ìë™ ë¶„ì„ íˆ´, ì‹œê°í™”, ëª…í™•í•œ ë©”íŠ¸ë¦­ ì •ì˜

#### ğŸŸ¢ Low Risk
**ê¸°ì¡´ ì‹œìŠ¤í…œ ì˜í–¥**
- **ë¦¬ìŠ¤í¬**: ê´€ì°° ëª¨ë“œê°€ ê¸°ì¡´ ë¡œì§ì— ì˜í–¥
- **ëŒ€ì‘**: ì² ì €í•œ ê²©ë¦¬, ì˜ˆì™¸ ì²˜ë¦¬, ë¡¤ë°± ë©”ì»¤ë‹ˆì¦˜

### ë¡¤ë°± ì „ëµ
```python
# ê¸´ê¸‰ ë¹„í™œì„±í™” ë©”ì»¤ë‹ˆì¦˜
def emergency_disable_sliding_window():
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê´€ì°° ëª¨ë“œ ê¸´ê¸‰ ë¹„í™œì„±í™”"""

    self.sliding_window_config['enabled'] = False
    self.sliding_window_logs.clear()
    self.algorithm_comparison_stats.clear()

    self.logger.warning("ğŸš¨ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê´€ì°° ëª¨ë“œ ê¸´ê¸‰ ë¹„í™œì„±í™”")

# ìë™ ë¡¤ë°± ì¡°ê±´
def check_auto_rollback_conditions(self):
    """ìë™ ë¡¤ë°± ì¡°ê±´ í™•ì¸"""

    memory_usage = self.get_sliding_window_memory_usage()

    # ë©”ëª¨ë¦¬ ì„ê³„ê°’ ì´ˆê³¼
    if memory_usage['estimated_memory_mb'] > 100:
        self.emergency_disable_sliding_window()
        return True

    # ì„±ëŠ¥ ì„ê³„ê°’ ì´ˆê³¼ (í‰ê·  ì‘ë‹µì‹œê°„ ê¸°ì¤€)
    avg_response_time = self.get_average_response_time()
    if avg_response_time > self.baseline_response_time * 1.2:
        self.emergency_disable_sliding_window()
        return True

    return False
```

---

## ğŸ“Š **ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ ì„¤ê³„**

### í•µì‹¬ ë©”íŠ¸ë¦­ë“¤
```python
def generate_monitoring_dashboard_data(self) -> Dict[str, Any]:
    """ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œìš© ë°ì´í„° ìƒì„±"""

    comparison_report = self.get_comparison_report()
    memory_info = self.get_sliding_window_memory_usage()

    return {
        'algorithm_comparison': {
            'total_requests': comparison_report.get('total_requests', 0),
            'agreement_rate': comparison_report.get('agreement_rate', 0),
            'gcra_allow_rate': comparison_report.get('gcra_allow_rate', 0),
            'sw_allow_rate': comparison_report.get('sw_allow_rate', 0),
            'recommendation': comparison_report.get('recommendation', 'insufficient_data')
        },
        'performance_metrics': {
            'memory_usage_mb': memory_info['estimated_memory_mb'],
            'total_log_entries': memory_info['total_log_entries'],
            'avg_response_time_ms': self.get_average_response_time_ms(),
            'cleanup_frequency': self.get_cleanup_frequency()
        },
        'group_breakdown': {
            group.value: {
                'log_entries': memory_info['groups'][group.value],
                'recent_requests': self.get_recent_request_count(group),
                'allow_rate_gcra': self.get_group_allow_rate_gcra(group),
                'allow_rate_sw': self.get_group_allow_rate_sw(group)
            }
            for group in UpbitRateLimitGroup
        }
    }
```

### ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
```bash
# PowerShell ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸
$pythonScript = @"
import asyncio
from upbit_auto_trading.infrastructure.external_apis.upbit.rate_limiter import UnifiedUpbitRateLimiter

async def monitor_comparison():
    # ì‹¤ì œ rate limiter ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
    limiter = get_current_rate_limiter()

    while True:
        dashboard_data = limiter.generate_monitoring_dashboard_data()

        print(f"â° {datetime.now()}")
        print(f"ì´ ìš”ì²­: {dashboard_data['algorithm_comparison']['total_requests']}")
        print(f"ì¼ì¹˜ìœ¨: {dashboard_data['algorithm_comparison']['agreement_rate']:.1%}")
        print(f"ë©”ëª¨ë¦¬: {dashboard_data['performance_metrics']['memory_usage_mb']:.1f}MB")
        print(f"ê¶Œì¥ì‚¬í•­: {dashboard_data['algorithm_comparison']['recommendation']}")
        print("-" * 50)

        await asyncio.sleep(10)  # 10ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸

if __name__ == '__main__':
    asyncio.run(monitor_comparison())
"@

python -c $pythonScript
```

---

## ğŸ¯ **ì„±ê³µ ê¸°ì¤€ ë° KPI**

### ê¸°ìˆ ì  KPI
- [ ] **ê¸°ì¡´ ì‹œìŠ¤í…œ ë¬´ê²°ì„±**: 100% ìœ ì§€ (429 ì—ëŸ¬ìœ¨ ì¦ê°€ ì—†ìŒ)
- [ ] **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: 50MB ì´í•˜ ìœ ì§€
- [ ] **ì„±ëŠ¥ ì˜í–¥**: í‰ê·  ì‘ë‹µì‹œê°„ 5% ì´ë‚´ ì¦ê°€
- [ ] **ë°ì´í„° ìˆ˜ì§‘ëŸ‰**: 10,000íšŒ ì´ìƒ ìš”ì²­ ë¹„êµ ë°ì´í„°

### ë¹„ì¦ˆë‹ˆìŠ¤ KPI
- [ ] **429 ì—ëŸ¬ ê°ì†Œ**: ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¡œ ì „í™˜ ì‹œ 50% ì´ìƒ ê°ì†Œ
- [ ] **API ì•ˆì •ì„±**: 99.9% ì„±ê³µë¥  ìœ ì§€
- [ ] **ê°œë°œ ìƒì‚°ì„±**: Rate limiting ê´€ë ¨ ì´ìŠˆ ëŒ€ì‘ ì‹œê°„ ë‹¨ì¶•

### ì˜ì‚¬ê²°ì • ê¸°ì¤€
```python
def evaluate_migration_readiness(comparison_report: Dict) -> str:
    """ë§ˆì´ê·¸ë ˆì´ì…˜ ì¤€ë¹„ ìƒíƒœ í‰ê°€"""

    total_requests = comparison_report['total_requests']
    agreement_rate = comparison_report['agreement_rate']
    sw_allow_rate = comparison_report['sw_allow_rate']
    gcra_allow_rate = comparison_report['gcra_allow_rate']

    if total_requests < 10000:
        return "âŒ ë°ì´í„° ë¶€ì¡± - ë” ë§ì€ ìƒ˜í”Œ í•„ìš”"

    if agreement_rate > 0.95:
        if sw_allow_rate < gcra_allow_rate * 0.9:
            return "âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ ê¶Œì¥ - SWê°€ ë” ì—„ê²©í•˜ì—¬ 429 ê°ì†Œ ì˜ˆìƒ"
        elif abs(sw_allow_rate - gcra_allow_rate) < 0.05:
            return "âš–ï¸ ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ëŠ¥ - ìœ ì‚¬í•œ ì„±ëŠ¥"
        else:
            return "ğŸ” ì¶”ê°€ ë¶„ì„ í•„ìš” - SWê°€ ë” ê´€ëŒ€í•¨"
    elif agreement_rate > 0.90:
        return "ğŸ”§ íŠœë‹ í•„ìš” - ì¼ì¹˜ìœ¨ ê°œì„  í›„ ì¬í‰ê°€"
    else:
        return "âŒ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶€ì í•© - ì•Œê³ ë¦¬ì¦˜ ê·¼ë³¸ì  ì°¨ì´"
```

---

## ğŸ“ˆ **í–¥í›„ ë°œì „ ê³„íš**

### Phase A: ê´€ì°° ëª¨ë“œ ì™„ì„± (í˜„ì¬ ê³„íš)
- [x] ë³‘ë ¬ ê´€ì°° ì‹œìŠ¤í…œ êµ¬ì¶•
- [x] ë¹„êµ ë°ì´í„° ìˆ˜ì§‘
- [x] ì•ˆì „ì„± ê²€ì¦

### Phase B: ì ì‘í˜• í•˜ì´ë¸Œë¦¬ë“œ (ì„ íƒì )
- [ ] ë™ì  ì•Œê³ ë¦¬ì¦˜ ì„ íƒ
- [ ] ìƒí™©ë³„ ìµœì  ì•Œê³ ë¦¬ì¦˜ ì ìš©
- [ ] ì‹¤ì‹œê°„ ì„±ëŠ¥ ìµœì í™”

### Phase C: ì™„ì „ ì „í™˜ (ì¡°ê±´ë¶€)
- [ ] ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¡œ ì™„ì „ ì „í™˜
- [ ] ê¸°ì¡´ GCRA ì½”ë“œ ì œê±°
- [ ] ì„±ëŠ¥ ìµœì í™” ë° ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± ê°œì„ 

---

## ğŸ’¡ **ê²°ë¡ **

ì´ ê³„íšì€ **Zero-Risk ì›ì¹™**ì„ ë°”íƒ•ìœ¼ë¡œ ê¸°ì¡´ ì‹œìŠ¤í…œì˜ ì•ˆì •ì„±ì„ ì ˆëŒ€ í•´ì¹˜ì§€ ì•Šìœ¼ë©´ì„œ, ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì•Œê³ ë¦¬ì¦˜ì˜ ì ì¬ì  ì´ì ì„ ì•ˆì „í•˜ê²Œ ê²€ì¦í•  ìˆ˜ ìˆëŠ” ì²´ê³„ì  ì ‘ê·¼ë²•ì…ë‹ˆë‹¤.

### í•µì‹¬ ì´ì 
ğŸ›¡ï¸ **ì™„ì „í•œ ì•ˆì „ì„±** - ê¸°ì¡´ ì‹œìŠ¤í…œì— ì ˆëŒ€ ì˜í–¥ ì—†ìŒ
ğŸ“Š **ë°ì´í„° ê¸°ë°˜ ê²°ì •** - ì¶©ë¶„í•œ ë¹„êµ ë°ì´í„°ë¡œ ê°ê´€ì  íŒë‹¨
ğŸ”§ **ì ì§„ì  ê°œì„ ** - ë‹¨ê³„ë³„ ê²€ì¦ì„ í†µí•œ ë¦¬ìŠ¤í¬ ìµœì†Œí™”
ğŸš€ **ë¯¸ë˜ ì¤€ë¹„** - ë” ì •í™•í•œ Rate Limiting ì‹œìŠ¤í…œ êµ¬ì¶• ê¸°ë°˜

**ë‹¤ìŒ ë‹¨ê³„**: Phase 1 êµ¬í˜„ ì‹œì‘ - ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê´€ì°° ë³€ìˆ˜ ì¶”ê°€ë¶€í„° ì°¨ê·¼ì°¨ê·¼ ì§„í–‰í•˜ê² ìŠµë‹ˆë‹¤!
