# 🔄 현재 시스템 슬라이딩 윈도우 통합 계획서

> **GCRA + 슬라이딩 윈도우 병렬 관찰 모드 구현 계획**
> 기존 시스템 보존하며 새 알고리즘을 안전하게 테스트하는 점진적 통합 전략

---

## 🎯 **프로젝트 목표**

### 핵심 원칙
🛡️ **Zero-Risk Policy** - 기존 동작하는 시스템에 절대 영향 없음
🔍 **관찰 우선** - 슬라이딩 윈도우는 순수 관찰 모드로 시작
📊 **데이터 기반 결정** - 충분한 비교 데이터 수집 후 전환 결정
🚀 **점진적 전환** - 단계별 검증을 통한 안전한 마이그레이션

### 성공 지표
- [ ] 기존 시스템 100% 무결성 유지
- [ ] 슬라이딩 윈도우 정확도 99%+ 검증
- [ ] 두 알고리즘 간 성능 차이 분석 완료
- [ ] 429 에러 발생율 개선 확인

---

## 🏗️ **현재 상황 분석**

### 기존 시스템의 뛰어한 장점들
✅ **Lock-Free GCRA** - aiohttp 패턴 기반 고성능 처리
✅ **동적 조정** - 429 자동 대응, 적응형 전략
✅ **자가치유 태스크 매니저** - 백그라운드 장애 감지/복구
✅ **타임아웃 보장 매니저** - 무한 대기 방지, 메모리 누수 차단
✅ **원자적 TAT 매니저** - Race condition 완벽 해결
✅ **이중 제한 지원** - RPS + RPM 복합 제한 (웹소켓)
✅ **정교한 버스트** - tau 기반 GCRA, 98% 마진 적용
✅ **통합 모니터링** - 상세 통계, 구조화된 로깅
✅ **Zero-429 정책** - 예방적 스로틀링

### 현재 문제점
❌ **429 에러 간헐적 발생** - 7rps + 1버스트 조건에서도 429 발생
❌ **경계 조건 이슈** - Fixed Window의 윈도우 경계 버스트
❌ **부정확한 제한** - 실제 업비트 서버의 슬라이딩 윈도우와 불일치

---

## 🔧 **통합 구현 전략**

### 병렬 관찰 모드 아키텍처
```
기존 GCRA 시스템 (실제 제어)
├── 모든 요청의 실제 허용/거부 결정
├── 기존 로직 100% 보존
└── 프로덕션 안정성 유지

슬라이딩 윈도우 시스템 (관찰 모드)
├── 모든 요청을 병렬로 추적
├── 허용/거부 결정 계산 (적용하지 않음)
├── 상세한 비교 로깅
└── 통계 데이터 수집
```

### 핵심 통합 지점
**`AtomicTATManager._consume_single_token_atomic` 메서드 확장**
```python
async def _consume_single_token_atomic(self, group, config, stats, now, rate_ratio):
    # 🔒 기존 GCRA 로직 (실제 적용) - 완전 보존
    gcra_allowed, gcra_tat = self._execute_gcra_logic(...)

    # 🔍 슬라이딩 윈도우 병렬 관찰 (새로 추가)
    sw_allowed, sw_detail = await self._observe_sliding_window(...)

    # 📊 비교 로깅 및 통계 수집
    await self._log_algorithm_comparison(gcra_allowed, sw_allowed, ...)

    # ✅ 기존 GCRA 결과만 실제 적용
    return gcra_allowed, gcra_tat
```

---

## 📝 **구현 계획 상세**

### Phase 1: 슬라이딩 윈도우 관찰 변수 추가 (1일)

#### 1.1 UnifiedUpbitRateLimiter 클래스 확장
```python
class UnifiedUpbitRateLimiter:
    def __init__(self, ...):
        # 기존 변수들 (전혀 수정하지 않음)
        # ...

        # 🆕 슬라이딩 윈도우 관찰용 변수들 추가
        self.sliding_window_config = {
            'enabled': True,  # 관찰 모드 활성화
            'window_size': 60.0,  # 1분 윈도우
            'max_log_size': 1000,  # 메모리 제한
            'cleanup_interval': 30.0  # 정리 주기
        }

        # 그룹별 요청 로그 저장소
        self.sliding_window_logs: Dict[UpbitRateLimitGroup, List[Tuple[float, int]]] = {
            group: [] for group in UpbitRateLimitGroup
        }

        # 통계 및 비교 데이터
        self.algorithm_comparison_stats = {
            'total_requests': 0,
            'gcra_allowed': 0,
            'sw_allowed': 0,
            'both_allowed': 0,
            'both_denied': 0,
            'gcra_only_allowed': 0,
            'sw_only_allowed': 0,
            'last_cleanup': time.monotonic()
        }
```

#### 1.2 슬라이딩 윈도우 유틸리티 메서드 추가
```python
def _update_sliding_window_log(self, group: UpbitRateLimitGroup, now: float, weight: int = 1):
    """슬라이딩 윈도우 로그에 요청 추가"""

def _cleanup_sliding_window_log(self, group: UpbitRateLimitGroup, now: float):
    """만료된 슬라이딩 윈도우 로그 정리"""

def _calculate_sliding_window_count(self, group: UpbitRateLimitGroup, now: float) -> Tuple[int, int]:
    """현재 슬라이딩 윈도우 내 요청 수 계산"""

def _sliding_window_would_allow(self, group: UpbitRateLimitGroup, now: float, weight: int = 1) -> Tuple[bool, Dict]:
    """슬라이딩 윈도우 기준 허용 여부 확인 (관찰용)"""
```

### Phase 2: AtomicTATManager 확장 (2일)

#### 2.1 병렬 관찰 로직 통합
```python
async def _consume_single_token_atomic(self, group, config, stats, now, current_rate_ratio):
    """GCRA + 슬라이딩 윈도우 병렬 실행"""

    # 🔒 기존 GCRA 로직 (100% 보존)
    current_tat = self.limiter.group_tats.get(group, now)
    base_interval = config.emission_interval
    adjusted_interval = (base_interval / current_rate_ratio) * 1.02  # 98% 마진
    tau = config.burst_capacity * adjusted_interval

    # GCRA 결정 (기존 로직 그대로)
    if current_tat <= now:
        gcra_allowed = True
        new_tat = now + adjusted_interval
        self.limiter.group_tats[group] = new_tat
        burst_remaining = config.burst_capacity
    else:
        debt_time = current_tat - now
        if debt_time <= tau:
            gcra_allowed = True
            new_tat = current_tat + adjusted_interval
            self.limiter.group_tats[group] = new_tat
            burst_remaining = max(0, config.burst_capacity - (debt_time / adjusted_interval))
        else:
            gcra_allowed = False
            new_tat = current_tat
            burst_remaining = 0

    # 🔍 슬라이딩 윈도우 병렬 관찰 (새로 추가)
    if self.limiter.sliding_window_config['enabled']:
        sw_allowed, sw_detail = await self._observe_sliding_window_decision(group, now)

        # 📊 비교 데이터 수집
        await self._collect_comparison_data(group, gcra_allowed, sw_allowed, sw_detail, burst_remaining)

        # 🧹 주기적 로그 정리
        if now - self.limiter.algorithm_comparison_stats['last_cleanup'] > 30.0:
            await self._cleanup_sliding_window_logs(now)

    # ✅ 기존 GCRA 결과만 실제 적용 (변화 없음)
    self.atomic_stats['successful_acquisitions'] += 1 if gcra_allowed else 0
    if not gcra_allowed:
        self.atomic_stats['rejected_acquisitions'] += 1

    return gcra_allowed, new_tat
```

#### 2.2 슬라이딩 윈도우 관찰 메서드
```python
async def _observe_sliding_window_decision(self, group: UpbitRateLimitGroup, now: float) -> Tuple[bool, Dict]:
    """슬라이딩 윈도우 알고리즘으로 결정 시뮬레이션"""

    config = self.limiter.group_configs[group]
    window_size = self.limiter.sliding_window_config['window_size']

    # 1. 로그에 현재 요청 가상 추가
    self.limiter._update_sliding_window_log(group, now, weight=1)

    # 2. 현재 윈도우 내 요청 수 계산
    window_start = now - window_size
    current_logs = self.limiter.sliding_window_logs[group]
    valid_requests = [
        (timestamp, weight) for timestamp, weight in current_logs
        if timestamp >= window_start
    ]

    total_weight = sum(weight for _, weight in valid_requests)

    # 3. 제한 확인 (config.rps * window_size를 최대 요청수로 가정)
    max_requests_in_window = int(config.rps * window_size)
    would_allow = total_weight <= max_requests_in_window

    # 4. 상세 정보 수집
    detail = {
        'window_start': window_start,
        'window_end': now,
        'total_requests': len(valid_requests),
        'total_weight': total_weight,
        'max_requests': max_requests_in_window,
        'utilization_rate': total_weight / max_requests_in_window if max_requests_in_window > 0 else 0,
        'oldest_request': min((t for t, _ in valid_requests), default=None),
        'newest_request': max((t for t, _ in valid_requests), default=None)
    }

    return would_allow, detail
```

### Phase 3: 비교 로깅 및 통계 시스템 (1일)

#### 3.1 상세 비교 로깅
```python
async def _collect_comparison_data(self,
                                 group: UpbitRateLimitGroup,
                                 gcra_allowed: bool,
                                 sw_allowed: bool,
                                 sw_detail: Dict,
                                 burst_remaining: int):
    """두 알고리즘 결과 비교 데이터 수집"""

    stats = self.limiter.algorithm_comparison_stats
    stats['total_requests'] += 1

    if gcra_allowed:
        stats['gcra_allowed'] += 1
    if sw_allowed:
        stats['sw_allowed'] += 1

    # 결정 일치 여부 분석
    if gcra_allowed and sw_allowed:
        stats['both_allowed'] += 1
        result_type = "일치허용"
    elif not gcra_allowed and not sw_allowed:
        stats['both_denied'] += 1
        result_type = "일치거부"
    elif gcra_allowed and not sw_allowed:
        stats['gcra_only_allowed'] += 1
        result_type = "GCRA만허용"
    else:  # not gcra_allowed and sw_allowed
        stats['sw_only_allowed'] += 1
        result_type = "SW만허용"

    # 상세 로깅 (중요한 불일치만)
    if gcra_allowed != sw_allowed:
        self.logger.warning(
            f"🔄 알고리즘 불일치: {group.value} {result_type} "
            f"GCRA({gcra_allowed}:버스트{burst_remaining}) "
            f"SW({sw_allowed}:{sw_detail['total_weight']}/{sw_detail['max_requests']} "
            f"이용률{sw_detail['utilization_rate']:.1%})"
        )
    else:
        # 일치하는 경우는 debug 레벨로
        self.logger.debug(
            f"🔄 알고리즘 일치: {group.value} {result_type} "
            f"SW이용률:{sw_detail['utilization_rate']:.1%} 버스트:{burst_remaining}"
        )

    # 통계 요약 (100회마다)
    if stats['total_requests'] % 100 == 0:
        self._log_comparison_summary(stats)
```

#### 3.2 통계 요약 및 분석
```python
def _log_comparison_summary(self, stats: Dict):
    """비교 통계 요약 로깅"""

    total = stats['total_requests']
    if total == 0:
        return

    agreement_rate = (stats['both_allowed'] + stats['both_denied']) / total * 100
    gcra_allow_rate = stats['gcra_allowed'] / total * 100
    sw_allow_rate = stats['sw_allowed'] / total * 100

    self.logger.info(
        f"📊 알고리즘 비교 통계 (총 {total}회):\n"
        f"  일치율: {agreement_rate:.1f}% "
        f"(허용일치:{stats['both_allowed']} 거부일치:{stats['both_denied']})\n"
        f"  GCRA 허용률: {gcra_allow_rate:.1f}% ({stats['gcra_allowed']}/{total})\n"
        f"  SW 허용률: {sw_allow_rate:.1f}% ({stats['sw_allowed']}/{total})\n"
        f"  불일치: GCRA만허용:{stats['gcra_only_allowed']} SW만허용:{stats['sw_only_allowed']}"
    )

def get_comparison_report(self) -> Dict[str, Any]:
    """상세 비교 보고서 생성"""

    stats = self.limiter.algorithm_comparison_stats
    total = stats['total_requests']

    if total == 0:
        return {'status': 'no_data'}

    return {
        'total_requests': total,
        'agreement_rate': (stats['both_allowed'] + stats['both_denied']) / total,
        'gcra_allow_rate': stats['gcra_allowed'] / total,
        'sw_allow_rate': stats['sw_allowed'] / total,
        'consistency_analysis': {
            'both_allowed': stats['both_allowed'],
            'both_denied': stats['both_denied'],
            'gcra_only_allowed': stats['gcra_only_allowed'],
            'sw_only_allowed': stats['sw_only_allowed']
        },
        'recommendation': self._generate_migration_recommendation(stats)
    }

def _generate_migration_recommendation(self, stats: Dict) -> str:
    """마이그레이션 권장사항 생성"""

    total = stats['total_requests']
    if total < 1000:
        return "insufficient_data"

    agreement_rate = (stats['both_allowed'] + stats['both_denied']) / total
    sw_more_restrictive = stats['gcra_only_allowed'] > stats['sw_only_allowed']

    if agreement_rate > 0.95:
        if sw_more_restrictive:
            return "sw_ready_more_restrictive"  # SW가 더 엄격 - 429 감소 기대
        else:
            return "sw_ready_equivalent"  # 거의 동일
    elif agreement_rate > 0.90:
        return "sw_needs_tuning"  # 튜닝 필요
    else:
        return "sw_not_ready"  # 아직 준비 안됨
```

### Phase 4: 메모리 관리 및 최적화 (1일)

#### 4.1 로그 정리 시스템
```python
async def _cleanup_sliding_window_logs(self, now: float):
    """슬라이딩 윈도우 로그 정리"""

    window_size = self.sliding_window_config['window_size']
    max_log_size = self.sliding_window_config['max_log_size']
    cutoff_time = now - window_size

    total_cleaned = 0

    for group in UpbitRateLimitGroup:
        logs = self.sliding_window_logs[group]

        # 1. 시간 기반 정리
        original_count = len(logs)
        self.sliding_window_logs[group] = [
            (timestamp, weight) for timestamp, weight in logs
            if timestamp >= cutoff_time
        ]

        # 2. 크기 기반 정리 (메모리 제한)
        if len(self.sliding_window_logs[group]) > max_log_size:
            # 최신 요청들만 유지
            self.sliding_window_logs[group] = self.sliding_window_logs[group][-max_log_size:]

        cleaned = original_count - len(self.sliding_window_logs[group])
        total_cleaned += cleaned

    if total_cleaned > 0:
        self.logger.debug(f"🧹 슬라이딩 윈도우 로그 정리: {total_cleaned}개 엔트리 제거")

    # 정리 시간 업데이트
    self.algorithm_comparison_stats['last_cleanup'] = now
```

#### 4.2 메모리 모니터링
```python
def get_sliding_window_memory_usage(self) -> Dict[str, Any]:
    """슬라이딩 윈도우 메모리 사용량 조회"""

    total_entries = sum(len(logs) for logs in self.sliding_window_logs.values())
    estimated_memory_mb = total_entries * 32 / 1024 / 1024  # 대략적 추정

    return {
        'total_log_entries': total_entries,
        'estimated_memory_mb': estimated_memory_mb,
        'groups': {
            group.value: len(logs)
            for group, logs in self.sliding_window_logs.items()
        },
        'config': self.sliding_window_config
    }
```

---

## 📅 **구현 타임라인**

### Week 1: 관찰 모드 구현
- **Day 1**: Phase 1 - 슬라이딩 윈도우 변수 추가
- **Day 2-3**: Phase 2 - AtomicTATManager 확장
- **Day 4**: Phase 3 - 비교 로깅 시스템
- **Day 5**: Phase 4 - 메모리 관리 및 테스트

### Week 2: 검증 및 분석
- **Day 1-3**: 실제 API 환경에서 관찰 데이터 수집
- **Day 4**: 수집된 데이터 분석 및 튜닝
- **Day 5**: 성능 영향 분석 및 최적화

### Week 3: 결정 및 전환 (선택적)
- **Day 1-2**: 마이그레이션 결정 (데이터 기반)
- **Day 3-4**: 점진적 전환 (필요 시)
- **Day 5**: 최종 검증 및 문서화

---

## 🔍 **테스트 계획**

### 관찰 모드 테스트
```python
# 1. 기본 동작 테스트
await limiter.acquire_permission(UpbitRateLimitGroup.REST_PUBLIC, "ticker")

# 2. 버스트 상황 테스트
for i in range(10):
    result = await limiter.acquire_permission(UpbitRateLimitGroup.REST_PUBLIC, f"test_{i}")

# 3. 비교 통계 확인
report = limiter.get_comparison_report()
print(f"일치율: {report['agreement_rate']:.1%}")

# 4. 메모리 사용량 확인
memory_info = limiter.get_sliding_window_memory_usage()
print(f"메모리 사용: {memory_info['estimated_memory_mb']:.1f}MB")
```

### 실제 API 테스트
```python
# rest_api_public_all_endpoint_response.py 수정하여 비교 데이터 수집
async def test_with_comparison_logging():
    for i in range(100):
        await upbit_client.get_ticker("KRW-BTC")

        # 매 10회마다 통계 확인
        if i % 10 == 0:
            report = rate_limiter.get_comparison_report()
            logger.info(f"진행: {i}/100, 일치율: {report['agreement_rate']:.1%}")
```

---

## ⚠️ **리스크 분석 및 대응**

### 식별된 리스크들

#### 🔴 High Risk
**메모리 사용량 증가**
- **리스크**: 슬라이딩 윈도우 로그로 인한 메모리 증가
- **대응**: 최대 로그 크기 제한, 주기적 정리, 메모리 모니터링
- **임계값**: 50MB 초과 시 경고, 100MB 초과 시 자동 비활성화

**성능 저하**
- **리스크**: 추가 계산으로 인한 지연
- **대응**: 비동기 처리, 캐싱, 배치 정리
- **임계값**: 평균 응답시간 10% 증가 시 최적화

#### 🟡 Medium Risk
**로깅 오버헤드**
- **리스크**: 과도한 로깅으로 인한 I/O 부하
- **대응**: 로그 레벨 조정, 배치 로깅, 중요한 이벤트만 로깅
- **모니터링**: 로그 볼륨 및 디스크 사용량 추적

**데이터 분석 복잡성**
- **리스크**: 수집된 데이터 해석의 어려움
- **대응**: 자동 분석 툴, 시각화, 명확한 메트릭 정의

#### 🟢 Low Risk
**기존 시스템 영향**
- **리스크**: 관찰 모드가 기존 로직에 영향
- **대응**: 철저한 격리, 예외 처리, 롤백 메커니즘

### 롤백 전략
```python
# 긴급 비활성화 메커니즘
def emergency_disable_sliding_window():
    """슬라이딩 윈도우 관찰 모드 긴급 비활성화"""

    self.sliding_window_config['enabled'] = False
    self.sliding_window_logs.clear()
    self.algorithm_comparison_stats.clear()

    self.logger.warning("🚨 슬라이딩 윈도우 관찰 모드 긴급 비활성화")

# 자동 롤백 조건
def check_auto_rollback_conditions(self):
    """자동 롤백 조건 확인"""

    memory_usage = self.get_sliding_window_memory_usage()

    # 메모리 임계값 초과
    if memory_usage['estimated_memory_mb'] > 100:
        self.emergency_disable_sliding_window()
        return True

    # 성능 임계값 초과 (평균 응답시간 기준)
    avg_response_time = self.get_average_response_time()
    if avg_response_time > self.baseline_response_time * 1.2:
        self.emergency_disable_sliding_window()
        return True

    return False
```

---

## 📊 **모니터링 대시보드 설계**

### 핵심 메트릭들
```python
def generate_monitoring_dashboard_data(self) -> Dict[str, Any]:
    """모니터링 대시보드용 데이터 생성"""

    comparison_report = self.get_comparison_report()
    memory_info = self.get_sliding_window_memory_usage()

    return {
        'algorithm_comparison': {
            'total_requests': comparison_report.get('total_requests', 0),
            'agreement_rate': comparison_report.get('agreement_rate', 0),
            'gcra_allow_rate': comparison_report.get('gcra_allow_rate', 0),
            'sw_allow_rate': comparison_report.get('sw_allow_rate', 0),
            'recommendation': comparison_report.get('recommendation', 'insufficient_data')
        },
        'performance_metrics': {
            'memory_usage_mb': memory_info['estimated_memory_mb'],
            'total_log_entries': memory_info['total_log_entries'],
            'avg_response_time_ms': self.get_average_response_time_ms(),
            'cleanup_frequency': self.get_cleanup_frequency()
        },
        'group_breakdown': {
            group.value: {
                'log_entries': memory_info['groups'][group.value],
                'recent_requests': self.get_recent_request_count(group),
                'allow_rate_gcra': self.get_group_allow_rate_gcra(group),
                'allow_rate_sw': self.get_group_allow_rate_sw(group)
            }
            for group in UpbitRateLimitGroup
        }
    }
```

### 실시간 모니터링
```bash
# PowerShell 모니터링 스크립트
$pythonScript = @"
import asyncio
from upbit_auto_trading.infrastructure.external_apis.upbit.rate_limiter import UnifiedUpbitRateLimiter

async def monitor_comparison():
    # 실제 rate limiter 인스턴스 가져오기
    limiter = get_current_rate_limiter()

    while True:
        dashboard_data = limiter.generate_monitoring_dashboard_data()

        print(f"⏰ {datetime.now()}")
        print(f"총 요청: {dashboard_data['algorithm_comparison']['total_requests']}")
        print(f"일치율: {dashboard_data['algorithm_comparison']['agreement_rate']:.1%}")
        print(f"메모리: {dashboard_data['performance_metrics']['memory_usage_mb']:.1f}MB")
        print(f"권장사항: {dashboard_data['algorithm_comparison']['recommendation']}")
        print("-" * 50)

        await asyncio.sleep(10)  # 10초마다 업데이트

if __name__ == '__main__':
    asyncio.run(monitor_comparison())
"@

python -c $pythonScript
```

---

## 🎯 **성공 기준 및 KPI**

### 기술적 KPI
- [ ] **기존 시스템 무결성**: 100% 유지 (429 에러율 증가 없음)
- [ ] **메모리 사용량**: 50MB 이하 유지
- [ ] **성능 영향**: 평균 응답시간 5% 이내 증가
- [ ] **데이터 수집량**: 10,000회 이상 요청 비교 데이터

### 비즈니스 KPI
- [ ] **429 에러 감소**: 슬라이딩 윈도우로 전환 시 50% 이상 감소
- [ ] **API 안정성**: 99.9% 성공률 유지
- [ ] **개발 생산성**: Rate limiting 관련 이슈 대응 시간 단축

### 의사결정 기준
```python
def evaluate_migration_readiness(comparison_report: Dict) -> str:
    """마이그레이션 준비 상태 평가"""

    total_requests = comparison_report['total_requests']
    agreement_rate = comparison_report['agreement_rate']
    sw_allow_rate = comparison_report['sw_allow_rate']
    gcra_allow_rate = comparison_report['gcra_allow_rate']

    if total_requests < 10000:
        return "❌ 데이터 부족 - 더 많은 샘플 필요"

    if agreement_rate > 0.95:
        if sw_allow_rate < gcra_allow_rate * 0.9:
            return "✅ 마이그레이션 권장 - SW가 더 엄격하여 429 감소 예상"
        elif abs(sw_allow_rate - gcra_allow_rate) < 0.05:
            return "⚖️ 마이그레이션 가능 - 유사한 성능"
        else:
            return "🔍 추가 분석 필요 - SW가 더 관대함"
    elif agreement_rate > 0.90:
        return "🔧 튜닝 필요 - 일치율 개선 후 재평가"
    else:
        return "❌ 마이그레이션 부적합 - 알고리즘 근본적 차이"
```

---

## 📈 **향후 발전 계획**

### Phase A: 관찰 모드 완성 (현재 계획)
- [x] 병렬 관찰 시스템 구축
- [x] 비교 데이터 수집
- [x] 안전성 검증

### Phase B: 적응형 하이브리드 (선택적)
- [ ] 동적 알고리즘 선택
- [ ] 상황별 최적 알고리즘 적용
- [ ] 실시간 성능 최적화

### Phase C: 완전 전환 (조건부)
- [ ] 슬라이딩 윈도우로 완전 전환
- [ ] 기존 GCRA 코드 제거
- [ ] 성능 최적화 및 메모리 효율성 개선

---

## 💡 **결론**

이 계획은 **Zero-Risk 원칙**을 바탕으로 기존 시스템의 안정성을 절대 해치지 않으면서, 슬라이딩 윈도우 알고리즘의 잠재적 이점을 안전하게 검증할 수 있는 체계적 접근법입니다.

### 핵심 이점
🛡️ **완전한 안전성** - 기존 시스템에 절대 영향 없음
📊 **데이터 기반 결정** - 충분한 비교 데이터로 객관적 판단
🔧 **점진적 개선** - 단계별 검증을 통한 리스크 최소화
🚀 **미래 준비** - 더 정확한 Rate Limiting 시스템 구축 기반

**다음 단계**: Phase 1 구현 시작 - 슬라이딩 윈도우 관찰 변수 추가부터 차근차근 진행하겠습니다!
