## 🧠 상황 이해 및 분석

### 📋 현재 상황 정리

**OverlapAnalyzer의 올바른 동작 확인:**
1. ✅ **데이터 존재 확인**: DB에 `2025-09-12T00:38:00` 레코드 발견
2. ✅ **시작점 검사**: `2025-09-12T00:39:00`에는 데이터 없음 확인
3. ✅ **데이터 시작점 탐색**: 범위 내 데이터 시작점을 `2025-09-12T00:38:00`로 식별
4. ✅ **연속성 분석**: `00:38:00`에서 끝나고 요청 범위 끝(`00:30:00`)까지 연속되지 않음 확인
5. ✅ **파편화 판정**: `PARTIAL_MIDDLE_FRAGMENT` 분류
6. ✅ **API 시작점 반환**: `api_start = 2025-09-12T00:39:00` (DB가 채워야 할 시작점)

**OverlapAnalyzer 자체는 완벽하게 동작했습니다!**

---

### 🚨 핵심 문제: 청크 요청 파라미터의 시간 정렬 이슈

#### **Count-Only 요청의 함정**

**시나리오 1: 안전한 경우**
```
실제 요청 시간: 2025-09-12 00:39:01 (1초 늦음)
→ 정렬된 시간: 2025-09-12 00:39:00 (1분봉 경계로 정렬)
→ 업비트 API: 00:38:00부터 10개 반환 (00:38:00 → 00:29:00)
→ OverlapAnalyzer 분석 범위: 00:39:00 ~ 00:30:00
→ ✅ 정상: API 응답이 분석 범위와 일치
```

**시나리오 2: 위험한 경우** ⚠️
```
실제 요청 시간: 2025-09-12 00:39:00 (정확히 경계 시간)
→ 정렬된 시간: 2025-09-12 00:39:00 (그대로)
→ 업비트 API: 00:38:00부터 10개 반환 (00:38:00 → 00:29:00)
→ OverlapAnalyzer 분석 범위: 00:39:00 ~ 00:30:00
→ ❌ 문제: API 응답(00:38:00 시작)이 분석 범위(00:39:00 시작) 밖!
```

---

### 🔄 다른 요청 파라미터별 시나리오

#### **1. To + Count 요청 (두 번째 청크부터)**

**현재 문제가 있는 로직:**
```
이전 청크 마지막: 2025-09-12 00:40:00
→ 다음 청크 to: 2025-09-12 00:40:00 (그대로 사용)
→ 업비트 API: 00:39:00부터 반환 (00:40:00 제외)
→ ❌ 연속성 파괴: 00:39:00 누락
```

**올바른 로직이어야 할 것:**
```
이전 청크 마지막: 2025-09-12 00:40:00
→ 다음 청크 to: 2025-09-12 00:39:00 (1틱 이전)
→ 업비트 API: 00:38:00부터 반환
→ ✅ 연속성 보장: 00:39:00 포함 없이도 자연스러운 연결
```

#### **2. From + To 범위 요청**

**예상 시나리오:**
```
요청: from=2025-09-12 00:40:00, to=2025-09-12 00:30:00
→ 업비트 API: 00:39:00 → 00:30:00 반환 (from 제외, to 포함)
→ OverlapAnalyzer: 정확한 범위 분석 가능
→ ✅ 가장 안전한 방식
```

#### **3. End 파라미터 요청**

**예상 동작:**
```
요청: count=25, end=2025-09-12 00:25:00
→ 내부 계산: 00:49:00 → 00:25:00 범위
→ 청크별 분할: 각 청크마다 정확한 범위 계산
→ OverlapAnalyzer: 명확한 경계로 정확한 분석
→ ✅ 상대적으로 안전
```

---

### 🎯 교묘한 해결책이 필요한 이유

**근본적 딜레마:**
1. **업비트 서버 시간**: 정확히 알 수 없음 (최대 1초 단위)
2. **시간 정렬 로직**: 요청 시간을 분봉 경계로 정렬
3. **경계 조건**: 정확히 경계 시간에 요청하면 OverlapAnalyzer 범위와 API 응답 불일치
4. **연속성 보장**: 청크 간 데이터 누락 없이 자연스러운 연결 필요

**해결책이 "교묘해야" 하는 이유:**
- 서버 시간을 알 수 없으므로 **예측과 보정**이 필요
- API 특성상 **exclusive/inclusive 경계**를 정확히 다뤄야 함
- OverlapAnalyzer의 **분석 범위와 실제 API 응답**을 일치시켜야 함
- **첫 번째 요청**과 **후속 요청**의 파라미터 생성 로직이 달라야 함

**결론: 시간 경계 처리, 청크 연속성, OverlapAnalyzer 호환성을 모두 만족하는 정교한 알고리즘이 필요합니다.**
