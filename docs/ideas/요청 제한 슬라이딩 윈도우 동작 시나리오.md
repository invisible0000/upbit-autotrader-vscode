# 슬라이딩 윈도우 카운터 로그 처리 시나리오
- 슬라이딩 윈도우는 동적으로 생성되며 여러 서브 시스템에서 공유되면서 관리
- ct : Curent Time
- pw : Previous Window
- cw : Current Window
- wsdt : Window Slot Delay Time
- swsdt : Sliding Window Slot Delay Time (누적)
- rate_limiter_wait : Rate Limiter Wait Time (지연 시간)
- rate_limit : Rate Limit (초당 요청 수)
- rate_limit_count : Rate Limit Count (초당 요청 수 카운트)
- rate_limit_interval : Rate Limit Interval (밀리초)
- window_slot_count : Window Slot Count (윈도우 슬롯 수)
- window_slot_interval : Window Slot Interval (윈도우 슬롯 간격, 밀리초)
- request_id : 요청 ID
- request_queue : 요청 큐
- request_timestamps : 요청 타임스탬프

### 요청 시나리오
- 3 rps 제한을 회피

| time(ms) | 서브1 | 서브2 |
| -------- | ---- | ---- |
| 초기값 | none | none |
| 1000ms | s1_1 | none |
| 1020ms | none | s2_1 |
| 1030ms | s1_2 | none |
| 1040ms | none | s2_2 |
| 1500ms | s1_3 | none |
| 1800ms | none | s2_3 |
| 2200ms | s1_4 | none |
| 2600ms | none | s2_4 |
| 3000ms | s1_5 | none |

### 처리 상황
- 3 rps 제한 회피
- 윈도우 슬롯 3
- 업비트 서버 1초 당 요청수 확인 가정
```
윈도우는 기본적으로 타임 스탬프를 가진다.
보조적으로 요청 id를 가진다.
요청 id는 디버깅 용도이며, 실제로는 타임스탬프만으로 동작한다.

메카니즘(마진이 없은 경우)
요청을 접수
현재 지연중인지 확인
    지연중이면 큐에 요청을 넣고 종료
    지연중이 아니면 다음 단계로 진행
윈도우 확인
 이전 윈도우의 빈 슬롯을 찾는다.
  빈 슬롯이 있으면 큐에서 요청을 처리하고 윈도우 id 슬롯과 윈도우 타임스탬프를 채운다.

  빈 슬롯이 없으면 윈도우 타임스탬프 첫 슬롯에서 현재 시간을 빼고, 2번 슬롯부터는 다음 슬롯 시간에서 이전 슬롯 시간을 빼서 윈도우 시차를 만든다.
  윈도우 시차를 모두 더해서 윈도우 시차 합계를 만든다.
  윈도우 시차 합계가 요청 제한 감시 간격 보다 작으면 지연을 한다.
  지연 시간은 요청 제한 감시 간격에서 윈도우 시차 합계를 뺀 값이다.



지연 연산
 ([현재시간] + [슬롯 0:-2])
```

#### 1. 초기값
```python
rate_limit = 3  # 3 rps
rate_limit_count = 3 # 3rps
rate_limit_interval = 1000 ms
rate_limit_interval_margin_ratio = 0.01  # 지연 처리 시 +1% 마진
```

```python
# 윈도우 빈슬롯이 존재하는지 확인
def has_empty_slot(window):
    return any(slot is None for slot in window)

# 빈 슬롯이 있으면 요청 처리
def process_request_in_window(window, request_id, timestamp):
    for i in range(len(window)):
        if window[i] is None:
            window[i] = request_id
            window_timestamps[i] = timestamp
            return True
    return False

# 윈도우 슬롯 시차 계산
def calculate_window_slot_delay_time(window_timestamps, current_time):
    wsdt = [0] * len(window_timestamps)
    if window_timestamps[0] is not None:
        wsdt[0] = current_time - window_timestamps[0]
    for i in range(1, len(window_timestamps)):
        if window_timestamps[i] is not None and window_timestamps[i-1] is not None:
            wsdt[i] = window_timestamps[i] - window_timestamps[i-1]
    return wsdt

# 윈도우 총지연 계산
def calculate_sum_of_window_slot_delay_time(wsdt):
    return sum(wsdt)

# 지연 연산
def calculate_rate_limiter_wait(sum_of_wsdt, rate_limit_count, rate_limit_interval, window_slot_count):
    if window_slot_count < rate_limit_count:
        return 0
    else:
        return max(0, (sum_of_wsdt / rate_limit_count) - rate_limit_interval * (1 + rate_limit_interval_margin_ratio))

# 요청 처리 메인 함수
def handle_request(request_id, current_time):
    cw_timestamps = [None] * rate_limit_count
    cw = [None] * rate_limit_count
    pw = pw # 윈도우는 기본적으로 timestamps
    if has_empty_slot(cw):
        process_request_in_window(cw, request_id, current_time)
    else:
        wsdt = calculate_window_slot_delay_time(cw_timestamps, current_time)
        sum_of_wsdt = calculate_sum_of_window_slot_delay_time(wsdt)
        window_slot_count = sum(1 for slot in cw if slot is not None)
        wait_time = calculate_rate_limiter_wait(sum_of_wsdt, rate_limit_count, rate_limit_interval, window_slot_count)
        if wait_time > 0:
            time.sleep(wait_time / 1000)  # 밀리초를 초로 변환
            current_time += wait_time
        # 이전 윈도우로 현재 윈도우를 이동
        pw[:] = cw[:]
        cw[:] = [None] * rate_limit_count
        cw_timestamps[:] = [None] * rate_limit_count
        process_request_in_window(cw, request_id, current_time)
```


| time(ms) | 서브1  | 서브2  |
| -------- | ---- | ---- |
| 초기값      | none | none |

- 현재 시간 : ct
- queue : queue = []
- 이전 윈도우 : pw = [,,]
- 현재 윈도우 : cw = [,,]
- 슬롯 편차 :
- 처리 :

#### 2. 1000 ms
| time(ms) | 서브1  | 서브2  |
| -------- | ---- | ---- |
| 1000ms   | s1_1 | none |
- 현재 시간 : ct = 1000 ms
- 요청 id :  s1_1
- 요청 큐 : request_queue = ["s1_1"]
- 요청 타임스탬프 : request_timestamps = [1000]
- 이전 윈도우 : pw = [,,]
- 슬롯 시차 : window_slot_delay_time = [0, , ]
- 윈도우 총지연 : sum_of_window_slot_delay_time = sum(wsdt(1,:)) = 0 ms
- 지연 연산 : window_slot_count = 1 < rate_limit_count = 3 이므로 지연 없음
- 처리 : s1_1 처리
- 현재 윈도우 : cw = [[s1_1, , ], [1000, , ]]
- 로그 : queue = [s1_1], cw = [[s1_1, , ], [1000, , ]], pw = [,,], wsdt = [[s1_1, , ], [0, , ]], swsdt = 0 ms

#### 3. 1020 ms
| time(ms) | 서브1  | 서브2  |
| -------- | ---- | ---- |
| 1020ms   | none | s2_1 |

- 현재 시간 : ct = 1020 ms
- queue: 선처리?
- 이전 윈도우 : pw = [[s1_1, , ], [1000, , ]]
- 현재 윈도우 : cw = [[s1_1, , ], [1000, , ], [s2_1, , ]]
- 슬롯 시차 : wsdt = [[s1_1, , ], [0, , ], [s2_1, , ]]
- 윈도우 총지연 : swsdt = sum(wsdt(1,:)) = 0 ms
- 지연 연산 : window_slot_count = 2 < rate_limit_count = 3 이므로 지연 없음
- 처리 : s2_1 처리


|time(ms) | 서브1 | 서브2 | queue | 이전 윈도우 | 현재 윈도우 | 윈도우 타임 |윈도우 시차 | 윈도우 총시간 | 처리 | 상태 | 지연 |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----|
|초기값 | none | none | none | [, , ] | [, , ] | [, , ] | [, , ] | 0 ms | none | 초기값 | 0 ms |
|1000 ms | s1_1 | none | s1_1 | [, , ] | [s1_1, , ] | [1000, , ] | [0, , ] | 0 ms | s1_1 | 전송 | 0 ms |
|1020 ms | none | s2_1 | s2_1 | [s1_1, , ] | [s2_1, s1_1, ] | [1020, 1000, ] | [0, 20, ] | 20 ms | s2_1 | 전송 | 0 ms |
|1030 ms | s1_2 | none | s1_2 | [s2_2, s1_1, ] | [s1_2, s2_1, s1_1] | [1030, 1020, 1000] |[0, 10, 20] | 30 ms | s1_2 | 전송 | 0 ms |
|1040 ms | none | s2_2 | s2_2 | [s1_2, s2_1, s1_1] | [s1_2, s2_1, s1_1] | [1030, 1020, 1000] | [10, 10, 20] | 40 ms | 큐 | 대기 | 960 ms |
|1500 ms | s1_3 | none | s2_2, s1_3 | [s1_2, s2_1, s1_1] | [s1_2, s2_1, s1_1] | [1030, 1020, 1000] | [470, 10, 20] |  500 ms | 큐 | 대기 | 500 ms |
|1800 ms | none | s2_3 | s2_2, s1_3, s2_3 | [s1_2, s2_1, s1_1] | [s1_2, s2_1, s1_1] | [1030, 1020, 1000] | [770, 10, 20] | 800 ms | 큐 | 대기 | 300 ms |
|2000 ms | none | none | s2_2, s1_3, s2_3 | [s1_2, s2_1, s1_1] | [s1_2, s2_1, s1_1] | [1030, 1020, 1000] | [970, 10, 20] | 1000 ms | 정리 | 해제 | 0 ms |
|2000 ms | none | none | s2_2, s1_3, s2_3 | [s1_2, s2_1, s1_1] | [s2_2, s1_2, s2_1,] | [1040, 1030, 1020] | [960, 10, 10] | 980 ms | s2_2 | 전송 | 0 ms |
|2000 ms | none | none | s1_3, s2_3 | [s2_2, s2_1, s2_1] | [s2_2, s2_1, s2_1] | [1040, 1030, 1020] | [960, 10, 10] | 980 ms | 큐 | 대기 | 20 ms |
|2020 ms | none | none | s1_3, s2_3 | [s2_2, s2_1, s2_1] | [s2_2, s2_1, s2_1] | [1040, 1030, 1020] | [980, 10, 10] | 1000 ms | 정리 | 해제 | 0 ms |
|2020 ms | none | none | s1_3, s2_3 | [s2_2, s2_1, s2_1] | [s1_3, s2_2, s2_1] | [1500, 1040, 1030] | [520, 10, 10] | 540 ms | 큐 | 대기 | 460 ms |
|2480 ms | none | none | s1_3, s2_3 | [s2_2, s2_1, s2_1] | [s1_3, s2_2, s2_1] | [1500, 1040, 1030] | [980, 10, 10] | 1000 ms | 정리 | 해제 | 0 ms |
|2480 ms | none | none | s1_3, s2_3 | [s2_2, s2_1, s2_1] | [s1_3, s2_2, s2_1] | [1500, 1040, 1030] | [980, 10, 10] | 1000 ms | 정리 | 해제 | 0 ms |
