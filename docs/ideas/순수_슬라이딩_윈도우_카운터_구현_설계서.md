# 🎯 순수 슬라이딩 윈도우 카운터 구현 설계서

> **업비트 Rate Limiter v3.0: 슬라이딩 윈도우 로그 중심 설계**
> 기존 GCRA 시스템의 장점을 슬라이딩 윈도우에 통합한 완전 새로운 구현

---

## 📋 **설계 개요**

### 핵심 철학
- **정밀도 우선**: 슬라이딩 윈도우 로그의 완벽한 정확성 활용
- **현재 시스템 장점 계승**: 자가치유, 원자적 처리, 타임아웃 관리 등
- **메모리 효율성**: 로그 크기 제한 및 효율적 정리
- **Zero-429 정책**: 예방적 스로틀링으로 완벽한 429 방지

### 기존 GCRA 대비 장점
✅ **경계 조건 문제 해결** - 윈도우 경계에서의 버스트 없음
✅ **완벽한 정확성** - 모든 요청을 타임스탬프로 추적
✅ **유연한 윈도우 크기** - 임의의 시간 단위 지원
✅ **실시간 모니터링** - 정확한 현재 사용률 계산

---

## 🏗️ **파일 구조 설계**

### 디렉터리 구조
```
upbit_auto_trading/infrastructure/external_apis/upbit/rate_limiter/
├── sliding_window_limiter.py          # 🎯 메인 제한기
├── sliding_window_types.py            # 📝 타입 정의
├── sliding_window_managers.py         # 🛠️ 보조 매니저들
├── sliding_window_monitoring.py       # 📊 모니터링 및 통계
├── sliding_window_timing.py           # ⏰ 타이밍 유틸리티
└── __init__.py                        # 📦 패키지 초기화
```

### 핵심 설계 원칙
- **단일 책임**: 각 파일은 명확한 단일 역할
- **기존 컨벤션 준수**: 현재 프로젝트 스타일 유지
- **호환성 무시**: 기존 GCRA 시스템과 완전 분리
- **현대적 구조**: Python 3.8+ 타입 힌트 완전 활용

---

## 📊 **핵심 데이터 구조**

### 주요 변수들

```python
# sliding_window_types.py
@dataclass(frozen=True)
class RequestEntry:
    """개별 요청 엔트리"""
    timestamp: float
    weight: int = 1
    endpoint: str = ""
    request_id: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class SlidingWindowConfig:
    """슬라이딩 윈도우 설정"""
    max_requests: int
    window_size_seconds: float
    max_log_size: int = 10000
    cleanup_interval: float = 5.0
    memory_threshold_mb: float = 50.0

@dataclass
class WindowStats:
    """윈도우 통계"""
    current_count: int = 0
    peak_count: int = 0
    oldest_entry: Optional[float] = None
    newest_entry: Optional[float] = None
    memory_usage_mb: float = 0.0
    cleanup_count: int = 0
```

### 로그 저장 구조
```python
# 그룹별 요청 로그 (메인 데이터)
request_logs: Dict[UpbitRateLimitGroup, List[RequestEntry]]

# 빠른 검색을 위한 인덱스
timestamp_index: Dict[UpbitRateLimitGroup, Dict[float, List[int]]]  # timestamp -> log indices

# 메모리 효율성을 위한 순환 버퍼 (선택적)
circular_buffers: Dict[UpbitRateLimitGroup, collections.deque[RequestEntry]]
```

---

## 🔧 **핵심 클래스 설계**

### 1. SlidingWindowLimiter (메인)
```python
class SlidingWindowLimiter:
    """슬라이딩 윈도우 기반 Rate Limiter"""

    def __init__(self, group_configs: Dict[UpbitRateLimitGroup, SlidingWindowConfig]):
        # 그룹별 설정 및 상태
        self.group_configs = group_configs
        self.request_logs: Dict[UpbitRateLimitGroup, List[RequestEntry]] = {}
        self.window_stats: Dict[UpbitRateLimitGroup, WindowStats] = {}

        # 고급 매니저들 (기존 장점 계승)
        self.memory_manager = MemoryEfficientLogManager(self)
        self.atomic_manager = AtomicWindowManager(self)
        self.timeout_manager = TimeoutAwareWindowLimiter(self)
        self.monitoring_manager = WindowMonitoringManager(self)

    async def acquire_permission(self,
                               group: UpbitRateLimitGroup,
                               endpoint: str = "",
                               weight: int = 1,
                               timeout: float = 30.0) -> bool:
        """권한 획득 - 메인 진입점"""

    async def check_permission_without_consume(self,
                                             group: UpbitRateLimitGroup,
                                             weight: int = 1) -> Tuple[bool, float]:
        """소모하지 않고 권한만 확인"""

    def get_current_usage(self, group: UpbitRateLimitGroup) -> WindowUsageInfo:
        """현재 윈도우 사용률 조회"""

    def get_detailed_stats(self) -> Dict[str, Any]:
        """상세 통계 조회"""
```

### 2. MemoryEfficientLogManager (managers.py)
```python
class MemoryEfficientLogManager:
    """메모리 효율적인 로그 관리자"""

    async def add_request(self, group: UpbitRateLimitGroup, entry: RequestEntry):
        """요청 로그 추가"""

    async def cleanup_expired_logs(self, group: UpbitRateLimitGroup, now: float):
        """만료된 로그 정리"""

    def calculate_window_count(self, group: UpbitRateLimitGroup, now: float) -> int:
        """현재 윈도우 내 요청 수 계산"""

    def estimate_memory_usage(self, group: UpbitRateLimitGroup) -> float:
        """메모리 사용량 추정"""

    async def optimize_storage(self, group: UpbitRateLimitGroup):
        """스토리지 최적화 (압축, 인덱스 재구성 등)"""
```

### 3. AtomicWindowManager (managers.py)
```python
class AtomicWindowManager:
    """원자적 윈도우 관리자"""

    def __init__(self, limiter_instance):
        self._window_locks: Dict[UpbitRateLimitGroup, asyncio.Lock] = {}

    async def atomic_check_and_add(self,
                                   group: UpbitRateLimitGroup,
                                   entry: RequestEntry) -> Tuple[bool, WindowCheckResult]:
        """원자적 체크 및 추가"""

    async def atomic_count_calculation(self,
                                     group: UpbitRateLimitGroup,
                                     now: float) -> WindowCountInfo:
        """원자적 카운트 계산"""
```

### 4. WindowMonitoringManager (monitoring.py)
```python
class WindowMonitoringManager:
    """윈도우 모니터링 관리자"""

    def __init__(self, limiter_instance):
        self.peak_usage_tracker = PeakUsageTracker()
        self.trend_analyzer = UsageTrendAnalyzer()

    def track_request(self, group: UpbitRateLimitGroup, entry: RequestEntry, allowed: bool):
        """요청 추적"""

    def analyze_usage_pattern(self, group: UpbitRateLimitGroup) -> UsagePattern:
        """사용 패턴 분석"""

    def predict_next_window_usage(self, group: UpbitRateLimitGroup) -> float:
        """다음 윈도우 사용률 예측"""

    def generate_monitoring_report(self) -> Dict[str, Any]:
        """모니터링 보고서 생성"""
```

---

## 🎯 **핵심 알고리즘**

### 슬라이딩 윈도우 권한 확인 로직
```python
async def _check_sliding_window_permission(self,
                                         group: UpbitRateLimitGroup,
                                         now: float,
                                         weight: int = 1) -> Tuple[bool, WindowCheckDetail]:
    """슬라이딩 윈도우 권한 확인"""

    async with self.atomic_manager.get_lock(group):
        config = self.group_configs[group]
        window_start = now - config.window_size_seconds

        # 1. 현재 윈도우 내 요청 필터링
        current_requests = [
            entry for entry in self.request_logs[group]
            if entry.timestamp >= window_start
        ]

        # 2. 가중치 합계 계산
        current_weight_sum = sum(req.weight for req in current_requests)

        # 3. 권한 확인
        would_exceed = (current_weight_sum + weight) > config.max_requests

        # 4. 상세 정보 구성
        detail = WindowCheckDetail(
            current_count=len(current_requests),
            current_weight=current_weight_sum,
            would_exceed=would_exceed,
            window_start=window_start,
            window_end=now,
            oldest_request=min((r.timestamp for r in current_requests), default=None),
            newest_request=max((r.timestamp for r in current_requests), default=None)
        )

        return not would_exceed, detail
```

### 메모리 효율적 로그 정리
```python
async def _cleanup_expired_entries(self, group: UpbitRateLimitGroup, now: float):
    """만료된 엔트리 효율적 정리"""

    config = self.group_configs[group]
    cutoff_time = now - config.window_size_seconds

    # 1. 이진 탐색으로 정리 시작점 찾기
    logs = self.request_logs[group]
    start_idx = bisect.bisect_left([r.timestamp for r in logs], cutoff_time)

    # 2. 배치 정리 (메모리 효율성)
    if start_idx > 0:
        removed_count = start_idx
        self.request_logs[group] = logs[start_idx:]

        # 3. 통계 업데이트
        self.window_stats[group].cleanup_count += removed_count

        # 4. 메모리 사용량 재계산
        self._update_memory_usage(group)

        self.logger.debug(f"🧹 로그 정리: {group.value} {removed_count}개 제거")
```

### 예측적 스로틀링 (Zero-429 정책)
```python
def _calculate_predictive_delay(self, group: UpbitRateLimitGroup, detail: WindowCheckDetail) -> float:
    """예측적 지연 계산"""

    config = self.group_configs[group]

    if not detail.would_exceed:
        return 0.0

    # 1. 가장 오래된 요청이 윈도우에서 나가는 시간 계산
    if detail.oldest_request:
        time_until_oldest_expires = (
            detail.oldest_request + config.window_size_seconds - detail.window_end
        )
        return max(0.01, time_until_oldest_expires)

    # 2. 균등 분산 지연 (최악 경우)
    return config.window_size_seconds / config.max_requests
```

---

## 📈 **고급 기능 통합**

### 1. 자가치유 백그라운드 태스크
- **로그 정리 태스크**: 주기적 만료 엔트리 제거
- **메모리 최적화 태스크**: 압축 및 인덱스 재구성
- **통계 집계 태스크**: 성능 메트릭 계산
- **장애 복구**: 태스크 실패 시 자동 재시작

### 2. 타임아웃 보장 시스템
- **대기자 관리**: 권한 대기 중인 요청들 추적
- **타임아웃 처리**: 설정된 시간 후 자동 실패
- **리소스 정리**: 타임아웃된 대기자 확실한 제거

### 3. 원자적 연산 보장
- **Lock 기반 동시성 제어**: 그룹별 개별 락
- **Race Condition 방지**: 읽기-쓰기 원자성
- **일관성 보장**: 멀티스레드 환경 안전성

### 4. 실시간 모니터링
- **사용률 추적**: 실시간 윈도우 사용률
- **패턴 분석**: 요청 패턴 및 트렌드 감지
- **예측 알고리즘**: 향후 사용률 예측
- **알림 시스템**: 임계값 도달 시 경고

---

## 🔍 **성능 최적화**

### 메모리 최적화
```python
# 1. 순환 버퍼 사용 (메모리 제한)
self.circular_logs: Dict[UpbitRateLimitGroup, collections.deque[RequestEntry]]

# 2. 압축된 엔트리 (메모리 절약)
@dataclass
class CompressedRequestEntry:
    timestamp_offset: int  # 32bit offset from base_time
    weight: int = 1

# 3. 배치 정리 (CPU 효율성)
async def _batch_cleanup(self, batch_size: int = 1000):
    """배치 단위 로그 정리"""
```

### 검색 최적화
```python
# 1. 타임스탬프 인덱스
timestamp_index: Dict[UpbitRateLimitGroup, Dict[int, List[int]]]  # second -> log indices

# 2. 이진 탐색 활용
def _find_window_start_index(self, logs: List[RequestEntry], cutoff_time: float) -> int:
    return bisect.bisect_left([r.timestamp for r in logs], cutoff_time)

# 3. 캐시된 카운트 (짧은 시간 내 재계산 방지)
@dataclass
class CachedWindowCount:
    timestamp: float
    count: int
    weight_sum: int
    valid_until: float
```

---

## 🎯 **사용 예제**

### 기본 사용법
```python
# 1. 설정
configs = {
    UpbitRateLimitGroup.REST_PUBLIC: SlidingWindowConfig(
        max_requests=100,
        window_size_seconds=60.0,
        max_log_size=5000
    )
}

# 2. 초기화
limiter = SlidingWindowLimiter(configs)
await limiter.start()

# 3. 권한 획득
if await limiter.acquire_permission(UpbitRateLimitGroup.REST_PUBLIC, "ticker"):
    # API 호출 수행
    response = await api_call()
else:
    # Rate limit 도달
    logger.warning("Rate limit reached")

# 4. 현재 상태 확인
usage = limiter.get_current_usage(UpbitRateLimitGroup.REST_PUBLIC)
print(f"현재 사용률: {usage.current_count}/{usage.max_requests}")
```

### 고급 사용법
```python
# 1. 가중치 기반 제한
await limiter.acquire_permission(
    UpbitRateLimitGroup.REST_PRIVATE_ORDER,
    "order",
    weight=5  # 주문은 5배 가중치
)

# 2. 예측적 확인
allowed, delay = await limiter.check_permission_without_consume(
    UpbitRateLimitGroup.REST_PUBLIC
)
if not allowed:
    await asyncio.sleep(delay)

# 3. 상세 모니터링
stats = limiter.get_detailed_stats()
for group, data in stats.items():
    print(f"{group}: {data['current_usage']}/{data['max_requests']}")
    print(f"메모리 사용: {data['memory_mb']:.1f}MB")
    print(f"예측 대기시간: {data['predicted_delay']:.3f}초")
```

---

## ⚖️ **장단점 분석**

### 장점
✅ **완벽한 정확성** - 모든 요청을 정확히 추적
✅ **경계 문제 해결** - 윈도우 경계에서의 버스트 없음
✅ **유연성** - 임의의 윈도우 크기 지원
✅ **실시간 모니터링** - 정확한 현재 상태 파악
✅ **예측 기능** - 향후 사용률 예측 가능
✅ **기존 고급 기능 계승** - 자가치유, 원자성, 타임아웃 등

### 단점 및 대응방안
❌ **메모리 사용량 증가** → 순환 버퍼, 압축, 배치 정리로 해결
❌ **계산 복잡도 증가** → 인덱스, 캐싱, 이진 탐색으로 최적화
❌ **초기 구현 복잡성** → 단계적 마이그레이션, 철저한 테스트

---

## 🚀 **마이그레이션 전략**

### Phase 1: 기반 구조 구축 (1-2주)
- [ ] 기본 슬라이딩 윈도우 로직 구현
- [ ] 메모리 효율적 로그 관리
- [ ] 기본 테스트 케이스 작성

### Phase 2: 고급 기능 통합 (2-3주)
- [ ] 자가치유 시스템 포팅
- [ ] 원자적 관리 시스템 구현
- [ ] 타임아웃 보장 시스템 통합

### Phase 3: 최적화 및 모니터링 (1-2주)
- [ ] 성능 최적화 (인덱스, 캐싱)
- [ ] 실시간 모니터링 시스템
- [ ] 상세 통계 및 알림

### Phase 4: 프로덕션 배포 (1주)
- [ ] 부하 테스트
- [ ] 기존 시스템 교체
- [ ] 모니터링 및 튜닝

---

## 📊 **예상 성능 지표**

### 메모리 사용량
- **기본**: ~10MB (10,000 요청 로그 기준)
- **최적화**: ~5MB (압축 및 순환 버퍼 사용)
- **대규모**: ~50MB (100,000 요청 로그 기준)

### 처리 성능
- **권한 확인**: <1ms (인덱스 사용)
- **로그 추가**: <0.1ms (append 연산)
- **정리 작업**: <10ms (배치 처리)

### 정확도
- **429 방지율**: 99.9% (예측적 스로틀링)
- **윈도우 정확도**: 100% (완전한 로그 추적)
- **동시성 안전성**: 100% (Lock 기반 원자성)

---

**💡 결론**: 이 설계는 슬라이딩 윈도우의 완벽한 정확성과 현재 시스템의 고급 기능들을 결합하여, 업비트 API의 까다로운 Rate Limit 요구사항을 완벽하게 만족하는 차세대 Rate Limiter를 제공합니다.
