# ğŸ¯ ìˆœìˆ˜ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì¹´ìš´í„° êµ¬í˜„ ì„¤ê³„ì„œ

> **ì—…ë¹„íŠ¸ Rate Limiter v3.0: ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ ì¤‘ì‹¬ ì„¤ê³„**
> ê¸°ì¡´ GCRA ì‹œìŠ¤í…œì˜ ì¥ì ì„ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì— í†µí•©í•œ ì™„ì „ ìƒˆë¡œìš´ êµ¬í˜„

---

## ğŸ“‹ **ì„¤ê³„ ê°œìš”**

### í•µì‹¬ ì² í•™
- **ì •ë°€ë„ ìš°ì„ **: ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œê·¸ì˜ ì™„ë²½í•œ ì •í™•ì„± í™œìš©
- **í˜„ì¬ ì‹œìŠ¤í…œ ì¥ì  ê³„ìŠ¹**: ìê°€ì¹˜ìœ , ì›ìì  ì²˜ë¦¬, íƒ€ì„ì•„ì›ƒ ê´€ë¦¬ ë“±
- **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ë¡œê·¸ í¬ê¸° ì œí•œ ë° íš¨ìœ¨ì  ì •ë¦¬
- **Zero-429 ì •ì±…**: ì˜ˆë°©ì  ìŠ¤ë¡œí‹€ë§ìœ¼ë¡œ ì™„ë²½í•œ 429 ë°©ì§€

### ê¸°ì¡´ GCRA ëŒ€ë¹„ ì¥ì 
âœ… **ê²½ê³„ ì¡°ê±´ ë¬¸ì œ í•´ê²°** - ìœˆë„ìš° ê²½ê³„ì—ì„œì˜ ë²„ìŠ¤íŠ¸ ì—†ìŒ
âœ… **ì™„ë²½í•œ ì •í™•ì„±** - ëª¨ë“  ìš”ì²­ì„ íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ ì¶”ì 
âœ… **ìœ ì—°í•œ ìœˆë„ìš° í¬ê¸°** - ì„ì˜ì˜ ì‹œê°„ ë‹¨ìœ„ ì§€ì›
âœ… **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§** - ì •í™•í•œ í˜„ì¬ ì‚¬ìš©ë¥  ê³„ì‚°

---

## ğŸ—ï¸ **íŒŒì¼ êµ¬ì¡° ì„¤ê³„**

### ë””ë ‰í„°ë¦¬ êµ¬ì¡°
```
upbit_auto_trading/infrastructure/external_apis/upbit/rate_limiter/
â”œâ”€â”€ sliding_window_limiter.py          # ğŸ¯ ë©”ì¸ ì œí•œê¸°
â”œâ”€â”€ sliding_window_types.py            # ğŸ“ íƒ€ì… ì •ì˜
â”œâ”€â”€ sliding_window_managers.py         # ğŸ› ï¸ ë³´ì¡° ë§¤ë‹ˆì €ë“¤
â”œâ”€â”€ sliding_window_monitoring.py       # ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° í†µê³„
â”œâ”€â”€ sliding_window_timing.py           # â° íƒ€ì´ë° ìœ í‹¸ë¦¬í‹°
â””â”€â”€ __init__.py                        # ğŸ“¦ íŒ¨í‚¤ì§€ ì´ˆê¸°í™”
```

### í•µì‹¬ ì„¤ê³„ ì›ì¹™
- **ë‹¨ì¼ ì±…ì„**: ê° íŒŒì¼ì€ ëª…í™•í•œ ë‹¨ì¼ ì—­í• 
- **ê¸°ì¡´ ì»¨ë²¤ì…˜ ì¤€ìˆ˜**: í˜„ì¬ í”„ë¡œì íŠ¸ ìŠ¤íƒ€ì¼ ìœ ì§€
- **í˜¸í™˜ì„± ë¬´ì‹œ**: ê¸°ì¡´ GCRA ì‹œìŠ¤í…œê³¼ ì™„ì „ ë¶„ë¦¬
- **í˜„ëŒ€ì  êµ¬ì¡°**: Python 3.8+ íƒ€ì… íŒíŠ¸ ì™„ì „ í™œìš©

---

## ğŸ“Š **í•µì‹¬ ë°ì´í„° êµ¬ì¡°**

### ì£¼ìš” ë³€ìˆ˜ë“¤

```python
# sliding_window_types.py
@dataclass(frozen=True)
class RequestEntry:
    """ê°œë³„ ìš”ì²­ ì—”íŠ¸ë¦¬"""
    timestamp: float
    weight: int = 1
    endpoint: str = ""
    request_id: str = field(default_factory=lambda: str(uuid.uuid4()))

@dataclass
class SlidingWindowConfig:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ì„¤ì •"""
    max_requests: int
    window_size_seconds: float
    max_log_size: int = 10000
    cleanup_interval: float = 5.0
    memory_threshold_mb: float = 50.0

@dataclass
class WindowStats:
    """ìœˆë„ìš° í†µê³„"""
    current_count: int = 0
    peak_count: int = 0
    oldest_entry: Optional[float] = None
    newest_entry: Optional[float] = None
    memory_usage_mb: float = 0.0
    cleanup_count: int = 0
```

### ë¡œê·¸ ì €ì¥ êµ¬ì¡°
```python
# ê·¸ë£¹ë³„ ìš”ì²­ ë¡œê·¸ (ë©”ì¸ ë°ì´í„°)
request_logs: Dict[UpbitRateLimitGroup, List[RequestEntry]]

# ë¹ ë¥¸ ê²€ìƒ‰ì„ ìœ„í•œ ì¸ë±ìŠ¤
timestamp_index: Dict[UpbitRateLimitGroup, Dict[float, List[int]]]  # timestamp -> log indices

# ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì„ ìœ„í•œ ìˆœí™˜ ë²„í¼ (ì„ íƒì )
circular_buffers: Dict[UpbitRateLimitGroup, collections.deque[RequestEntry]]
```

---

## ğŸ”§ **í•µì‹¬ í´ë˜ìŠ¤ ì„¤ê³„**

### 1. SlidingWindowLimiter (ë©”ì¸)
```python
class SlidingWindowLimiter:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê¸°ë°˜ Rate Limiter"""

    def __init__(self, group_configs: Dict[UpbitRateLimitGroup, SlidingWindowConfig]):
        # ê·¸ë£¹ë³„ ì„¤ì • ë° ìƒíƒœ
        self.group_configs = group_configs
        self.request_logs: Dict[UpbitRateLimitGroup, List[RequestEntry]] = {}
        self.window_stats: Dict[UpbitRateLimitGroup, WindowStats] = {}

        # ê³ ê¸‰ ë§¤ë‹ˆì €ë“¤ (ê¸°ì¡´ ì¥ì  ê³„ìŠ¹)
        self.memory_manager = MemoryEfficientLogManager(self)
        self.atomic_manager = AtomicWindowManager(self)
        self.timeout_manager = TimeoutAwareWindowLimiter(self)
        self.monitoring_manager = WindowMonitoringManager(self)

    async def acquire_permission(self,
                               group: UpbitRateLimitGroup,
                               endpoint: str = "",
                               weight: int = 1,
                               timeout: float = 30.0) -> bool:
        """ê¶Œí•œ íšë“ - ë©”ì¸ ì§„ì…ì """

    async def check_permission_without_consume(self,
                                             group: UpbitRateLimitGroup,
                                             weight: int = 1) -> Tuple[bool, float]:
        """ì†Œëª¨í•˜ì§€ ì•Šê³  ê¶Œí•œë§Œ í™•ì¸"""

    def get_current_usage(self, group: UpbitRateLimitGroup) -> WindowUsageInfo:
        """í˜„ì¬ ìœˆë„ìš° ì‚¬ìš©ë¥  ì¡°íšŒ"""

    def get_detailed_stats(self) -> Dict[str, Any]:
        """ìƒì„¸ í†µê³„ ì¡°íšŒ"""
```

### 2. MemoryEfficientLogManager (managers.py)
```python
class MemoryEfficientLogManager:
    """ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë¡œê·¸ ê´€ë¦¬ì"""

    async def add_request(self, group: UpbitRateLimitGroup, entry: RequestEntry):
        """ìš”ì²­ ë¡œê·¸ ì¶”ê°€"""

    async def cleanup_expired_logs(self, group: UpbitRateLimitGroup, now: float):
        """ë§Œë£Œëœ ë¡œê·¸ ì •ë¦¬"""

    def calculate_window_count(self, group: UpbitRateLimitGroup, now: float) -> int:
        """í˜„ì¬ ìœˆë„ìš° ë‚´ ìš”ì²­ ìˆ˜ ê³„ì‚°"""

    def estimate_memory_usage(self, group: UpbitRateLimitGroup) -> float:
        """ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¶”ì •"""

    async def optimize_storage(self, group: UpbitRateLimitGroup):
        """ìŠ¤í† ë¦¬ì§€ ìµœì í™” (ì••ì¶•, ì¸ë±ìŠ¤ ì¬êµ¬ì„± ë“±)"""
```

### 3. AtomicWindowManager (managers.py)
```python
class AtomicWindowManager:
    """ì›ìì  ìœˆë„ìš° ê´€ë¦¬ì"""

    def __init__(self, limiter_instance):
        self._window_locks: Dict[UpbitRateLimitGroup, asyncio.Lock] = {}

    async def atomic_check_and_add(self,
                                   group: UpbitRateLimitGroup,
                                   entry: RequestEntry) -> Tuple[bool, WindowCheckResult]:
        """ì›ìì  ì²´í¬ ë° ì¶”ê°€"""

    async def atomic_count_calculation(self,
                                     group: UpbitRateLimitGroup,
                                     now: float) -> WindowCountInfo:
        """ì›ìì  ì¹´ìš´íŠ¸ ê³„ì‚°"""
```

### 4. WindowMonitoringManager (monitoring.py)
```python
class WindowMonitoringManager:
    """ìœˆë„ìš° ëª¨ë‹ˆí„°ë§ ê´€ë¦¬ì"""

    def __init__(self, limiter_instance):
        self.peak_usage_tracker = PeakUsageTracker()
        self.trend_analyzer = UsageTrendAnalyzer()

    def track_request(self, group: UpbitRateLimitGroup, entry: RequestEntry, allowed: bool):
        """ìš”ì²­ ì¶”ì """

    def analyze_usage_pattern(self, group: UpbitRateLimitGroup) -> UsagePattern:
        """ì‚¬ìš© íŒ¨í„´ ë¶„ì„"""

    def predict_next_window_usage(self, group: UpbitRateLimitGroup) -> float:
        """ë‹¤ìŒ ìœˆë„ìš° ì‚¬ìš©ë¥  ì˜ˆì¸¡"""

    def generate_monitoring_report(self) -> Dict[str, Any]:
        """ëª¨ë‹ˆí„°ë§ ë³´ê³ ì„œ ìƒì„±"""
```

---

## ğŸ¯ **í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**

### ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê¶Œí•œ í™•ì¸ ë¡œì§
```python
async def _check_sliding_window_permission(self,
                                         group: UpbitRateLimitGroup,
                                         now: float,
                                         weight: int = 1) -> Tuple[bool, WindowCheckDetail]:
    """ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê¶Œí•œ í™•ì¸"""

    async with self.atomic_manager.get_lock(group):
        config = self.group_configs[group]
        window_start = now - config.window_size_seconds

        # 1. í˜„ì¬ ìœˆë„ìš° ë‚´ ìš”ì²­ í•„í„°ë§
        current_requests = [
            entry for entry in self.request_logs[group]
            if entry.timestamp >= window_start
        ]

        # 2. ê°€ì¤‘ì¹˜ í•©ê³„ ê³„ì‚°
        current_weight_sum = sum(req.weight for req in current_requests)

        # 3. ê¶Œí•œ í™•ì¸
        would_exceed = (current_weight_sum + weight) > config.max_requests

        # 4. ìƒì„¸ ì •ë³´ êµ¬ì„±
        detail = WindowCheckDetail(
            current_count=len(current_requests),
            current_weight=current_weight_sum,
            would_exceed=would_exceed,
            window_start=window_start,
            window_end=now,
            oldest_request=min((r.timestamp for r in current_requests), default=None),
            newest_request=max((r.timestamp for r in current_requests), default=None)
        )

        return not would_exceed, detail
```

### ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ë¡œê·¸ ì •ë¦¬
```python
async def _cleanup_expired_entries(self, group: UpbitRateLimitGroup, now: float):
    """ë§Œë£Œëœ ì—”íŠ¸ë¦¬ íš¨ìœ¨ì  ì •ë¦¬"""

    config = self.group_configs[group]
    cutoff_time = now - config.window_size_seconds

    # 1. ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ì •ë¦¬ ì‹œì‘ì  ì°¾ê¸°
    logs = self.request_logs[group]
    start_idx = bisect.bisect_left([r.timestamp for r in logs], cutoff_time)

    # 2. ë°°ì¹˜ ì •ë¦¬ (ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±)
    if start_idx > 0:
        removed_count = start_idx
        self.request_logs[group] = logs[start_idx:]

        # 3. í†µê³„ ì—…ë°ì´íŠ¸
        self.window_stats[group].cleanup_count += removed_count

        # 4. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¬ê³„ì‚°
        self._update_memory_usage(group)

        self.logger.debug(f"ğŸ§¹ ë¡œê·¸ ì •ë¦¬: {group.value} {removed_count}ê°œ ì œê±°")
```

### ì˜ˆì¸¡ì  ìŠ¤ë¡œí‹€ë§ (Zero-429 ì •ì±…)
```python
def _calculate_predictive_delay(self, group: UpbitRateLimitGroup, detail: WindowCheckDetail) -> float:
    """ì˜ˆì¸¡ì  ì§€ì—° ê³„ì‚°"""

    config = self.group_configs[group]

    if not detail.would_exceed:
        return 0.0

    # 1. ê°€ì¥ ì˜¤ë˜ëœ ìš”ì²­ì´ ìœˆë„ìš°ì—ì„œ ë‚˜ê°€ëŠ” ì‹œê°„ ê³„ì‚°
    if detail.oldest_request:
        time_until_oldest_expires = (
            detail.oldest_request + config.window_size_seconds - detail.window_end
        )
        return max(0.01, time_until_oldest_expires)

    # 2. ê· ë“± ë¶„ì‚° ì§€ì—° (ìµœì•… ê²½ìš°)
    return config.window_size_seconds / config.max_requests
```

---

## ğŸ“ˆ **ê³ ê¸‰ ê¸°ëŠ¥ í†µí•©**

### 1. ìê°€ì¹˜ìœ  ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬
- **ë¡œê·¸ ì •ë¦¬ íƒœìŠ¤í¬**: ì£¼ê¸°ì  ë§Œë£Œ ì—”íŠ¸ë¦¬ ì œê±°
- **ë©”ëª¨ë¦¬ ìµœì í™” íƒœìŠ¤í¬**: ì••ì¶• ë° ì¸ë±ìŠ¤ ì¬êµ¬ì„±
- **í†µê³„ ì§‘ê³„ íƒœìŠ¤í¬**: ì„±ëŠ¥ ë©”íŠ¸ë¦­ ê³„ì‚°
- **ì¥ì•  ë³µêµ¬**: íƒœìŠ¤í¬ ì‹¤íŒ¨ ì‹œ ìë™ ì¬ì‹œì‘

### 2. íƒ€ì„ì•„ì›ƒ ë³´ì¥ ì‹œìŠ¤í…œ
- **ëŒ€ê¸°ì ê´€ë¦¬**: ê¶Œí•œ ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ë“¤ ì¶”ì 
- **íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬**: ì„¤ì •ëœ ì‹œê°„ í›„ ìë™ ì‹¤íŒ¨
- **ë¦¬ì†ŒìŠ¤ ì •ë¦¬**: íƒ€ì„ì•„ì›ƒëœ ëŒ€ê¸°ì í™•ì‹¤í•œ ì œê±°

### 3. ì›ìì  ì—°ì‚° ë³´ì¥
- **Lock ê¸°ë°˜ ë™ì‹œì„± ì œì–´**: ê·¸ë£¹ë³„ ê°œë³„ ë½
- **Race Condition ë°©ì§€**: ì½ê¸°-ì“°ê¸° ì›ìì„±
- **ì¼ê´€ì„± ë³´ì¥**: ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ ì•ˆì „ì„±

### 4. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- **ì‚¬ìš©ë¥  ì¶”ì **: ì‹¤ì‹œê°„ ìœˆë„ìš° ì‚¬ìš©ë¥ 
- **íŒ¨í„´ ë¶„ì„**: ìš”ì²­ íŒ¨í„´ ë° íŠ¸ë Œë“œ ê°ì§€
- **ì˜ˆì¸¡ ì•Œê³ ë¦¬ì¦˜**: í–¥í›„ ì‚¬ìš©ë¥  ì˜ˆì¸¡
- **ì•Œë¦¼ ì‹œìŠ¤í…œ**: ì„ê³„ê°’ ë„ë‹¬ ì‹œ ê²½ê³ 

---

## ğŸ” **ì„±ëŠ¥ ìµœì í™”**

### ë©”ëª¨ë¦¬ ìµœì í™”
```python
# 1. ìˆœí™˜ ë²„í¼ ì‚¬ìš© (ë©”ëª¨ë¦¬ ì œí•œ)
self.circular_logs: Dict[UpbitRateLimitGroup, collections.deque[RequestEntry]]

# 2. ì••ì¶•ëœ ì—”íŠ¸ë¦¬ (ë©”ëª¨ë¦¬ ì ˆì•½)
@dataclass
class CompressedRequestEntry:
    timestamp_offset: int  # 32bit offset from base_time
    weight: int = 1

# 3. ë°°ì¹˜ ì •ë¦¬ (CPU íš¨ìœ¨ì„±)
async def _batch_cleanup(self, batch_size: int = 1000):
    """ë°°ì¹˜ ë‹¨ìœ„ ë¡œê·¸ ì •ë¦¬"""
```

### ê²€ìƒ‰ ìµœì í™”
```python
# 1. íƒ€ì„ìŠ¤íƒ¬í”„ ì¸ë±ìŠ¤
timestamp_index: Dict[UpbitRateLimitGroup, Dict[int, List[int]]]  # second -> log indices

# 2. ì´ì§„ íƒìƒ‰ í™œìš©
def _find_window_start_index(self, logs: List[RequestEntry], cutoff_time: float) -> int:
    return bisect.bisect_left([r.timestamp for r in logs], cutoff_time)

# 3. ìºì‹œëœ ì¹´ìš´íŠ¸ (ì§§ì€ ì‹œê°„ ë‚´ ì¬ê³„ì‚° ë°©ì§€)
@dataclass
class CachedWindowCount:
    timestamp: float
    count: int
    weight_sum: int
    valid_until: float
```

---

## ğŸ¯ **ì‚¬ìš© ì˜ˆì œ**

### ê¸°ë³¸ ì‚¬ìš©ë²•
```python
# 1. ì„¤ì •
configs = {
    UpbitRateLimitGroup.REST_PUBLIC: SlidingWindowConfig(
        max_requests=100,
        window_size_seconds=60.0,
        max_log_size=5000
    )
}

# 2. ì´ˆê¸°í™”
limiter = SlidingWindowLimiter(configs)
await limiter.start()

# 3. ê¶Œí•œ íšë“
if await limiter.acquire_permission(UpbitRateLimitGroup.REST_PUBLIC, "ticker"):
    # API í˜¸ì¶œ ìˆ˜í–‰
    response = await api_call()
else:
    # Rate limit ë„ë‹¬
    logger.warning("Rate limit reached")

# 4. í˜„ì¬ ìƒíƒœ í™•ì¸
usage = limiter.get_current_usage(UpbitRateLimitGroup.REST_PUBLIC)
print(f"í˜„ì¬ ì‚¬ìš©ë¥ : {usage.current_count}/{usage.max_requests}")
```

### ê³ ê¸‰ ì‚¬ìš©ë²•
```python
# 1. ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì œí•œ
await limiter.acquire_permission(
    UpbitRateLimitGroup.REST_PRIVATE_ORDER,
    "order",
    weight=5  # ì£¼ë¬¸ì€ 5ë°° ê°€ì¤‘ì¹˜
)

# 2. ì˜ˆì¸¡ì  í™•ì¸
allowed, delay = await limiter.check_permission_without_consume(
    UpbitRateLimitGroup.REST_PUBLIC
)
if not allowed:
    await asyncio.sleep(delay)

# 3. ìƒì„¸ ëª¨ë‹ˆí„°ë§
stats = limiter.get_detailed_stats()
for group, data in stats.items():
    print(f"{group}: {data['current_usage']}/{data['max_requests']}")
    print(f"ë©”ëª¨ë¦¬ ì‚¬ìš©: {data['memory_mb']:.1f}MB")
    print(f"ì˜ˆì¸¡ ëŒ€ê¸°ì‹œê°„: {data['predicted_delay']:.3f}ì´ˆ")
```

---

## âš–ï¸ **ì¥ë‹¨ì  ë¶„ì„**

### ì¥ì 
âœ… **ì™„ë²½í•œ ì •í™•ì„±** - ëª¨ë“  ìš”ì²­ì„ ì •í™•íˆ ì¶”ì 
âœ… **ê²½ê³„ ë¬¸ì œ í•´ê²°** - ìœˆë„ìš° ê²½ê³„ì—ì„œì˜ ë²„ìŠ¤íŠ¸ ì—†ìŒ
âœ… **ìœ ì—°ì„±** - ì„ì˜ì˜ ìœˆë„ìš° í¬ê¸° ì§€ì›
âœ… **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§** - ì •í™•í•œ í˜„ì¬ ìƒíƒœ íŒŒì•…
âœ… **ì˜ˆì¸¡ ê¸°ëŠ¥** - í–¥í›„ ì‚¬ìš©ë¥  ì˜ˆì¸¡ ê°€ëŠ¥
âœ… **ê¸°ì¡´ ê³ ê¸‰ ê¸°ëŠ¥ ê³„ìŠ¹** - ìê°€ì¹˜ìœ , ì›ìì„±, íƒ€ì„ì•„ì›ƒ ë“±

### ë‹¨ì  ë° ëŒ€ì‘ë°©ì•ˆ
âŒ **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€** â†’ ìˆœí™˜ ë²„í¼, ì••ì¶•, ë°°ì¹˜ ì •ë¦¬ë¡œ í•´ê²°
âŒ **ê³„ì‚° ë³µì¡ë„ ì¦ê°€** â†’ ì¸ë±ìŠ¤, ìºì‹±, ì´ì§„ íƒìƒ‰ìœ¼ë¡œ ìµœì í™”
âŒ **ì´ˆê¸° êµ¬í˜„ ë³µì¡ì„±** â†’ ë‹¨ê³„ì  ë§ˆì´ê·¸ë ˆì´ì…˜, ì² ì €í•œ í…ŒìŠ¤íŠ¸

---

## ğŸš€ **ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ**

### Phase 1: ê¸°ë°˜ êµ¬ì¡° êµ¬ì¶• (1-2ì£¼)
- [ ] ê¸°ë³¸ ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ë¡œì§ êµ¬í˜„
- [ ] ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ë¡œê·¸ ê´€ë¦¬
- [ ] ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±

### Phase 2: ê³ ê¸‰ ê¸°ëŠ¥ í†µí•© (2-3ì£¼)
- [ ] ìê°€ì¹˜ìœ  ì‹œìŠ¤í…œ í¬íŒ…
- [ ] ì›ìì  ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] íƒ€ì„ì•„ì›ƒ ë³´ì¥ ì‹œìŠ¤í…œ í†µí•©

### Phase 3: ìµœì í™” ë° ëª¨ë‹ˆí„°ë§ (1-2ì£¼)
- [ ] ì„±ëŠ¥ ìµœì í™” (ì¸ë±ìŠ¤, ìºì‹±)
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
- [ ] ìƒì„¸ í†µê³„ ë° ì•Œë¦¼

### Phase 4: í”„ë¡œë•ì…˜ ë°°í¬ (1ì£¼)
- [ ] ë¶€í•˜ í…ŒìŠ¤íŠ¸
- [ ] ê¸°ì¡´ ì‹œìŠ¤í…œ êµì²´
- [ ] ëª¨ë‹ˆí„°ë§ ë° íŠœë‹

---

## ğŸ“Š **ì˜ˆìƒ ì„±ëŠ¥ ì§€í‘œ**

### ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
- **ê¸°ë³¸**: ~10MB (10,000 ìš”ì²­ ë¡œê·¸ ê¸°ì¤€)
- **ìµœì í™”**: ~5MB (ì••ì¶• ë° ìˆœí™˜ ë²„í¼ ì‚¬ìš©)
- **ëŒ€ê·œëª¨**: ~50MB (100,000 ìš”ì²­ ë¡œê·¸ ê¸°ì¤€)

### ì²˜ë¦¬ ì„±ëŠ¥
- **ê¶Œí•œ í™•ì¸**: <1ms (ì¸ë±ìŠ¤ ì‚¬ìš©)
- **ë¡œê·¸ ì¶”ê°€**: <0.1ms (append ì—°ì‚°)
- **ì •ë¦¬ ì‘ì—…**: <10ms (ë°°ì¹˜ ì²˜ë¦¬)

### ì •í™•ë„
- **429 ë°©ì§€ìœ¨**: 99.9% (ì˜ˆì¸¡ì  ìŠ¤ë¡œí‹€ë§)
- **ìœˆë„ìš° ì •í™•ë„**: 100% (ì™„ì „í•œ ë¡œê·¸ ì¶”ì )
- **ë™ì‹œì„± ì•ˆì „ì„±**: 100% (Lock ê¸°ë°˜ ì›ìì„±)

---

**ğŸ’¡ ê²°ë¡ **: ì´ ì„¤ê³„ëŠ” ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ì™„ë²½í•œ ì •í™•ì„±ê³¼ í˜„ì¬ ì‹œìŠ¤í…œì˜ ê³ ê¸‰ ê¸°ëŠ¥ë“¤ì„ ê²°í•©í•˜ì—¬, ì—…ë¹„íŠ¸ APIì˜ ê¹Œë‹¤ë¡œìš´ Rate Limit ìš”êµ¬ì‚¬í•­ì„ ì™„ë²½í•˜ê²Œ ë§Œì¡±í•˜ëŠ” ì°¨ì„¸ëŒ€ Rate Limiterë¥¼ ì œê³µí•©ë‹ˆë‹¤.
