완벽한 기록용 아이디어네요! `candle_empty_next_to` 방식을 문서화하고, 기존 방식으로 집중해서 토의해보겠습니다.

## 📝 **미래 최적화 방안 기록 - `candle_empty_next_to` 컬럼 방식**

### 🎯 **핵심 아이디어**
기존 실제 캔들 레코드에 "다음 빈 구간 종료점" 정보를 추가하여 최소한의 레코드로 빈 구간 표현

### 💡 **구조 예시**
```sql
-- 기존 스키마에 컬럼 하나만 추가
ALTER TABLE candles ADD COLUMN candle_empty_next_to TEXT NULL;

-- 사용 예시
candle_date_time_utc    | opening_price | ... | candle_empty_next_to
2025-09-07T15:39:00    | 67500.0       | ... | NULL                    -- 실제 캔들, 바로 다음도 실제
2025-09-07T15:38:00    | 67480.0       | ... | NULL                    -- 실제 캔들, 바로 다음도 실제
2025-09-07T15:37:00    | 67520.0       | ... | 2025-09-07T15:11:00     -- 실제 캔들, 15:36~15:12까지 빈 구간
2025-09-07T15:10:00    | 67600.0       | ... | NULL                    -- 실제 캔들, 바로 다음도 실제
2025-09-07T15:09:00    | 67590.0       | ... | NULL                    -- 실제 캔들, 바로 다음도 실제
```

### ✅ **장점**
- **최소 레코드**: 실제 캔들 개수만큼만 레코드 사용
- **기존 호환**: 모든 기존 쿼리가 그대로 작동
- **직관적**: "이 캔들 다음이 언제까지 비어있다"는 명확한 의미
- **효율적**: 범위 압축과 기존 방식의 장점 결합

### 🔍 **사용 패턴**
```sql
-- 특정 시간이 빈 구간인지 확인
SELECT 1 FROM candles
WHERE candle_date_time_utc < '2025-09-07T15:35:00'
  AND candle_empty_next_to >= '2025-09-07T15:35:00'
LIMIT 1;

-- 실제 캔들만 조회 (기존과 동일)
SELECT * FROM candles WHERE candle_date_time_utc BETWEEN ? AND ?;
```

**→ 나중에 극도의 최적화가 필요할 때 고려할 우수한 방안으로 기록 완료!**
