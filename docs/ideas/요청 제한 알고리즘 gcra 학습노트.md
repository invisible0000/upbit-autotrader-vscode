# Upbit Rate Limiter v2.0
업비트 API 전용 통합 Rate Limiter - Zero-429 보장
## 핵심 기능
- **Zero-429 정책**: 429 에러 완전 차단
- **Lock-Free GCRA**: aiohttp 패턴 기반 고성능
- **동적 조정**: 429 발생 시 자동 rate 감소 + 점진적 복구
- **자가치유**: 백그라운드 태스크 장애 시 자동 재시작
- **타임아웃 보장**: 무한 대기 방지

현재 구현된 gcra 버스트 허용 방법이 일반적으로 알려진 gcra의 tau를 이용한 버스트 처리 방식이 매우 다른거 같습니다. rest_api_public_all_endpoint_response.py 로 `10rps 엔드포인트를 대상으로 테스트 중에 `7rps+ 1버스트` 조건에서도 429 가 발생할정도로 어딘가 로직에 헛점이 있는거 같습니다. 그러니 테스트를 위해 upbit_rate_limiter_managers.py 에 기존 _consume_single_token_atomic 메서드의 이름을 _consume_single_token_atomic_bacup 으로 바꾼 후 _consume_single_token_atomic 를 아래에 제안하는 방식의 원론적인 tau를 이해서 구현재 주세요. 그리고 내부적으로 사용은 안하지만 로그 출력을 위한 현재 요청은 버스트임을 알릴 수 있도록 체크를 해서 남은 버스트 갯수를 알수 있도록 하고 싶습니다. 예로 요청이 버스트에 해당하면 `버트스(2/10)` 이런식으로 간단히 표현되어 최대갯수는 버스트 설정을 따르도록 해주세요. 이 값의 변화를 관찰하고 아래 기능을 구현하려 합니다.
요청은 버스트 체크를 가진다.
- 버스트 체크를 하면 버스트 카운트가 차감된다.
- 버스트 카운트의 최대값은 설정을 따른다.
- 버스트 카운트는 시간에 따라 다시 채워지며 rps설정의 역수 시간마다 채워진다.

그러나 이런 고려에도 문제는 있습니다. 업비트 서버는 슬라이딩 윈도우 카운트를 쓰는거 같은데 10 rps 제한인 rest api public 엔드 포인트에서 10개까지는 아무리 짧아도 허용하다가 11개 부터 1초안에 10개가 넘어가면 바로 429를 날립니다. 그런데 위와 같은 방식으로 제한하면 버스트이후 다음 요청을 gcra로 제한해도 업비트 제한에 걸리게 됩니다. 그러므로 이런 동작이 필요하게 됩니다.
요청01: 버스트(9/10), 요청간격: 0, 응답속도: 10ms, 10요청 누적 시간: 10ms(-990ms)
요청02: 버스트(8/10), 요청간격: 10ms,응답속도: 10ms, 10요청 누적 시간: 20ms(-980ms)
요청03: 버스트(7/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 30ms(-970ms)
요청04: 버스트(6/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 40ms(-960ms)
요청05: 버스트(5/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 50ms(-950ms)
요청06: 버스트(4/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 60ms(-940ms)
요청07: 버스트(3/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 70ms(-930ms)
요청08: 버스트(2/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 80ms(-920ms)
요청09: 버스트(1/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 90ms(-910ms)
요청10: 버스트(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 100ms(-900ms, 다음 요청 10누적 지연 필요)
요청11: 일반(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: ms: 1000ms(-0ms), 10누적 지연: + 890ms
요청12: 일반(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 1000ms(0ms), 10누적 지연: + 90ms
요청13: 일반(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 1000ms(0ms), 10누적 지연: + 90ms
-- 요청 없음 500ms
요청14: 버스트(4/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 510ms(-490ms)
요청15: 버스트(3/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 520ms(-480ms)
요청16: 버스트(2/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 530ms(-470ms)
요청17: 버스트(1/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 540ms(-460ms)
요청18: 버스트(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 550ms(-450ms, 다음 요청 10누적 지연 필요)
요청19: 일반(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: ms: 1000ms(-0ms), 10누적 지연: + 440ms
요청20: 일반(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 1000ms(0ms), 10누적 지연: + 90ms
요청21: 일반(0/10), 요청간격: 10ms, 응답속도: 10ms, 10요청 누적 시간: 1000ms(0ms), 10누적 지연: + 90ms

이런 동작을 지금은 슬라이딩 윈도우 로그 알고리즘이 아닌 gcra 로 구현을 하려 하는데 매우 어려움이 있습니다.
지금 구현된 gcra는 어딘가 헛점이 있는거 같아 _consume_single_token_atomic 를 순수한 gcra 방식으로 먼저 구현하고 다음에 동작을 관찰하여 위와 같은 동작이 내재 되도록 하는 기획을 하는것이 목적입니다.



#### 약어 명세
- RPS: Requests Per Second (초당 요청 수)
- RPM: Requests Per Minute (분당 요청 수)
- RTT: Round-Trip Time (왕복 시간)
- IRT: Inter-Request Time (요청 간격 시간)
- AIR: Actual Interval Rate or Actual Inter-Request Time (실제 요청 간격 시간)
- TIR: Target Interval Rate (목표 요청 간격 시간)
- ART: Average Response Time (평균 응답 시간)
- CT: Current Time (현재 시간)
- N: Sample Size (샘플 크기)
- NSSW: N-Sampled(Slot) Sliding Window (슬라이딩 윈도우 내 샘플 수)
- NoSSW: Number of Slots(Samples) in Sliding Window (슬라이딩 윈도우 내 슬롯 수)
- RLWait: Rate Limiter Wait Time (레이트 리미터 대기 시간)
- TAT: Theoretical Arrival Time (이론적 도착 시간)
- Tau: Time Constant (시간 상수)
- GCRA: Generic Cell Rate Algorithm (일반 셀 속도 알고리즘)
- TAT: Time of Actual Transmission (실제 전송 시간)

슬라이딩 윈도우 카운터 로그 방식

훌륭하지만 아직 429 에러가 나고 있습니다. 그래서 재밌는 계획을 세웠습니다. 현재의 슬라이딘 윈도우 카운터 로그방식을 포함 시킬건데 기존 코드는 동작하면서 슬라이딩 윈도우 카운터의 로그 방식의 주요 기능들을 담당한 변수들만 구현해서 지금 상태를 동작 시켜보면서 값을 지켜 보는겁니다.
 그렇다면 이제 조사가 필요할겁니다. 가용한 도구를 모두 사용하여 슬라이딩 윈도우 카운터의 기존 전문가들의 구현 패턴을 조사합니다. 그리고 우리의 _consume_single_token_atomic 메서드에 추가해야될 변수가 있는지 확인합니다. 그리고 기능 구현으로 넘어가지 전에 각 변수들의 값을 출력해 가면서 구현 가능성을 확인합니다.
  지금의 rate limiter구조를 그대로 활용하면서 새기능으로 자연스럽게 넘어가는거죠. 현재 구현의 장점이 많은것으로 압니다. 단순히 GCRA알고리즘 뿐만 아니라 많은 고급 기능이 포함된것으로 압니다. 이번 조사를 하면서 결론에 현재 구조의 장점도 같이 정리해서 표시해 주세요.
   마지막으로 다시 말씀드리면 바로 구현을 시작하는것이 아니고 조마,검토,계획을 세우는 단계입니다. 침착하게 차근차근 진행해 주세요. thought
