매우 중요한 발견입니다! 🎯 분석 결과를 공유드리겠습니다.

## 🔍 **문제 분석**

### **핵심 불일치 패턴**
```
✅ 수집 프로세스: 200,000개 완료 (청크 담당 범위 기준)
✅ DB 저장 결과: 200,000개 레코드 존재
❌ 최종 반환 결과: 199,616개 (384개 부족!)
```

### **의심되는 원인들**

#### **1. 메모리 제한 문제 🧠**
- 200,000개 `CandleData` 객체 생성 시 메모리 부족
- Python 리스트 한계 또는 SQLite 조회 결과 크기 제한
- `await self.repository.get_candles_by_range()` 내부 제한

#### **2. `_get_final_result` 로직 문제 📊**
```python
# _get_final_result에서 범위 계산 오류 가능성
if to and count:
    aligned_to = collection_state.completed_chunks[0].to
    end_time = TimeUtils.get_time_by_ticks(aligned_to, timeframe, -(count - 1))
    return await self.repository.get_candles_by_range(
        symbol, timeframe, aligned_to, end_time
    )
```
- `completed_chunks[0].to`와 실제 수집 범위 불일치?
- 시간 계산에서 edge case 누락?

#### **3. Repository 조회 한계 💾**
- `SqliteCandleRepository.get_candles_by_range()` 내부 LIMIT 절?
- SQLite 성능 최적화를 위한 묵시적 제한?

## 💡 **"순수 수집 모드" 제안 검토**

### **현재 아키텍처의 한계**
```python
# 현재: 수집 → 메모리 해제 → 다시 DB 조회 → 반환
async def get_candles(...) -> List[CandleData]:
    # 1. 청크별 수집 & DB 저장 (메모리 효율적)
    while True:
        await self.mark_chunk_completed(request_id)  # 즉시 메모리 해제

    # 2. 최종 결과를 위해 DB에서 다시 조회 (❌ 메모리 부담)
    collected_candles = await self._get_final_result(...)
    return collected_candles  # ← 여기서 메모리 문제 가능!
```

### **"순수 수집 모드"의 필요성** ✅

#### **Use Case 1: 대용량 백그라운드 수집**
```python
# 새로운 API 제안
async def collect_candles_only(...) -> CollectionSummary:
    """DB 저장만 수행, 메모리 반환 없음"""
    # 수집만 하고 요약 정보만 반환
    return CollectionSummary(
        collected_count=200000,
        db_records=200000,
        time_range=("2025-04-22T21:06:00", "2025-09-09T00:49:00"),
        chunks_processed=1000
    )
```

#### **Use Case 2: 스트리밍 수집**
```python
# 새로운 API 제안
async def stream_candles(...) -> AsyncGenerator[List[CandleData], None]:
    """청크별로 yield, 메모리 압박 없음"""
    while chunk := get_next_chunk():
        chunk_candles = await process_chunk()
        yield chunk_candles  # 청크별 점진적 반환
```

## 🎯 **즉시 해결 방안**

### **1. Repository 조회 한계 확인**
`SqliteCandleRepository.get_candles_by_range()` 내부에 LIMIT 절이 있는지 확인

### **2. 범위 계산 검증**
`_get_final_result`에서 시간 범위 계산이 실제 수집 범위와 일치하는지 검증

### **3. 메모리 사용량 모니터링**
200,000개 `CandleData` 객체 생성 시 메모리 사용량 측정

## 🚀 **장기적 개선 방향**

1. **순수 수집 모드**: DB 저장만, 메모리 반환 없음
2. **페이징 조회**: 대용량 데이터를 청크별로 반환
3. **스트리밍 모드**: 실시간 청크별 yield

**현재 문제는 "메모리 vs 성능"의 트레이드오프를 보여주는 완벽한 사례입니다!** 🎯
