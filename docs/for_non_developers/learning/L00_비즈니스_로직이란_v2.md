# 비즈니스 로직이란? v2 - Domain vs Application 완벽 구분

## 🎯 이 문서의 목적

**"비즈니스 로직이 Domain에도 있고 Application에도 있다고?"**

이 혼란을 **완벽히 해결**하고, **어디에 무엇을 만들지 정확히 판단**할 수 있게 됩니다.

---

## 🤔 핵심 질문: "비즈니스 로직은 어디에 있나요?"

### 혼란스러운 답변들

- 📚 **책 A**: "비즈니스 로직은 Domain에 있습니다"
- 📚 **책 B**: "비즈니스 로직은 Application에 있습니다"
- 🤷 **당신**: "뭐가 맞는 거죠???"

### 🎯 진실

**둘 다 맞습니다!** 하지만 **"비즈니스 로직"의 종류가 다릅니다.**

---

## 📊 비즈니스 로직의 2가지 종류

### 비유: 레스토랑으로 이해하기

```
🍽️ 레스토랑 = 자동매매 시스템

┌─────────────────────────────────────────┐
│ 🏛️ Domain 비즈니스 로직                 │
│ "요리법 규칙"                            │
│                                         │
│ - 파스타는 면을 8분 삶는다 (개념의 규칙)  │
│ - 스테이크는 150도에서 굽는다            │
│ - 소금은 재료의 1% 분량                  │
│                                         │
│ 특징: 어느 레스토랑이든 동일              │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 🎬 Application 비즈니스 로직             │
│ "주문 처리 규칙"                         │
│                                         │
│ - 주문 받기 → 재고 확인 → 조리 → 서빙    │
│ - VIP 고객은 우선 처리                   │
│ - 3만원 이상 무료 배달                   │
│                                         │
│ 특징: 레스토랑마다 다를 수 있음           │
└─────────────────────────────────────────┘
```

---

## 1️⃣ Domain 비즈니스 로직 (핵심 규칙)

### 정의

**"이것이 무엇인가?"에 대한 순수한 규칙**

### 특징

- ✅ **개념의 본질**: "전략이란?", "수익률이란?"
- ✅ **외부 의존성 없음**: DB, API, 파일 없이 완결
- ✅ **어디서든 동일**: 업비트든 바이낸스든 같은 규칙
- ✅ **변경 거의 없음**: 핵심 개념은 안정적

### 실전 예시

#### 예시 1: 수익률 계산

```python
# domain/services/profit_calculator.py
class ProfitCalculator:
    """수익률 계산 - Domain 비즈니스 로직"""

    def calculate_profit_rate(
        self,
        entry_price: Decimal,
        current_price: Decimal
    ) -> Decimal:
        """
        핵심 규칙: 수익률이란 무엇인가?
        수익률 = (현재가 - 진입가) ÷ 진입가 × 100

        외부 의존성 없음 → Domain!
        """
        if entry_price <= 0:
            raise DomainError("진입가는 0보다 커야 함")

        return (current_price - entry_price) / entry_price * 100

    def is_profit_target_reached(
        self,
        profit_rate: Decimal,
        target_rate: Decimal
    ) -> bool:
        """
        핵심 규칙: 목표 수익 달성이란?
        """
        return profit_rate >= target_rate
```

**왜 Domain인가?**

- ✅ "수익률"의 **개념 정의**
- ✅ 계산기만 있으면 테스트 가능 (DB/API 불필요)
- ✅ 어떤 거래소든 동일한 공식

#### 예시 2: 전략 규칙

```python
# domain/entities/strategy.py
class Strategy:
    """전략 엔티티 - Domain 비즈니스 로직"""

    def add_rule(self, rule: TriggerRule) -> None:
        """
        핵심 규칙: 전략이란 무엇인가?
        - 최대 10개 규칙
        - 중복 규칙 불가
        """
        if len(self.rules) >= 10:
            raise DomainError("전략은 최대 10개 규칙만 가능")

        if self._has_duplicate_rule(rule):
            raise DomainError("중복된 규칙 불가")

        self.rules.append(rule)

    def validate(self) -> None:
        """
        핵심 규칙: 유효한 전략이란?
        """
        if not self.entry_rules:
            raise DomainError("진입 규칙 필수")

        if not self.exit_rules:
            raise DomainError("청산 규칙 필수")
```

**왜 Domain인가?**

- ✅ "전략"의 **본질적 규칙**
- ✅ 외부 없이 메모리에서 검증 가능
- ✅ 플랫폼 무관 (어디서든 전략 개념은 동일)

#### 예시 3: RSI 판단

```python
# domain/services/indicator_validator.py
class IndicatorValidator:
    """지표 판단 - Domain 비즈니스 로직"""

    def is_oversold(self, rsi: Decimal) -> bool:
        """
        핵심 규칙: 과매도란?
        RSI < 30 → 과매도
        """
        return rsi < Decimal("30")

    def is_overbought(self, rsi: Decimal) -> bool:
        """
        핵심 규칙: 과매수란?
        RSI > 70 → 과매수
        """
        return rsi > Decimal("70")
```

**왜 Domain인가?**

- ✅ "과매수/과매도"의 **정의**
- ✅ 숫자 비교만으로 완결
- ✅ 기술적 분석의 보편적 규칙

---

## 2️⃣ Application 비즈니스 로직 (시나리오 규칙)

### 정의

**"어떻게 할 것인가?"에 대한 작업 흐름 규칙**

### 특징

- ✅ **시나리오 조율**: 여러 Domain + Infrastructure 조합
- ✅ **외부 의존성 있음**: Repository, API Client 사용
- ✅ **플랫폼 특화 가능**: 업비트만의 규칙 포함 가능
- ✅ **변경 많음**: 비즈니스 요구사항 변화에 민감

### 실전 예시

#### 예시 1: 전략 생성 시나리오

```python
# application/use_cases/create_strategy.py
class CreateStrategyUseCase:
    """전략 생성 UseCase - Application 비즈니스 로직"""

    def __init__(
        self,
        strategy_repository: IStrategyRepository,
        event_bus: IEventBus,
        auth_service: IAuthService
    ):
        self.repository = strategy_repository
        self.event_bus = event_bus
        self.auth_service = auth_service

    def execute(self, strategy_data: StrategyDTO, user_id: str) -> str:
        """
        시나리오 규칙: 전략을 어떻게 생성할 것인가?
        """
        # 1. 권한 검증 (Application 규칙)
        if not self.auth_service.can_create_strategy(user_id):
            raise ApplicationError("전략 생성 권한 없음")

        # 2. 중복 체크 (Application 규칙)
        if self.repository.exists_by_name(strategy_data.name):
            raise ApplicationError("동일한 이름의 전략이 이미 존재")

        # 3. 전략 생성 (Domain 호출)
        strategy = Strategy.create(strategy_data)
        strategy.validate()  # Domain 규칙 실행

        # 4. 저장 (Infrastructure 호출)
        strategy_id = self.repository.save(strategy)

        # 5. 이벤트 발행 (Application 규칙)
        self.event_bus.publish(
            StrategyCreatedEvent(strategy_id, user_id)
        )

        return strategy_id
```

**왜 Application인가?**

- ✅ **여러 단계 조율** (권한→중복→생성→저장→이벤트)
- ✅ **외부 의존성** (Repository, EventBus)
- ✅ **시나리오 특화** (우리 시스템만의 흐름)

#### 예시 2: 익절 실행 시나리오

```python
# application/use_cases/execute_take_profit.py
class ExecuteTakeProfitUseCase:
    """익절 실행 UseCase - Application 비즈니스 로직"""

    def __init__(
        self,
        position_repository: IPositionRepository,
        upbit_client: IUpbitClient,
        profit_calculator: ProfitCalculator,  # Domain
        event_bus: IEventBus,
        logger: Logger
    ):
        self.position_repo = position_repository
        self.upbit_client = upbit_client
        self.profit_calculator = profit_calculator
        self.event_bus = event_bus
        self.logger = logger

    def execute(self, position_id: str) -> dict:
        """
        시나리오 규칙: 익절을 어떻게 실행할 것인가?
        """
        # 1. 포지션 조회 (Infrastructure)
        position = self.position_repo.find_by_id(position_id)
        if not position:
            raise ApplicationError("포지션을 찾을 수 없음")

        # 2. 현재가 조회 (Infrastructure)
        current_price = self.upbit_client.get_current_price(
            position.symbol
        )

        # 3. 수익률 계산 (Domain 호출)
        profit_rate = self.profit_calculator.calculate_profit_rate(
            position.entry_price,
            current_price
        )

        # 4. 목표 달성 확인 (Domain 호출)
        if not self.profit_calculator.is_profit_target_reached(
            profit_rate,
            position.target_profit_rate
        ):
            return {"status": "target_not_reached", "profit_rate": profit_rate}

        # 5. 주문 생성 (Domain 호출)
        order = position.create_close_order(current_price)

        # 6. 거래소 주문 (Infrastructure)
        result = self.upbit_client.place_order(order)

        # 7. 상태 업데이트 및 저장 (Application 규칙)
        position.mark_as_closed(result.executed_price)
        self.position_repo.save(position)

        # 8. 로깅 및 이벤트 (Application 규칙)
        self.logger.info(f"익절 완료: {position_id}, 수익률: {profit_rate}%")
        self.event_bus.publish(
            TakeProfitExecutedEvent(position_id, profit_rate)
        )

        return {
            "status": "success",
            "profit_rate": profit_rate,
            "order_id": result.order_id
        }
```

**왜 Application인가?**

- ✅ **복잡한 시나리오** (8단계 흐름)
- ✅ **외부 연동 다수** (Repository, API Client)
- ✅ **Domain + Infrastructure 조율**

#### 예시 3: 포트폴리오 리밸런싱

```python
# application/services/portfolio_rebalancing_service.py
class PortfolioRebalancingService:
    """포트폴리오 리밸런싱 - Application 비즈니스 로직"""

    def rebalance_portfolio(self, portfolio_id: str) -> dict:
        """
        시나리오 규칙: 포트폴리오를 어떻게 리밸런싱할 것인가?

        비즈니스 규칙:
        - 각 코인은 총 자산의 20%씩 유지
        - 5% 이상 벗어나면 리밸런싱
        - 거래 수수료 고려
        """
        # 1. 포트폴리오 조회
        positions = self.position_repo.find_by_portfolio(portfolio_id)

        # 2. 총 자산 계산 (Domain 호출)
        total_value = self.portfolio_calculator.calculate_total_value(
            positions
        )

        # 3. 목표 비중 계산 (Application 규칙)
        target_allocation = total_value * Decimal("0.2")

        rebalancing_orders = []

        for position in positions:
            # 4. 현재 비중 계산 (Domain 호출)
            current_value = self.portfolio_calculator.calculate_position_value(
                position
            )

            # 5. 차이 계산 및 판단 (Application 규칙)
            diff = current_value - target_allocation
            diff_ratio = abs(diff) / target_allocation

            # 비즈니스 규칙: 5% 이상 차이만 리밸런싱
            if diff_ratio < Decimal("0.05"):
                continue

            # 6. 주문 생성 및 실행
            if diff > 0:  # 초과 보유 → 매도
                order = self._create_sell_order(position, diff)
            else:  # 부족 보유 → 매수
                order = self._create_buy_order(position, abs(diff))

            # 7. 거래소 주문 (Infrastructure)
            result = self.upbit_client.place_order(order)
            rebalancing_orders.append(result)

        # 8. 결과 저장 및 이벤트
        self.position_repo.save_all(positions)
        self.event_bus.publish(
            PortfolioRebalancedEvent(portfolio_id, rebalancing_orders)
        )

        return {
            "rebalanced_count": len(rebalancing_orders),
            "orders": rebalancing_orders
        }
```

**왜 Application인가?**

- ✅ **복잡한 조율** (여러 포지션 동시 처리)
- ✅ **비즈니스 정책** (5% 기준, 20% 비중)
- ✅ **외부 의존성** (Repository, API)

---

## 🎯 판단 기준: 3가지 질문법

### 질문 1: "외부 없이 테스트 가능한가?"

```python
# ✅ YES → Domain
def test_profit_calculator():
    calculator = ProfitCalculator()
    result = calculator.calculate_profit_rate(
        Decimal("100"),
        Decimal("110")
    )
    assert result == Decimal("10")  # 10% 수익
    # DB, API 필요 없음!

# ❌ NO → Application
def test_create_strategy():
    # Mock 필요
    mock_repo = Mock(IStrategyRepository)
    mock_event_bus = Mock(IEventBus)

    use_case = CreateStrategyUseCase(mock_repo, mock_event_bus)
    # ...
```

### 질문 2: "거래소가 바뀌어도 동일한가?"

```python
# ✅ YES → Domain
# "수익률 = (현재가 - 진입가) ÷ 진입가 × 100"
# 업비트든 바이낸스든 동일!

# ❌ NO → Application
# "업비트 API 호출 → 주문 → 웹훅 수신"
# 거래소마다 다를 수 있음
```

### 질문 3: "여러 객체/서비스를 조율하는가?"

```python
# ❌ NO → Domain
class Strategy:
    def validate(self):
        # 자기 자신만 검증
        if not self.rules:
            raise DomainError("규칙 없음")

# ✅ YES → Application
class CreateStrategyUseCase:
    def execute(self, data):
        # 여러 서비스 조율
        self.auth_service.check(...)
        self.repository.save(...)
        self.event_bus.publish(...)
```

---

## 📊 비교표: Domain vs Application

| 구분 | Domain 비즈니스 로직 | Application 비즈니스 로직 |
|------|---------------------|-------------------------|
| **질문** | "이것이 무엇인가?" | "어떻게 할 것인가?" |
| **초점** | 개념의 본질 | 작업의 흐름 |
| **예시** | "수익률이란?", "전략이란?" | "전략을 어떻게 생성?", "익절을 어떻게 실행?" |
| **계산** | 단일 공식 (수익률, RSI) | 여러 계산 조합 + 저장 + 알림 |
| **검증** | 단일 객체 유효성 | 여러 객체 간 정합성 |
| **의존성** | ❌ 외부 없음 | ✅ Repository, API Client |
| **테스트** | 단위 테스트 쉬움 | Mock 필요 |
| **변경** | 거의 변하지 않음 | 시나리오 변경 가능 |
| **재사용** | 높음 (어디서든) | 중간 (UseCase별 특화) |
| **폴더** | `domain/` | `application/` |

---

## 🔍 실전 판단 연습

### 연습 1: "손절 규칙"

**요구사항:** "손실률 -3% 달성 시 자동 손절"

#### 분해

**Domain 부분:**

```python
# domain/services/loss_calculator.py
class LossCalculator:
    def calculate_loss_rate(self, entry_price, current_price):
        """손실률 계산 - Domain"""
        return (current_price - entry_price) / entry_price * 100

    def should_stop_loss(self, loss_rate, stop_loss_rate):
        """손절 필요 여부 - Domain"""
        return loss_rate <= stop_loss_rate
```

**Application 부분:**

```python
# application/use_cases/execute_stop_loss.py
class ExecuteStopLossUseCase:
    def execute(self, position_id):
        """손절 실행 시나리오 - Application"""
        # 1. 포지션 조회
        position = self.repo.find(position_id)

        # 2. 현재가 조회 (Infrastructure)
        current_price = self.upbit_client.get_price(...)

        # 3. 손실률 계산 (Domain 호출)
        loss_rate = self.loss_calculator.calculate_loss_rate(...)

        # 4. 손절 판단 (Domain 호출)
        if not self.loss_calculator.should_stop_loss(...):
            return "손절 불필요"

        # 5. 주문 생성 및 실행 (Infrastructure)
        order = position.create_close_order(...)
        result = self.upbit_client.place_order(order)

        # 6. 저장 및 이벤트 (Application)
        self.repo.save(position)
        self.event_bus.publish(...)
```

### 연습 2: "볼린저 밴드 돌파 매수"

**요구사항:** "볼린저 밴드 하단 돌파 시 매수"

#### 분해

**Domain 부분:**

```python
# domain/services/bollinger_calculator.py
class BollingerCalculator:
    def calculate_bands(self, prices, period=20):
        """볼린저 밴드 계산 - Domain"""
        ma = self._moving_average(prices, period)
        std = self._standard_deviation(prices, period)

        upper = ma + (std * 2)
        lower = ma - (std * 2)

        return upper, ma, lower

    def is_lower_band_break(self, current_price, lower_band):
        """하단 돌파 판단 - Domain"""
        return current_price < lower_band
```

**Application 부분:**

```python
# application/use_cases/execute_bollinger_buy.py
class ExecuteBollingerBuyUseCase:
    def execute(self, symbol):
        """볼린저 밴드 기반 매수 시나리오 - Application"""
        # 1. 과거 가격 조회 (Infrastructure)
        prices = self.upbit_client.get_candles(symbol, count=20)

        # 2. 볼린저 밴드 계산 (Domain 호출)
        upper, ma, lower = self.bollinger_calculator.calculate_bands(prices)

        # 3. 현재가 조회 (Infrastructure)
        current_price = self.upbit_client.get_current_price(symbol)

        # 4. 돌파 판단 (Domain 호출)
        if not self.bollinger_calculator.is_lower_band_break(
            current_price, lower
        ):
            return "돌파 아님"

        # 5. 매수 금액 계산 (Application 규칙)
        balance = self.upbit_client.get_balance("KRW")
        buy_amount = balance * Decimal("0.1")  # 잔고의 10%

        # 6. 주문 실행 (Infrastructure)
        order = Order.create_market_buy(symbol, buy_amount)
        result = self.upbit_client.place_order(order)

        # 7. 포지션 생성 및 저장 (Application)
        position = Position.create_from_order(result)
        self.position_repo.save(position)

        return result
```

### 연습 3: "분할 매수 전략"

**요구사항:** "3% 하락할 때마다 추가 매수 (최대 3회)"

#### 분해

**Domain 부분:**

```python
# domain/services/scaling_calculator.py
class ScalingCalculator:
    def calculate_next_buy_price(
        self,
        last_buy_price: Decimal,
        drop_rate: Decimal
    ) -> Decimal:
        """다음 매수 가격 계산 - Domain"""
        return last_buy_price * (1 - drop_rate / 100)

    def can_scale_in(
        self,
        current_buy_count: int,
        max_buy_count: int
    ) -> bool:
        """추가 매수 가능 여부 - Domain"""
        return current_buy_count < max_buy_count
```

**Application 부분:**

```python
# application/use_cases/execute_scaling_buy.py
class ExecuteScalingBuyUseCase:
    def execute(self, position_id):
        """분할 매수 시나리오 - Application"""
        # 1. 포지션 조회 (Infrastructure)
        position = self.position_repo.find(position_id)

        # 2. 추가 매수 가능 확인 (Domain 호출)
        if not self.scaling_calculator.can_scale_in(
            position.buy_count,
            max_buy_count=3
        ):
            return "최대 매수 횟수 도달"

        # 3. 다음 매수 가격 계산 (Domain 호출)
        next_buy_price = self.scaling_calculator.calculate_next_buy_price(
            position.last_buy_price,
            drop_rate=Decimal("3")
        )

        # 4. 현재가 확인 (Infrastructure)
        current_price = self.upbit_client.get_current_price(
            position.symbol
        )

        # 5. 가격 조건 확인 (Application 규칙)
        if current_price > next_buy_price:
            return "아직 매수 가격 미도달"

        # 6. 매수 금액 계산 (Application 규칙)
        # 비즈니스 규칙: 첫 매수의 50%씩 추가
        buy_amount = position.first_buy_amount * Decimal("0.5")

        # 7. 주문 실행 (Infrastructure)
        order = Order.create_market_buy(position.symbol, buy_amount)
        result = self.upbit_client.place_order(order)

        # 8. 포지션 업데이트 (Application)
        position.add_buy(result.price, result.quantity)
        self.position_repo.save(position)

        return result
```

---

## 💡 왜 이렇게 나누나요?

### Domain 분리의 장점

```python
# ✅ 재사용성: 어디서든 사용 가능
profit_rate = profit_calculator.calculate(100, 110)  # UseCase에서
profit_rate = profit_calculator.calculate(100, 110)  # Presenter에서
profit_rate = profit_calculator.calculate(100, 110)  # 배치 작업에서

# ✅ 테스트 용이: 외부 없이 완결
def test_profit_calculator():
    result = calculate_profit_rate(100, 110)
    assert result == 10  # Mock 불필요!

# ✅ 변경 안정성: 핵심 규칙은 거의 변하지 않음
# "수익률 공식"은 10년이 지나도 동일
```

### Application 분리의 장점

```python
# ✅ 시나리오 유연성: 흐름 변경 쉬움
# AS-IS: 생성 → 저장
# TO-BE: 생성 → 승인 대기 → 저장

# ✅ 외부 통합: Infrastructure 조율
# Repository, API Client, EventBus 등을 자유롭게 조합

# ✅ 비즈니스 정책: 플랫폼 특화 규칙
# "업비트는 최소 5,000원", "VIP는 수수료 면제" 등
```

---

## 🎓 최종 정리

### Domain 비즈니스 로직 체크리스트

- [ ] "이것이 무엇인가?"에 대한 답인가?
- [ ] 외부 의존성(DB, API) 없이 완결되는가?
- [ ] 어떤 플랫폼에서든 동일한 규칙인가?
- [ ] 단위 테스트가 간단한가?

**→ 모두 YES → Domain에 작성**

### Application 비즈니스 로직 체크리스트

- [ ] "어떻게 할 것인가?"에 대한 답인가?
- [ ] 여러 Domain/Infrastructure를 조율하는가?
- [ ] 외부 의존성(Repository, API)이 필요한가?
- [ ] 시나리오가 변경될 가능성이 있는가?

**→ 모두 YES → Application에 작성**

---

## 🚀 실전 적용 가이드

### 새 기능 구현 시

1. **먼저 Domain 생각**
   - "이 기능의 핵심 개념/규칙은?"
   - 계산식, 검증 규칙을 Domain에 먼저 구현

2. **다음 Application 설계**
   - "어떤 순서로 실행할 것인가?"
   - Domain + Infrastructure 조율 시나리오 작성

3. **테스트 작성**
   - Domain: 단위 테스트 (Mock 없이)
   - Application: 통합 테스트 (Mock 사용)

---

## 📖 다음 학습

비즈니스 로직 구분을 이해했다면:

1. **learning/L01_DDD란_무엇인가.md** - DDD 전체 구조 이해
2. **learning/L04_Domain_쉽게_이해하기.md** - Domain 심화
3. **learning/L05_Application_쉽게_이해하기.md** - Application 심화
4. **guides/01_어디에_무엇을_만들까.md** - 실전 판단 연습

---

**문서 버전:** v2.0
**최종 수정:** 2025-10-02
**작성자:** GitHub Copilot (Claude Sonnet 4)
**변경 사항:** Domain vs Application 비즈니스 로직 완벽 구분
