# 🎯 코파일럿에게 올바르게 요청하기

> **비개발자를 위한 효율적인 AI 협업 가이드**
>
> "코파일럿이 엉뚱한 걸 만들어요" → 이 문서 하나면 해결됩니다!

---

## 📋 문서 정보

- **대상 독자**: 비개발자, GitHub Copilot 사용자
- **읽는 시간**: 20분
- **목적**: 명확한 요청으로 정확한 결과 얻기
- **실전 예시**: 오늘 발생한 실제 사례 기반

---

## 🎯 핵심 메시지

> **"구체적으로 요청하면 → 정확한 결과를 얻습니다"**
>
> 좋은 요청 = 50% 시간 절약 = 스트레스 제로

---

## 📖 목차

1. [왜 코파일럿이 엉뚱한 걸 만들까?](#-왜-코파일럿이-엉뚱한-걸-만들까)
2. [좋은 요청 vs 나쁜 요청](#-좋은-요청-vs-나쁜-요청)
3. [오늘의 실제 사례: DI 패턴 과잉 적용](#-오늘의-실제-사례-di-패턴-과잉-적용)
4. [5가지 황금 규칙](#-5가지-황금-규칙)
5. [실전 요청 템플릿](#-실전-요청-템플릿)
6. [체크리스트](#-체크리스트)

---

## 🤔 왜 코파일럿이 엉뚱한 걸 만들까?

### 코파일럿은 "마음을 읽지 못합니다"

**예시:**

```
❌ 나의 요청: "차트 만들어줘"

🤖 코파일럿이 이해한 것:
- 어떤 종류의 차트? (막대/선/캔들스틱?)
- 어디에 만들까? (새 파일? 기존 파일?)
- 어떤 데이터? (주식? 암호화폐?)
- 어떤 라이브러리? (matplotlib? plotly?)

→ 결과: 내가 원하지 않는 막대 차트 생성 😱
```

### 코파일럿은 "패턴을 따릅니다"

**오늘의 실제 사례:**

```python
# 코파일럿이 본 기존 코드 패턴
navigation_service = providers.Factory(NavigationBar)
status_bar_service = providers.Factory(StatusBar)
window_state_service = providers.Factory(WindowStateService)

# 코파일럿의 생각:
"아하! 모든 UI 위젯은 providers.Factory로 감싸는구나!"

# 결과: 필요 없는 곳까지 Factory 패턴 적용
# → 코드 복잡도 증가 😭
```

**문제점:**

- 코파일럿은 **"왜"**를 모릅니다
- 기존 코드를 **"무조건 따라합니다"**
- **"이건 잘못된 패턴이야"**를 판단 못 합니다

---

## ✅ 좋은 요청 vs 나쁜 요청

### 예시 #1: UI 컴포넌트 생성

#### ❌ 나쁜 요청

```
"차트 화면 만들어줘"
```

**문제점:**

1. 어디에 만들지 모름
2. 어떤 차트인지 모름
3. 어떤 패턴을 쓸지 모름
4. 의존성을 어떻게 할지 모름

**결과: 엉뚱한 위치에 엉뚱한 코드 생성**

#### ✅ 좋은 요청

```
차트 뷰 화면을 만들고 싶습니다.

📍 위치: upbit_auto_trading/ui/desktop/views/chart_view.py
🎯 목적: 실시간 캔들스틱 차트 표시

📋 요구사항:
1. matplotlib을 사용한 캔들스틱 차트
2. QWidget 기반 UI 컴포넌트
3. update_chart(candle_data) 메서드 제공

✅ 아키텍처 준수사항:
- MVP 패턴의 View 역할
- Presenter와 신호/슬롯으로 통신
- 직접적인 비즈니스 로직 포함 금지

🚫 금지사항:
- providers.Factory 사용하지 말 것 (단순 UI 위젯)
- 데이터 조회 로직 포함하지 말 것
- 전역 변수 사용 금지
```

**결과: 정확히 원하는 코드 생성** ✅

---

### 예시 #2: 서비스 클래스 생성

#### ❌ 나쁜 요청

```
"알림 서비스 만들어줘"
```

**코파일럿의 혼란:**

- 어느 레이어? (Domain? Application? Infrastructure?)
- DI 컨테이너에 등록? 아니면 직접 생성?
- Provider 패턴 사용? 아니면 수동 DI?

**결과: 레이어 위반 코드 생성 가능**

#### ✅ 좋은 요청

```
알림 서비스를 구현하고 싶습니다.

📍 위치: upbit_auto_trading/application/services/notification_service.py
🎯 목적: 거래 체결 시 사용자에게 알림 전송

📋 기능:
1. send_notification(message: str, level: str)
2. 알림 타입: INFO, WARNING, ERROR
3. 알림 이력 저장 (최근 100개)

✅ 아키텍처 준수사항:
- Application Layer 서비스 (비즈니스 로직 조합)
- Domain Event를 구독하여 동작
- Infrastructure 의존성 주입으로 받기

🔧 의존성 주입 방식:
- ApplicationServiceContainer에서 get_notification_service() 메서드로 제공
- 직접 생성 (providers.Factory 사용 안 함)
- Repository 주입 받기
```

**결과: 아키텍처에 맞는 깔끔한 코드** ✅

---

## 📚 오늘의 실제 사례: DI 패턴 과잉 적용

### 배경 상황

**문제:**

```python
# PresentationContainer.py
navigation_service = providers.Factory(NavigationBar)
status_bar_service = providers.Factory(StatusBar)
window_state_service = providers.Factory(WindowStateService)
menu_service = providers.Factory(MenuService)
```

**왜 문제인가?**

- NavigationBar, StatusBar는 **단순 UI 위젯**
- 상태 없음, 리소스 관리 불필요
- 매번 Factory로 생성할 이유 없음
- **코드 복잡도만 증가**

### 잘못된 요청 예시 (추정)

```
"NavigationBar를 DI 컨테이너에 등록해줘"
```

**코파일럿의 판단:**

- 기존 코드에 providers.Factory 패턴이 많네?
- 그럼 이것도 Factory로 감싸야지!

**결과:**

```python
# 불필요한 Provider 래핑
navigation_service = providers.Factory(NavigationBar)
```

### 올바른 요청 방법

```
NavigationBar를 MainWindow에서 사용하고 싶습니다.

📍 분석 먼저:
- NavigationBar는 상태 없는 단순 UI 위젯입니다
- MainWindow당 1개만 필요합니다
- 리소스 관리, 환경별 구현 불필요

🎯 요청:
MainWindow.__init__()에서 직접 생성하도록 해주세요.

```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.nav_bar = NavigationBar()  # 직접 생성
```

🚫 금지사항:

- providers.Factory 사용하지 말 것
- PresentationContainer에 등록하지 말 것
- 이유: 단순 UI 위젯은 직접 생성이 적절함

```

---

## 🎖️ 5가지 황금 규칙

### 규칙 #1: 정확한 파일 경로 명시

```

❌ "설정 화면 만들어줘"
✅ "upbit_auto_trading/ui/desktop/views/settings_view.py에 설정 화면 View 만들어줘"

```

**이유:** 코파일럿은 파일 위치를 추측하지 못합니다.

---

### 규칙 #2: 레이어 명시

```

❌ "전략 서비스 만들어줘"

✅ "application/services/strategy_application_service.py에
    전략 Application Service를 만들어줘.
    이 서비스는 Application Layer에 속하므로
    여러 Domain 객체를 조합하여 유스케이스를 구현해야 해."

```

**이유:** 같은 이름이라도 레이어에 따라 역할이 다릅니다.

---

### 규칙 #3: "하지 말아야 할 것" 명시

```

✅ 좋은 요청:

"DatabaseHealthService를 만들어줘.

🚫 금지사항:

- providers.Factory 사용 금지 (단순 서비스)
- 전역 변수 사용 금지
- print() 대신 Infrastructure 로깅 사용
- Domain Layer 의존성 주입 금지"

```

**이유:** 코파일럿은 안티패턴을 모릅니다. 명시적으로 금지해야 합니다.

---

### 규칙 #4: 기존 코드 패턴 지정

```

✅ 좋은 요청:

"NotificationService를 만들어줘.

📚 참고 패턴:

- ApplicationServiceContainer의 다른 서비스들처럼 get_xxx() 메서드로 제공
- 직접 생성 방식 (Factory 패턴 사용 안 함)
- 의존성은 생성자 주입

예시 참고:
application/services/strategy_application_service.py와 동일한 구조"

```

**이유:** 올바른 기존 코드를 참고하게 유도합니다.

---

### 규칙 #5: Provider 사용 판단 기준 제공

```

✅ 좋은 요청:

"ApiKeyService를 Infrastructure Layer에 만들어줘.

🔧 Provider 패턴 필요 여부 판단:
✅ Provider 필요:

- 보안 키 관리 (리소스 관리 필요)
- 환경별 다른 구현 가능성
- TTL 캐싱 (생명주기 제어 필요)

→ 결론: providers.Factory 사용 정당함

코드:
ExternalDependencyContainer에 다음과 같이 등록:

api_key_service = providers.Factory(
    ApiKeyService,
    secure_keys_repository=secure_keys_repository
)

```

**이유:** 언제 Provider를 써야 하는지 명확히 합니다.

---

## 📝 실전 요청 템플릿

### 템플릿 #1: 새 서비스 클래스 생성

```

[서비스명]을 구현하고 싶습니다.

📍 위치: [정확한 파일 경로]
🎯 목적: [한 문장 설명]
🏗️ 레이어: [Infrastructure/Domain/Application/Presentation]

📋 기능:

✅ 아키텍처 준수사항:

- [레이어 역할에 맞는 책임]
- [의존성 주입 방식]
- [다른 레이어와의 통신 방법]

🔧 DI 패턴 판단:
[Provider 필요 여부와 이유]

🚫 금지사항:

- [안티패턴 리스트]

📚 참고 코드:
[비슷한 기존 코드 경로]

```

---

### 템플릿 #2: UI 컴포넌트 생성

```

[UI 컴포넌트명]을 만들고 싶습니다.

📍 위치: upbit_auto_trading/ui/desktop/[폴더]/[파일명].py
🎯 목적: [화면 기능 설명]

📋 UI 구성:

✅ MVP 패턴 준수:

- View 역할만 (비즈니스 로직 금지)
- Presenter와 신호/슬롯 통신
- 데이터는 Presenter에서 받기

🔧 생성 방식:

- MainWindow에서 직접 생성 (Provider 불필요)
- 이유: 상태 없는 단순 UI 위젯

🚫 금지사항:

- providers.Factory 사용 금지
- 비즈니스 로직 포함 금지
- DB/API 직접 호출 금지

🎨 스타일링:

- ui/desktop/common/styles/ 의 전역 테마 사용
- setStyleSheet() 하드코딩 금지

```

---

### 템플릿 #3: 기존 코드 수정

```

[파일명]의 [기능]을 수정하고 싶습니다.

📍 대상 파일: [정확한 경로]
🎯 수정 목적: [명확한 이유]

📋 수정 내용:

1. [Before]: [기존 동작]
   [After]: [원하는 동작]

✅ 유지사항:

- [변경하면 안 되는 것들]
- [다른 코드와의 호환성]

🔧 아키텍처 영향:

- [이 수정이 다른 레이어에 미치는 영향]
- [관련 코드 수정 필요 여부]

🚫 주의사항:

- [실수하기 쉬운 부분]

🧪 검증 방법:

- [수정 후 테스트 방법]

```

---

## ✅ 요청 전 체크리스트

### 필수 확인 사항

- [ ] **파일 경로를 정확히 명시했는가?**
  - ❌ "설정 화면"
  - ✅ "upbit_auto_trading/ui/desktop/views/settings_view.py"

- [ ] **레이어를 명확히 했는가?**
  - ❌ "서비스 만들어줘"
  - ✅ "Application Layer의 UseCase 서비스"

- [ ] **금지사항을 명시했는가?**
  - ❌ 요청만 함
  - ✅ "providers.Factory 사용 금지, 이유: 단순 UI 위젯"

- [ ] **참고할 기존 코드를 지정했는가?**
  - ❌ "알아서 만들어줘"
  - ✅ "strategy_application_service.py와 동일한 구조로"

- [ ] **Provider 패턴 필요성을 판단했는가?**
  - ❌ "그냥 만들어줘"
  - ✅ "리소스 관리 불필요하므로 직접 생성"

---

## 🎓 학습 포인트

### Provider 패턴 사용 판단 (오늘의 핵심!)

#### ✅ Provider 필요한 경우

```python
# ✅ DatabaseManager - 리소스 관리 필요
database_manager = providers.Singleton(DatabaseConnectionService)

# ✅ ApiKeyService - 보안, 환경별 구현
api_key_service = providers.Factory(
    ApiKeyService,
    secure_keys_repository=secure_keys_repository
)

# ✅ ThemeService - 동적 생성, 설정 의존
theme_service = providers.Factory(
    ThemeService,
    settings_service=settings_service
)
```

**판단 기준:**

- 리소스 관리 필요? (DB 연결, API Rate Limit)
- 환경별 다른 구현? (Dev/Test/Prod)
- 생명주기 제어 필요? (Singleton, 지연 초기화)
- 복잡한 의존성 조합?

#### ❌ Provider 불필요한 경우

```python
# ❌ NavigationBar - 단순 UI 위젯
# navigation_service = providers.Factory(NavigationBar)
self.nav_bar = NavigationBar()  # 직접 생성

# ❌ WindowStateService - 상태 없는 유틸리티
# window_state_service = providers.Factory(WindowStateService)
self.window_state = WindowStateService()  # 직접 생성

# ❌ MenuService - 단순 로직 조합
# menu_service = providers.Factory(MenuService)
self.menu = MenuService()  # 직접 생성
```

**판단 기준:**

- 상태 없음?
- 리소스 관리 불필요?
- 환경별 구현 차이 없음?
- 단순 UI 위젯?

---

## 💡 실전 팁

### 팁 #1: 코파일럿에게 "왜"를 설명하기

```
❌ "providers.Factory 쓰지 마"

✅ "providers.Factory 쓰지 마.
   이유: NavigationBar는 단순 UI 위젯이고,
         상태가 없으며, 리소스 관리가 필요 없어.
         MainWindow당 1개만 있으면 되므로 직접 생성이 적절해."
```

**효과:** 코파일럿이 비슷한 상황에서 올바른 판단

---

### 팁 #2: 단계별 요청

```
✅ 1단계 요청:
"먼저 DatabaseHealthService 클래스만 만들어줘.
 메서드는 나중에 추가할게."

✅ 2단계 요청:
"이제 check_health_sync() 메서드를 추가해줘.
 SQLite 연결 테스트 로직 포함."

✅ 3단계 요청:
"ApplicationServiceContainer에서 이 서비스를
 get_database_health_service()로 제공하도록 해줘.
 직접 생성 방식으로."
```

**효과:** 복잡한 작업을 작은 단계로 분할, 검증 용이

---

### 팁 #3: 검증 요청 포함

```
✅ 요청 마지막에 추가:

"📊 검증 요청:
1. 이 코드가 DDD 레이어 규칙을 위반하지 않는지 확인해줘
2. Provider 패턴 사용이 적절한지 검토해줘
3. 비슷한 기존 코드와 일관성이 있는지 확인해줘"
```

**효과:** 코파일럿이 자체 검증 수행

---

## 🎯 다음 단계

이제 올바르게 요청하는 방법을 배웠다면:

1. **실전 연습**: 작은 기능부터 템플릿 사용하여 요청
2. **피드백 받기**: 코파일럿 응답 확인 후 수정 요청
3. **패턴 학습**: 잘 작동한 요청 방식을 노트에 기록

---

## 📞 자주 묻는 질문

### Q1: "요청이 너무 길어지는데 괜찮나요?"

**A:** 네! 구체적일수록 좋습니다.

- 짧은 요청 = 잘못된 코드 = 수정 3시간
- 긴 요청 = 정확한 코드 = 수정 0시간

**결론: 처음부터 자세히 요청하는 게 더 빠릅니다!**

---

### Q2: "코파일럿이 제 요청을 무시하는 것 같아요"

**A:** 명시적으로 강조하세요:

```
🚨 중요: 다음 사항을 반드시 지켜주세요:

1. providers.Factory 사용 금지
2. Infrastructure 로깅 필수 사용
3. MVP 패턴 준수

위 규칙을 위반하면 전체 아키텍처가 망가집니다!
```

---

### Q3: "어떤 기존 코드를 참고하라고 해야 하나요?"

**A:** 비슷한 역할의 잘 작동하는 코드:

```
✅ 새 Application Service 만들 때:
→ application/services/strategy_application_service.py 참고

✅ 새 UI View 만들 때:
→ ui/desktop/views/dashboard_view.py 참고

✅ 새 Infrastructure Service 만들 때:
→ infrastructure/services/api_key_service.py 참고
```

---

## 🎖️ 마스터 체크리스트

### 완벽한 요청을 위한 최종 점검

- [ ] 📍 정확한 파일 경로 명시
- [ ] 🏗️ 레이어 명확히 지정
- [ ] 🎯 목적을 한 문장으로 설명
- [ ] 📋 구체적인 기능 나열
- [ ] ✅ 아키텍처 준수사항 명시
- [ ] 🔧 Provider 패턴 필요성 판단
- [ ] 🚫 금지사항 명시
- [ ] 📚 참고 코드 지정
- [ ] 🧪 검증 방법 포함

**모두 체크했다면 → 완벽한 요청! 🎉**

---

## 📝 요청 예시 모음

### 실전 예시 #1: 오늘의 올바른 요청

```
PresentationContainer의 Provider 패턴을 검토하고 개선해주세요.

📊 현재 문제:
- NavigationBar, StatusBar 등 단순 UI 위젯까지 Factory 래핑
- 불필요한 복잡도 증가

🎯 개선 방향:
docs/tasks/active/DI_Pattern_Consistency_Improvement_Plan.md의
"Provider 사용 기준"을 참고하여:

✅ Provider 유지:
- theme_service (동적 생성 필요)
- api_key_service (보안, 리소스 관리)

❌ Provider 제거:
- navigation_service → 직접 생성
- status_bar_service → 직접 생성
- window_state_service → 직접 생성
- menu_service → 직접 생성

이유: 상태 없는 단순 UI 컴포넌트는 직접 생성이 적절

🚫 주의사항:
- 기존 동작 100% 보존
- MainWindow에서 사용하는 부분도 함께 수정
- 아키텍처 위반 없도록
```

---

## 🏆 성공 사례

### Before (잘못된 요청)

```
"UI 위젯들을 DI 컨테이너에 등록해줘"
```

**결과:**

- 모든 위젯이 불필요하게 Factory로 래핑됨
- 코드 복잡도 증가
- 성능 오버헤드 발생

---

### After (올바른 요청)

```
"UI 위젯들의 DI 필요성을 검토 후 적절하게 구성해줘.

판단 기준:
- 리소스 관리 필요? → Provider
- 상태 없는 단순 위젯? → 직접 생성
- 환경별 구현 다름? → Provider
- 단순 UI 컴포넌트? → 직접 생성

각 위젯별 판단 근거를 주석으로 남겨줘."
```

**결과:**

- 필요한 것만 Provider 사용
- 코드 단순화
- 성능 최적화
- 명확한 문서화

---

> **핵심 요약**:
>
> 1. **구체적으로** 요청하라 (파일 경로, 레이어, 목적)
> 2. **금지사항을** 명시하라 (안티패턴 방지)
> 3. **이유를** 설명하라 (코파일럿 학습 유도)
> 4. **검증을** 요청하라 (자체 품질 확인)
> 5. **단계별로** 진행하라 (복잡한 작업 분할)
>
> 좋은 요청 = 정확한 코드 = 행복한 개발! 😊

---

**문서 버전**: v1.0
**최종 수정**: 2025-10-02
**작성자**: GitHub Copilot (실전 사례 기반)
**기반 사례**: DI 패턴 과잉 적용 분석 및 개선
