# 🗺️ 시스템 전체 지도

> **비개발자를 위한 업비트 자동매매 시스템 구조 완전 이해**
>
> "코드가 어디에 있고, 어떻게 연결되는지 한눈에 보기"

---

## 📋 문서 정보

- **대상 독자**: 비개발자, 프로젝트 관리자
- **읽는 시간**: 30-40분
- **목적**: 전체 시스템 구조와 주요 패턴 이해
- **이전 단계**: [01_왜_이렇게_복잡한가요.md](01_왜_이렇게_복잡한가요.md)
- **다음 단계**: [03_꼭_알아야_할_3가지.md](03_꼭_알아야_할_3가지.md)

---

## 🎯 핵심 메시지

> **"복잡해 보이지만, 각 층이 명확한 역할을 가진 체계적인 구조입니다."**

5개 핵심 패턴만 이해하면 → 전체 시스템 구조 파악 가능!

---

## 📖 목차

1. [고층 빌딩으로 보는 시스템 구조](#-고층-빌딩으로-보는-시스템-구조)
2. [5개 핵심 패턴 빠른 요약](#-5개-핵심-패턴-빠른-요약)
3. [폴더 구조와 역할 매핑](#-폴더-구조와-역할-매핑)
4. [실제 코드에서 패턴 찾기](#-실제-코드에서-패턴-찾기)
5. [파일 위치 판단 가이드](#-파일-위치-판단-가이드)

---

## 🏙️ 고층 빌딩으로 보는 시스템 구조

### 전체 계층 개요

```
┌─────────────────────────────────────────────────────────┐
│  🖥️  10층: UI (Presentation Layer)                      │
│  "사용자가 보는 화면"                                      │
│  - 버튼, 입력창, 차트                                      │
│  - 📁 ui/desktop/screens/                                │
├─────────────────────────────────────────────────────────┤
│  🎯  8층: Presenter (MVP 패턴)                           │
│  "화면과 비즈니스 로직 중간 관리자"                         │
│  - 사용자 입력 처리                                        │
│  - 📁 presentation/presenters/                           │
├─────────────────────────────────────────────────────────┤
│  💼  6층: Application Services (비즈니스 로직)            │
│  "실제 업무 처리"                                          │
│  - 전략 생성, API 호출, 데이터 처리                         │
│  - 📁 application/services/                              │
├─────────────────────────────────────────────────────────┤
│  📊  4층: Domain (핵심 규칙)                              │
│  "자동매매의 핵심 개념과 규칙"                             │
│  - 전략, 트리거, 주문 규칙                                 │
│  - 📁 domain/entities/ domain/services/                  │
├─────────────────────────────────────────────────────────┤
│  🔧  2층: Infrastructure (기술 인프라)                    │
│  "DB, API, 로깅 등 기술적 구현"                            │
│  - 데이터 저장, 업비트 API 연동                            │
│  - 📁 infrastructure/repositories/                        │
└─────────────────────────────────────────────────────────┘

🔑 핵심 규칙: 위에서 아래로만 요청 가능 (아래에서 위로 직접 호출 금지)
```

### 층간 이동 규칙 (매우 중요!)

```
✅ 허용되는 흐름 (위 → 아래)
UI → Presenter → Application → Domain → Infrastructure

❌ 금지되는 흐름 (아래 → 위)
Infrastructure → Domain (절대 금지!)
Domain → Application (절대 금지!)
```

**왜 중요한가?**: 아래 층이 위 층을 모르면, 아래 층을 수정해도 위 층이 안전!

---

## 🎯 5개 핵심 패턴 빠른 요약

### 1️⃣ DDD (Domain-Driven Design) - 핵심 규칙 분리

**한 줄 요약**: "자동매매 핵심 개념을 기술 코드와 완전히 분리"

```
📁 domain/               ← 자동매매의 순수한 개념만
├── entities/            ← 전략, 트리거 (핵심 개체)
├── value_objects/       ← 가격, 수량 (불변 값)
└── services/            ← 도메인 규칙 (비즈니스 로직)

🚫 domain 폴더에서 금지된 것:
- import sqlite3       (DB 기술)
- import requests      (네트워크 기술)
- from PyQt6           (UI 기술)
```

**실제 코드 구분법**:

- ✅ Domain: `class Strategy`, `class TriggerRule` (개념)
- ❌ Domain: `save_to_database()`, `call_api()` (기술)

### 2️⃣ MVP (Model-View-Presenter) - 화면 로직 분리

**한 줄 요약**: "화면(View)은 표시만, 로직(Presenter)은 따로"

```
View (바보처럼)              Presenter (똑똑하게)
┌──────────────┐           ┌──────────────┐
│ 버튼, 입력창  │  신호→    │ 입력 검증     │
│ 차트, 목록   │  ←응답    │ 데이터 처리   │
└──────────────┘           └──────────────┘
    말만 전달                   실제 판단

📁 ui/desktop/screens/     📁 presentation/presenters/
```

**코드 구분법**:

```python
# ✅ View (ui/desktop/screens/)
self.save_button.clicked.connect(self.on_save)  # 신호만

# ✅ Presenter (presentation/presenters/)
def handle_save(self, data):
    if self.validate(data):  # 실제 로직
        self.service.save(data)
```

### 3️⃣ DI (Dependency Injection) - 자동 배달 시스템

**한 줄 요약**: "필요한 부품을 자동으로 가져다주는 시스템"

```
스마트 창고 (ApplicationContainer)
┌─────────────────────────────┐
│ API 키 서비스                │
│ 로깅 서비스      ←@inject    │ 자동 배달
│ DB 연결                      │
└─────────────────────────────┘

📁 infrastructure/dependency_injection/container.py
```

**코드 구분법**:

```python
# ✅ DI 사용
@inject
def __init__(self, api_service=Provide["api_key_service"]):
    # 자동으로 api_service 주입됨

# ❌ DI 미사용 (하드코딩)
def __init__(self):
    self.api_service = ApiKeyService()  # 직접 생성
```

### 4️⃣ Factory Pattern - 전문 공장 시스템

**한 줄 요약**: "복잡한 컴포넌트를 완성품으로 만들어주는 공장"

```
공장 (Factory)
┌────────────────────────┐
│ 1. View 생성           │
│ 2. Presenter 생성      │ → 완성된 설정 화면
│ 3. 서비스 연결         │
│ 4. 신호 연결           │
└────────────────────────┘

📁 ui/desktop/common/factories/
```

**코드 구분법**:

```python
# ✅ Factory 사용
factory = SettingsViewFactory(container)
view = factory.create_api_settings()  # 완성품

# ❌ Factory 미사용
view = ApiSettingsView()
presenter = ApiSettingsPresenter(view, service1, service2)
view.set_presenter(presenter)  # 수동 조립
```

### 5️⃣ QAsync - 비동기 실행 환경

**한 줄 요약**: "UI와 네트워크를 동시에 처리하는 실행 엔진"

```
단일 이벤트 루프 (QAsync)
┌───────────────────────────────┐
│  UI 버튼 클릭                  │
│     ↓                         │
│  네트워크 요청 (비동기)         │
│     ↓                         │
│  UI 업데이트 (결과 표시)        │
└───────────────────────────────┘

📁 infrastructure/runtime/app_kernel.py
```

**코드 구분법**:

```python
# ✅ QAsync 패턴
@asyncSlot()
async def on_button_click(self):
    result = await self.api_call()  # 비동기 대기

# ❌ 스레드 사용 (금지)
def on_button_click(self):
    thread = threading.Thread(target=self.api_call)  # 위험!
```

---

## 📂 폴더 구조와 역할 매핑

### 전체 폴더 구조 (핵심만)

```
upbit_auto_trading/
│
├── 🖥️ ui/desktop/                    [10층: UI]
│   ├── screens/                       화면들
│   │   ├── settings/                  설정 화면
│   │   └── strategy_maker/            전략 제작 화면
│   └── common/                        공통 UI 컴포넌트
│       ├── styles/                    스타일 시스템
│       └── factories/                 Factory 패턴
│
├── 🎯 presentation/                   [8층: MVP Presenter]
│   ├── presenters/                    Presenter 구현
│   └── interfaces/                    View 인터페이스
│
├── 💼 application/                    [6층: 비즈니스 로직]
│   ├── services/                      애플리케이션 서비스
│   └── dto/                           데이터 전송 객체
│
├── 📊 domain/                         [4층: 핵심 규칙]
│   ├── entities/                      핵심 개체 (전략, 트리거)
│   ├── value_objects/                 불변 값 (가격, 수량)
│   └── services/                      도메인 서비스
│
└── 🔧 infrastructure/                 [2층: 기술 인프라]
    ├── repositories/                  데이터 저장
    ├── external_apis/                 업비트 API
    ├── runtime/                       QAsync 시스템
    ├── events/                        이벤트 시스템
    └── dependency_injection/          DI 컨테이너
```

### 폴더별 역할 요약표

| 폴더 | 계층 | 역할 | 포함 가능 | 포함 불가 |
|------|------|------|----------|----------|
| `ui/desktop/` | Presentation | 화면 표시 | PyQt6, 시그널 | 비즈니스 로직, DB |
| `presentation/` | Presenter | UI 로직 | 검증, 변환 | DB, API 직접 호출 |
| `application/` | Service | 업무 처리 | 조합 로직 | DB 직접 접근 |
| `domain/` | Core | 핵심 규칙 | 순수 로직만 | 외부 기술 전부 |
| `infrastructure/` | Tech | 기술 구현 | DB, API 등 | 도메인 개념 |

---

## 🔍 실제 코드에서 패턴 찾기

### 패턴 인식 가이드

#### 1. DDD 패턴 찾기

**위치**: `domain/` 폴더
**특징**: 기술 import 없음, 순수한 개념만

```python
# ✅ 올바른 Domain 코드
# 파일: domain/entities/strategy.py
class Strategy:
    """전략 엔티티 (순수한 개념)"""
    def __init__(self, name: str, rules: List[TriggerRule]):
        self.name = name
        self.rules = rules

    def add_rule(self, rule: TriggerRule):
        """규칙 추가 (도메인 로직)"""
        if self.is_valid_rule(rule):
            self.rules.append(rule)

# ❌ 잘못된 Domain 코드 (기술 침투)
class Strategy:
    def save_to_database(self):  # 🚨 DB 기술이 domain에!
        conn = sqlite3.connect("db.sqlite3")
```

#### 2. MVP 패턴 찾기

**위치**: `ui/desktop/` + `presentation/presenters/`
**특징**: View는 신호만, Presenter는 로직

```python
# ✅ View (ui/desktop/screens/settings/api_settings_view.py)
class ApiSettingsView(QWidget):
    # 신호 정의
    save_requested = pyqtSignal(str, str)

    def on_save_button_clicked(self):
        """버튼 클릭 시 신호만 발생"""
        api_key = self.input_api_key.text()
        secret_key = self.input_secret_key.text()
        self.save_requested.emit(api_key, secret_key)  # 신호만!

# ✅ Presenter (presentation/presenters/api_settings_presenter.py)
class ApiSettingsPresenter:
    def handle_save(self, api_key: str, secret_key: str):
        """실제 로직 처리"""
        if self.validate_keys(api_key, secret_key):  # 검증
            self.api_service.save(api_key, secret_key)  # 저장
            self.view.show_success_message()  # 결과 표시
```

#### 3. DI 패턴 찾기

**위치**: `@inject` 데코레이터 사용
**특징**: `Provide["서비스명"]` 문법

```python
# ✅ DI 패턴
from dependency_injector.wiring import inject, Provide

class StrategyService:
    @inject
    def __init__(
        self,
        repository=Provide["strategy_repository"],
        logger=Provide["application_logging_service"]
    ):
        self.repository = repository
        self.logger = logger
```

#### 4. Factory 패턴 찾기

**위치**: `factories/` 폴더, `create_xxx` 메서드
**특징**: 복잡한 객체 조립

```python
# ✅ Factory 패턴
class SettingsViewFactory:
    def create_api_settings(self):
        """완성된 API 설정 컴포넌트 생성"""
        # 1. View 생성
        view = ApiSettingsView()

        # 2. Presenter 생성 (서비스 주입)
        presenter = ApiSettingsPresenter(
            view=view,
            api_service=self._api_service
        )

        # 3. 연결
        view.save_requested.connect(presenter.handle_save)

        return view  # 완성품
```

#### 5. QAsync 패턴 찾기

**위치**: `@asyncSlot()` 데코레이터
**특징**: `async`/`await` 키워드

```python
# ✅ QAsync 패턴
from qasync import asyncSlot

class TradingWidget(QWidget):
    @asyncSlot()
    async def on_execute_button_clicked(self):
        """비동기 실행"""
        self.button.setEnabled(False)

        # 네트워크 요청 (UI 블록 안 됨)
        result = await self.trading_service.execute_order()

        # UI 업데이트
        self.result_label.setText(f"결과: {result}")
        self.button.setEnabled(True)
```

---

## 🎯 파일 위치 판단 가이드

### 새 코드를 어디에 만들지 판단하기

#### Step 1: "무엇을 하는 코드인가?" 질문

```
┌─────────────────────────────────────────┐
│ 화면에 보여주는 코드?                    │
│ → ui/desktop/screens/                   │
├─────────────────────────────────────────┤
│ 사용자 입력 처리하는 코드?               │
│ → presentation/presenters/              │
├─────────────────────────────────────────┤
│ 비즈니스 로직 (전략, 주문 처리)?         │
│ → application/services/                 │
├─────────────────────────────────────────┤
│ 핵심 규칙 (전략이란?, 트리거란?)?        │
│ → domain/entities/                      │
├─────────────────────────────────────────┤
│ DB 저장, API 호출 등 기술?               │
│ → infrastructure/                       │
└─────────────────────────────────────────┘
```

#### Step 2: "어떤 기술을 사용하는가?" 확인

```python
# PyQt6 import 있음 → ui/desktop/
from PyQt6.QtWidgets import QWidget

# @inject 있고 비즈니스 로직 → application/services/
@inject
class TradingService:

# 기술 import 없음, 순수 개념 → domain/
class Strategy:
    def __init__(self, name: str):

# sqlite3, API 호출 → infrastructure/
import sqlite3
class StrategyRepository:
```

#### Step 3: "의존성 방향 확인"

```
✅ 올바른 방향:
ui → presentation → application → domain ← infrastructure

❌ 잘못된 방향:
domain → infrastructure (절대 금지!)
```

### 실전 예시: "알림 기능 추가하기"

**요구사항**: "거래 체결 시 카카오톡 알림"

```
1. 알림 UI 버튼 추가
   📁 ui/desktop/screens/settings/notification_view.py

2. 알림 설정 Presenter
   📁 presentation/presenters/notification_presenter.py

3. 알림 전송 서비스
   📁 application/services/notification_service.py

4. 거래 체결 이벤트 (도메인 개념)
   📁 domain/events/order_executed_event.py

5. 카카오 API 연동 (기술 구현)
   📁 infrastructure/notifications/kakao_notifier.py
```

---

## 🔧 코파일럿 실수 판단 가이드

### 코파일럿이 잘못된 위치에 코드를 만들었을 때

#### 체크리스트

- [ ] **Domain에 기술 import 있는가?**

  ```python
  # 🚨 문제 발견!
  # domain/entities/strategy.py
  import sqlite3  # Domain에 DB 기술!
  ```

- [ ] **View에 비즈니스 로직 있는가?**

  ```python
  # 🚨 문제 발견!
  # ui/desktop/screens/settings_view.py
  def save_settings(self):
      if self.validate_complex_rule():  # View에 로직!
  ```

- [ ] **Infrastructure가 Domain 참조하는가?**

  ```python
  # 🚨 문제 발견!
  # infrastructure/repositories/strategy_repository.py
  from domain.services.strategy_service import StrategyService
  ```

#### 수정 요청 방법

```
"코파일럿, domain/entities/strategy.py 파일에서
sqlite3 import를 발견했어요.

domain 레이어는 기술 의존성이 없어야 하는데,
DB 저장 로직을 infrastructure/repositories/ 로
옮겨주세요."
```

---

## 🎓 학습 정리

### 5개 패턴 핵심 요약

| 패턴 | 한 줄 요약 | 폴더 위치 | 코드 특징 |
|------|-----------|----------|----------|
| **DDD** | 핵심 개념 분리 | `domain/` | 기술 import 없음 |
| **MVP** | 화면과 로직 분리 | `ui/` + `presentation/` | 시그널 기반 통신 |
| **DI** | 자동 의존성 주입 | `@inject` | `Provide[""]` 문법 |
| **Factory** | 완성품 생성 | `factories/` | `create_xxx()` 메서드 |
| **QAsync** | 비동기 실행 | `@asyncSlot()` | `async`/`await` |

### 폴더 판단 빠른 체크

```
기술 import 있나? → 있음: infrastructure/, 없음: domain/
화면 코드인가? → 예: ui/desktop/
사용자 입력 처리? → 예: presentation/presenters/
비즈니스 로직? → 예: application/services/
```

---

## 🚀 다음 단계

이제 전체 구조를 이해했다면:

1. ✅ [01_왜_이렇게_복잡한가요.md](01_왜_이렇게_복잡한가요.md) ← 동기 이해
2. ✅ [02_시스템_전체_지도.md](02_시스템_전체_지도.md) ← 현재 문서
3. ➡️ [03_꼭_알아야_할_3가지.md](03_꼭_알아야_할_3가지.md) ← 핵심 패턴 집중 학습

---

## 📞 질문 & 확인

### 이해도 체크

- ✅ 5개 층 구조를 설명할 수 있나요?
- ✅ 새 파일을 어디에 만들지 판단할 수 있나요?
- ✅ 코파일럿 실수를 발견할 수 있나요?

### 어려운 부분이 있다면

코파일럿에게 질문하세요:

```
"02번 문서에서 [특정 패턴]이 어려워요.
실제 코드 예시로 더 설명해주세요."
```

---

> **핵심 요약**:
>
> 1. **5개 층 구조** (UI → Presenter → Service → Domain ← Infrastructure)
> 2. **5개 핵심 패턴** (DDD, MVP, DI, Factory, QAsync)
> 3. **폴더 = 역할** (위치만 봐도 무슨 코드인지 알 수 있음)
> 4. **의존성 방향** (위→아래만, 아래→위 금지)
>
> 이것만 기억하면 전체 시스템을 이해할 수 있습니다! 🎯

---

**문서 버전**: v1.0
**최종 수정**: 2025-10-02
**작성자**: GitHub Copilot (비개발자 교육용)
