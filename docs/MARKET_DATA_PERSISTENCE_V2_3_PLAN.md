# 마켓 데이터 영속화 시스템 V2.3 기획서

## 🎯 프로젝트 개요
**목표**: 업비트 API 200개 제한을 활용한 효율적인 다중 타임프레임 데이터 관리 시스템

**배경**: 사용자 워크플로우 (스크리너 → 백테스팅 → 실거래)에서 요구되는 대용량 다중 타임프레임 데이터 처리

## 📊 핵심 요구사항

### 사용 시나리오별 요구사항
1. **스크리너**: 1시간봉 30일 200종목 → 720개 × 200종목 = 144,000 데이터포인트
2. **백테스팅**: 다중 타임프레임 (15분/1시간/4시간봉) 1년치 데이터
3. **실거래**: 5종목 3타임프레임 실시간 모니터링

### 성능 목표
- **스크리너**: 30초 이내 완료 (기존 100초 → 70% 단축)
- **백테스팅**: 5분 이내 데이터 준비 (네트워크 요청 90% 감소)
- **실거래**: 1초 이하 지연시간 (리소스 사용량 60% 감소)

## 🏗️ 아키텍처 설계

### 3-파일 구조 (책임 중심 분리)
```
data_persistence/
├── collection_engine.py    (200 lines) - 외부 API 수집 전담
├── timeframe_calculator.py (160 lines) - 타임프레임 변환 전문
└── cache_manager.py        (180 lines) - 다층 캐시 관리
```

### 핵심 설계 원칙
1. **단일 책임**: 각 파일이 하나의 명확한 역할
2. **단방향 의존성**: 순환 참조 없는 깔끔한 구조
3. **API 최적화**: 200개 제한 기반 배치 처리
4. **메모리 효율성**: 1분봉 기준 수집 후 상위 타임프레임 계산

## 🔄 데이터 흐름

### 기본 흐름
```
1. cache_manager.get() → 캐시에서 데이터 확인
2. collection_engine.collect() → 부족분만 API로 수집
3. timeframe_calculator.convert() → 타임프레임 계산
4. cache_manager.store() → 계산 결과 캐시 저장
```

### 캐시 계층 구조
- **L1 (메모리)**: 실시간 데이터, 최신 1시간, <100ms 응답
- **L2 (SSD)**: 최근 7일 데이터, 압축 저장, <1초 응답
- **L3 (DB)**: 장기 데이터, 최대 압축, <5초 응답

## 🎯 핵심 최적화 전략

### 1. 타임프레임 통합 수집
- 1분봉으로 수집 → 메모리에서 상위 타임프레임 계산
- 네트워크 요청 90% 감소
- 데이터 정합성 보장

### 2. 지능형 배치 처리
- 200개 청크 단위 최적화
- 병렬 수집 (API 제한 내)
- 중복 요청 자동 제거

### 3. 적응형 캐싱
- 사용 패턴 기반 캐시 전략
- 스크리너용 vs 백테스팅용 차별화
- 메모리 사용량 자동 조절

## ✅ 성공 기준 및 검증

### 성능 지표
- **처리 속도**: 목표 달성률 90% 이상
- **API 효율성**: 요청 수 70% 이상 감소
- **메모리 사용량**: 2GB 이하 유지
- **캐시 히트율**: 80% 이상

### 테스트 커버리지
- **단위 테스트**: 각 모듈별 15개 이상
- **통합 테스트**: 실제 워크플로우 기반 6개
- **성능 테스트**: 대용량 처리 시나리오 3개
- **총 목표**: 21개 이상 테스트 통과

## 🚀 개발 계획

### Phase 2.3-1: 기본 구조 (3일)
- 3개 파일 기본 구조 생성
- 핵심 인터페이스 정의
- 기본 테스트 프레임워크

### Phase 2.3-2: 수집 엔진 (2일)
- collection_engine.py 구현
- API 최적화 및 에러 처리
- 수집 관련 테스트

### Phase 2.3-3: 계산 엔진 (2일)
- timeframe_calculator.py 구현
- OHLCV 집계 로직
- 타임프레임 변환 테스트

### Phase 2.3-4: 캐시 시스템 (3일)
- cache_manager.py 구현
- 3층 캐시 구조
- 성능 및 통합 테스트

## 🔍 리스크 및 대응

### 주요 리스크
1. **메모리 부족**: 대용량 데이터 처리 시
2. **API 제한**: 예상보다 많은 요청 필요
3. **계산 복잡도**: 타임프레임 변환 성능

### 대응 방안
1. **스트리밍 처리**: 메모리 효율적 배치 처리
2. **스마트 캐싱**: 중복 요청 최소화
3. **최적화된 알고리즘**: pandas 기반 벡터화 연산

---

**문서 버전**: v1.0
**작성일**: 2025-08-20
**검토 필요**: 구현 완료 후 성능 지표 업데이트
