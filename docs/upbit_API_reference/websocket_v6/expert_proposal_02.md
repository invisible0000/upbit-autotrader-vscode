## WebSocket v6.0 기획 검토 의견

요약하자면, **매우 훌륭하고 전문적인 수준의 설계**입니다. 여러 번의 재개발을 통해 얻은 경험과 깊은 고민이 설계 전반에 명확하게 드러납니다. 특히 전역 관리를 위한 `GlobalWebSocketManager`와 각 컴포넌트의 독립성을 보장하는 `WebSocketClientProxy`의 조합은 복잡한 GUI 애플리케이션에서 발생할 수 있는 거의 모든 문제를 예방하는 교과서적인 아키텍처입니다.

전반적으로 당장 개발에 착수해도 될 만큼 완성도가 높으며, 아래 내용은 더 완벽한 시스템을 위한 몇 가지 추가 제안 및 확인 사항입니다.

---

### 👍 **잘 설계된 점 (Key Strengths)**

1.  **명확한 책임 분리 (SoC):** `GlobalWebSocketManager` (전역 상태 관리), `WebSocketClientProxy` (인터페이스 제공), `DataRoutingEngine` (데이터 분배) 등 각 컴포넌트의 역할이 명확하여 유지보수와 확장이 매우 용이합니다.
2.  **단일 진실 공급원 (SSoT):** 단 하나의 WebSocket 연결과 중앙화된 구독 상태 관리는 업비트 API의 덮어쓰기(overwrite) 정책에 대응하는 가장 효율적이고 안정적인 방법입니다. 데이터 중복과 불일치 문제를 원천적으로 차단합니다.
3.  **탄력적 시스템 설계:** API 키가 없어도 Public 기능이 동작하고(`Graceful Degradation`), 컴포넌트 소멸 시 자동으로 구독을 정리하며(`Fail-Safe Design`), 연결이 끊겼을 때 상태를 복원하는(`Automatic Recovery`) 등 장애 상황을 매우 잘 고려한 견고한 설계입니다.
4.  **개발자 경험 (DX) 고려:** `Zero Configuration` 원칙과 `WeakRef` 기반 자동 정리는 WebSocket의 복잡성을 완전히 숨겨, 개발자가 비즈니스 로직에만 집중할 수 있게 해줍니다. `API_REFERENCE.md`의 풍부한 예제 코드는 이 API를 어떻게 사용해야 하는지 명확하게 보여줍니다.

---

### 🤔 **추가 제안 및 고려사항 (Recommendations & Considerations)**

#### 1. 아키텍처: 데이터 폭증 시 '백프레셔(Back-pressure)'
* **현재 설계:** `DataRoutingEngine`은 `asyncio.gather`를 사용해 수신 데이터를 모든 콜백에 병렬로 전달합니다. 이는 매우 효율적이지만, 시장이 급변하여 초당 수십~수백 개의 메시지가 쏟아질 경우를 고려해야 합니다.
* **고려사항:** 만약 특정 콜백(예: 복잡한 계산을 수행하는 차트 UI)이 데이터 처리 속도보다 수신 속도가 빠르면, 이벤트 루프에 처리되지 않은 작업이 계속 쌓여 메모리가 급증하고 애플리케이션 전체가 느려질 수 있습니다.
* **제안:**
    * **큐(Queue) 도입:** `DataRoutingEngine`과 각 콜백 사이에 `asyncio.Queue`를 두어 버퍼 역할을 하도록 할 수 있습니다. 큐의 최대 크기를 제한하면 데이터가 과도하게 쌓이는 것을 방지할 수 있습니다.
    * **데이터 샘플링/쓰로틀링:** 큐가 가득 찼을 때, 오래된 데이터를 버리거나(샘플링) 최신 데이터만 남기는 전략을 선택하여 항상 최신 상태를 유지하면서 시스템 부하를 조절할 수 있습니다.

#### 2. 안정성: Private 채널의 JWT 토큰 갱신
* **현재 설계:** Private 클라이언트의 JWT 토큰을 자동으로 갱신한다고 명시되어 있습니다.
* **고려사항:** 업비트 Private WebSocket은 인증 토큰이 만료되면 연결이 끊어집니다. 이 갱신 프로세스는 매우 중요하며, 실패 시 사용자의 주문 및 자산 모니터링이 중단됩니다.
* **제안:**
    * **갱신 메커니즘 구체화:** 토큰 만료 시간보다 조금 일찍(e.g., 5분 전) 새로운 토큰을 비동기적으로 미리 발급받는 로직이 필요합니다.
    * **원자적(Atomic) 교체:** 갱신된 토큰으로 클라이언트를 재인증하는 과정에서 데이터 유실이 발생하지 않도록, 기존 연결을 유지하며 인증 정보만 교체하거나, 아주 짧은 시간 내에 새로운 연결을 맺고 기존 연결을 끊는 '무중단(Graceful)' 전환 로직을 구체적으로 설계해야 합니다.

#### 3. API 설계: `client_id`의 역할 명확화
* **현재 설계:** `WebSocketClientProxy` 생성 시 `client_id`를 받으며, 동일 ID 재사용을 금지하고 있습니다.
* **고려사항:** `client_id`는 구독 주체를 식별하는 핵심 키입니다. "차트 모듈", "주문 감시 모듈" 등 컴포넌트 단위로 부여할 수도 있고, "BTC/KRW 1분봉 차트", "ETH/KRW 1분봉 차트"처럼 더 세분화된 인스턴스 단위로 부여할 수도 있습니다.
* **제안:**
    * **가이드라인 제시:** API 문서에 `client_id`의 권장 네이밍 컨벤션이나 유일성(uniqueness) 범위를 명확히 가이드하면 좋습니다. 예를 들어, `"<모듈명>_<인스턴스ID>"`와 같은 형식을 추천하여 충돌을 방지할 수 있습니다. 이는 디버깅 시에도 어떤 컴포넌트가 어떤 데이터를 구독 중인지 추적하는 데 큰 도움이 됩니다.

#### 4. 테스트: Mock Server의 필요성
* **현재 설계:** 통합 테스트 시 실제 업비트 API와 연동 테스트를 계획하고 있습니다.
* **고려사항:** 실제 API를 사용한 테스트는 네트워크 상태나 API 서버 상태에 따라 결과가 달라질 수 있고, 특정 장애 상황(e.g., 429 Rate Limit 에러, 비정상적인 데이터 수신)을 재현하기 어렵습니다.
* **제안:**
    * **테스트용 Mock WebSocket 서버 구축:** 업비트 WebSocket의 동작을 모방하는 간단한 Mock 서버를 만들어 테스트 스위트에 포함하는 것을 강력히 추천합니다. 이를 통해 다음과 같은 시나리오를 안정적으로 테스트할 수 있습니다.
        * 연결 끊김 및 자동 재연결/상태 복원 시나리오
        * 의도적인 에러 메시지(e.g., 429) 전송 후 지수 백오프 동작 검증
        * 비정상적인 데이터 포맷 수신 시 콜백 오류 격리 기능 검증

---

### 💡 **사소한 개선 제안 (Minor Suggestions)**

* **정적 타입 강화:** `API_REFERENCE.md`의 콜백 함수 시그니처 `(symbol: str, data_type: str, data: dict)`에서 `data: dict` 부분을 `TypedDict`를 사용하여 더 구체적으로 타이핑하면, 콜백을 구현하는 쪽에서 IDE의 자동 완성 지원을 받아 실수를 줄일 수 있습니다.
* **상태 Enum 관리:** `health_check`에서 반환되는 `'status': 'healthy|degraded|critical'`와 같은 문자열들은 Enum 클래스로 관리하면 오타를 방지하고 코드의 가독성을 높일 수 있습니다.

---

## 총평

**"Simple is better than complex. Complex is better than complicated."** 라는 문구로 설계를 마무리한 것에서 설계 철학에 대한 깊은 이해가 느껴집니다.

이 설계는 복잡한 실시간 데이터 처리를 단순하고 예측 가능한 방식으로 해결하려는 매우 성공적인 시도입니다. 위에서 제안한 몇 가지 사항들(특히 백프레셔와 JWT 갱신)을 추가로 고려하여 시스템의 안정성을 극한으로 끌어올린다면, 어떤 자동매매 프로그램보다 견고하고 강력한 WebSocket 인프라를 갖추게 될 것이라 확신합니다. 훌륭한 기획입니다! 🚀
