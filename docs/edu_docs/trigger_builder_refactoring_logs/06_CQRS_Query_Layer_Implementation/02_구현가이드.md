# CQRS Query Layer 구현 가이드

## 🎯 구현 목표
Command와 Query 책임을 분리하여 복잡한 읽기 쿼리를 최적화하고, UI 요구사항에 맞는 전용 Query Service를 구축합니다.

## 📐 아키텍처 설계 원칙

### 1. **Layer 분리 원칙**
```
Application Layer
├── Commands (쓰기 작업)
└── Queries (읽기 작업) ← 이번 구현 범위
    ├── DTO: UI 최적화된 데이터 구조
    ├── Handlers: 비즈니스 로직 캡슐화
    ├── Dispatcher: 요청 라우팅
    └── Service: 파사드 패턴
```

### 2. **책임 분리 매트릭스**

| 컴포넌트 | 책임 | 금지사항 |
|---------|------|----------|
| Query DTO | UI 요구사항 반영 | Domain 로직 포함 |
| Query Handler | 비즈니스 로직 처리 | Infrastructure 직접 접근 |
| Query Dispatcher | 요청 라우팅 | 비즈니스 로직 처리 |
| Query Service | 통합 인터페이스 제공 | Handler 로직 직접 구현 |

## 🛠️ 단계별 구현 가이드

### Step 1: 폴더 구조 생성
```bash
application/queries/
├── dto/                    # Query 전용 DTO
├── handlers/              # Query Handler 구현
├── query_dispatcher.py    # 요청 라우팅
├── query_service.py       # 파사드 패턴
└── query_container.py     # 의존성 주입
```

### Step 2: Query DTO 설계
```python
@dataclass
class StrategyListQuery:
    """UI 필터링 요구사항을 반영한 Query DTO"""
    page: int = 1
    page_size: int = 20
    status_filter: Optional[StrategyStatus] = None
    search_text: Optional[str] = None
    sort_by: SortField = SortField.CREATED_AT
    sort_direction: SortDirection = SortDirection.DESC
    date_range: Optional[DateRange] = None

@dataclass
class StrategyListResponse:
    """UI 표시를 위한 응답 DTO"""
    strategies: List[StrategyDTO]
    total_count: int
    page: int
    page_size: int
    has_next: bool
    performance_metrics: QueryPerformanceMetrics
```

**설계 가이드라인**:
- UI 컴포넌트의 실제 필요사항 반영
- 페이징, 필터링, 정렬을 하나의 객체로 통합
- 응답에 성능 메트릭 포함으로 모니터링 지원

### Step 3: Query Handler 구현
```python
class StrategyListQueryHandler(BaseQueryHandler[StrategyListQuery, StrategyListResponse]):
    """전략 목록 조회 비즈니스 로직"""

    def __init__(self, strategy_repository: StrategyRepository):
        self.strategy_repository = strategy_repository

    def handle(self, query: StrategyListQuery) -> StrategyListResponse:
        start_time = time.time()

        # 1. 입력 유효성 검증
        self._validate_query(query)

        # 2. Repository 호출
        strategies, total_count = self.strategy_repository.find_strategies_with_filters(
            status=query.status_filter,
            search_text=query.search_text,
            sort_by=query.sort_by,
            sort_direction=query.sort_direction,
            date_range=query.date_range,
            offset=(query.page - 1) * query.page_size,
            limit=query.page_size
        )

        # 3. DTO 변환
        strategy_dtos = [StrategyDTO.from_entity(s) for s in strategies]

        # 4. 성능 메트릭 계산
        execution_time = time.time() - start_time
        metrics = QueryPerformanceMetrics(
            execution_time=execution_time,
            query_type="StrategyList",
            record_count=len(strategy_dtos)
        )

        return StrategyListResponse(
            strategies=strategy_dtos,
            total_count=total_count,
            page=query.page,
            page_size=query.page_size,
            has_next=total_count > query.page * query.page_size,
            performance_metrics=metrics
        )
```

**구현 가이드라인**:
- 입력 유효성 검증 필수
- Repository 패턴으로 데이터 접근 추상화
- 성능 메트릭 자동 계산
- Domain Entity → DTO 변환 명시적 처리

### Step 4: Query Dispatcher 구현
```python
class QueryDispatcher:
    """Query와 Handler 매핑 관리"""

    def __init__(self):
        self._handlers: Dict[Type, Callable] = {}

    def register_handler(self, query_type: Type[TQuery], handler: Callable[[TQuery], TResponse]):
        """Handler 등록"""
        self._handlers[query_type] = handler

    def dispatch(self, query: TQuery) -> TResponse:
        """Query 실행"""
        query_type = type(query)
        if query_type not in self._handlers:
            raise ValueError(f"No handler registered for {query_type}")

        handler = self._handlers[query_type]
        return handler(query)
```

### Step 5: Query Service Facade 구현
```python
class QueryService:
    """고수준 Query 실행 인터페이스"""

    def __init__(self, dispatcher: QueryDispatcher):
        self.dispatcher = dispatcher

    def get_strategy_list(self, query: StrategyListQuery) -> StrategyListResponse:
        """전략 목록 조회"""
        return self.dispatcher.dispatch(query)

    def get_strategy_detail(self, query: StrategyDetailQuery) -> StrategyDetailResponse:
        """전략 상세 조회"""
        return self.dispatcher.dispatch(query)
```

### Step 6: 의존성 주입 Container 구현
```python
class QueryServiceContainer:
    """Query Layer 의존성 관리"""

    def __init__(self):
        self._query_service = None
        self._dispatcher = None

    def get_query_service(self) -> QueryService:
        """Query Service 싱글톤 제공"""
        if self._query_service is None:
            self._query_service = self._create_query_service()
        return self._query_service

    def _create_query_service(self) -> QueryService:
        """Query Service 생성 및 Handler 등록"""
        dispatcher = QueryDispatcher()

        # Handler 등록
        strategy_handler = StrategyListQueryHandler(MockStrategyRepository())
        dispatcher.register_handler(StrategyListQuery, strategy_handler.handle)

        return QueryService(dispatcher)
```

## 🧪 테스트 전략

### 1. **단위 테스트 - Handler 독립 검증**
```python
def test_strategy_list_query_handler():
    # Mock Repository 생성
    mock_repo = Mock()
    mock_repo.find_strategies_with_filters.return_value = ([mock_strategy], 1)

    # Handler 테스트
    handler = StrategyListQueryHandler(mock_repo)
    result = handler.handle(query)

    # 검증
    assert len(result.strategies) == 1
    assert result.total_count == 1
    mock_repo.find_strategies_with_filters.assert_called_once()
```

### 2. **통합 테스트 - 전체 플로우 검증**
```python
def test_query_service_integration():
    # Container를 통한 전체 플로우 테스트
    container = QueryServiceContainer()
    query_service = container.get_query_service()

    # 실제 Query 실행
    query = StrategyListQuery(page=1, page_size=10)
    result = query_service.get_strategy_list(query)

    # 전체 플로우 검증
    assert result.strategies is not None
    assert result.performance_metrics.execution_time > 0
```

## 📊 성능 고려사항

### 1. **Query 최적화 체크리스트**
- [ ] 적절한 페이징 크기 설정 (기본 20개)
- [ ] 불필요한 JOIN 회피
- [ ] 인덱스 활용 가능한 필터링 조건
- [ ] 성능 메트릭 모니터링

### 2. **메모리 관리**
- 대용량 결과셋에 대한 스트리밍 처리 고려
- DTO 변환 시 불필요한 데이터 제외
- Cache 전략으로 반복 쿼리 최적화

## 🔍 디버깅 가이드

### 자주 발생하는 문제와 해결책

1. **Handler 등록 누락**
   ```python
   # 증상: ValueError: No handler registered for <query_type>
   # 해결: Container에서 Handler 등록 확인
   dispatcher.register_handler(StrategyListQuery, handler.handle)
   ```

2. **Mock Repository 설정 오류**
   ```python
   # 증상: AttributeError: Mock object has no attribute
   # 해결: Mock 메서드 명시적 설정
   mock_repo.find_strategies_with_filters = Mock(return_value=([], 0))
   ```

3. **성능 저하**
   ```python
   # 증상: Query 실행 시간 1초 초과
   # 해결: 성능 메트릭 확인 및 쿼리 최적화
   assert result.performance_metrics.execution_time < 1.0
   ```

## 📋 체크리스트

### 구현 완료 체크리스트
- [ ] Query DTO 설계 완료
- [ ] Query Handler 구현 완료
- [ ] Query Dispatcher 구현 완료
- [ ] Query Service Facade 구현 완료
- [ ] 의존성 주입 Container 구현 완료
- [ ] 단위 테스트 작성 완료
- [ ] 통합 테스트 작성 완료
- [ ] 성능 테스트 통과 (1ms 이내)

### 코드 품질 체크리스트
- [ ] 각 컴포넌트 단일 책임 원칙 준수
- [ ] Domain Entity와 DTO 분리
- [ ] Mock을 활용한 독립적 테스트
- [ ] 성능 메트릭 자동 계산
- [ ] 에러 처리 및 유효성 검증

이 가이드를 따라 구현하면 확장 가능하고 테스트 가능한 CQRS Query Layer를 구축할 수 있습니다.
