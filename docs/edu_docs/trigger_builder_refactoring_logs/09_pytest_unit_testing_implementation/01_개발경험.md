# 📚 pytest 단위테스트 구현 - 개발경험

> **대상**: 주니어 개발자
> **목적**: pytest 단위테스트 시스템 구현 과정에서 얻은 실무 경험 공유
> **작성일**: 2025-08-05

## 🎯 프로젝트 배경

### 초기 상황
- **문제**: TASK-20250803-09에서 pytest 단위테스트가 구현되지 않았음
- **원인**: Infrastructure Layer의 복잡성과 API 키 의존성
- **목표**: 실제 API와 Mock 테스트를 모두 지원하는 완전한 pytest 시스템 구축

### 기술적 도전과제
1. **비동기 API 클라이언트 테스트**: `async/await` 패턴 복잡성
2. **API 키 보안**: 개발/프로덕션 환경별 다른 키 저장 방식
3. **Mock vs Real 테스트**: 두 가지 접근법의 균형점 찾기
4. **인터페이스 일치성**: Mock이 실제 구현과 정확히 일치해야 함

## 💡 핵심 학습 포인트

### 1. pytest 비동기 테스트 패턴
```python
# ✅ 성공 패턴: pytest-asyncio 활용
@pytest.mark.asyncio
async def test_async_method(self, client):
    with patch.object(client, '_make_request', new_callable=AsyncMock) as mock:
        mock.return_value = expected_response
        result = await client.get_markets()
        assert result == expected_data
```

**학습**: `AsyncMock`을 사용해야 `await` 호출이 정상 작동

### 2. 이중 API 키 로딩 전략
```python
def get_test_api_keys():
    # 1순위: .env 파일 (개발 편의성)
    if os.path.exists('.env'):
        return load_from_env()

    # 2순위: 암호화 파일 (프로덕션 보안)
    return load_from_encrypted()
```

**학습**: 개발 편의성과 보안을 모두 만족하는 유연한 접근법

### 3. Mock 객체 정확성의 중요성
```python
# ❌ 실패: 잘못된 파라미터명
ApiResponse(response_time=0.1)

# ✅ 성공: 실제 구현과 일치
ApiResponse(response_time_ms=100.0)
```

**학습**: Mock 테스트의 가치는 실제 구현과의 정확한 일치에 있음

## 🔍 문제 해결 과정

### Phase 1: 문제 진단 (30분)
- **접근법**: 기존 코드 분석 → 문제점 파악 → 해결책 설계
- **발견**: API 키 접근 방법 2가지, Mock 인터페이스 불일치
- **결정**: 단계별 점진적 해결

### Phase 2: API 키 시스템 구축 (45분)
- **도전**: 암호화된 파일 복호화 + .env 파일 동시 지원
- **해결**: `ApiKeyLoader` 유틸리티 클래스로 통합
- **결과**: 두 방식 모두 100% 동작 확인

### Phase 3: Mock 테스트 수정 (60분)
- **도전**: 실제 API 클라이언트 인터페이스 분석 필요
- **과정**: 소스코드 직접 확인 → 파라미터명 수정 → 기본값 수정
- **결과**: 13개 테스트 모두 통과

### Phase 4: 실제 API 통합 (30분)
- **검증**: Mock 테스트와 실제 API 테스트 모두 성공
- **성과**: 4개 실제 API 테스트 100% 통과
- **확신**: 시스템의 신뢰성 확보

## 🎓 개발자로서 성장한 부분

### 1. 체계적 문제 해결
**이전**: 문제를 보면 바로 코딩 시작
**지금**: 문제 분석 → 해결책 설계 → 단계별 구현

### 2. 테스트 주도 사고
**이전**: 기능 구현 후 테스트는 선택사항
**지금**: 테스트가 개발 품질의 핵심이자 문서화 수단

### 3. 보안 의식 향상
**이전**: API 키를 `.env`에만 저장
**지금**: 다중 저장 방식으로 개발/프로덕션 환경 모두 고려

### 4. Mock 테스트의 철학 이해
**이전**: Mock은 단순히 가짜 객체
**지금**: Mock은 실제 구현의 정확한 계약(Contract) 검증 도구

## ⚡ 실무에서 바로 적용할 팁

### 1. pytest 마커 활용
```python
@pytest.mark.unit      # 빠른 단위 테스트
@pytest.mark.integration  # 느린 통합 테스트
@pytest.mark.real_api     # 실제 외부 API 테스트
```
**활용**: `pytest -m "not real_api"`로 빠른 테스트만 실행

### 2. 픽스처 스코프 최적화
```python
@pytest.fixture(scope="class")  # 클래스당 1번만 실행
def api_keys(self):
    return get_test_api_keys()
```
**활용**: 비용이 큰 설정을 클래스 레벨에서 재사용

### 3. 환경별 테스트 전략
```bash
# 개발환경: Mock 테스트 위주
pytest tests/ -m "not real_api"

# CI/CD: 전체 테스트
pytest tests/ --cov=upbit_auto_trading
```

## 💭 프로젝트 회고

### 잘한 점
- **차근차근 접근**: 각 문제를 하나씩 정확히 해결
- **실제 구현 확인**: 추측하지 않고 소스코드 직접 분석
- **이중 검증**: Mock과 실제 API 테스트로 신뢰성 확보

### 아쉬운 점
- **초기 계획 부족**: 문제 복잡성을 과소평가
- **문서화 지연**: 구현 중간에 기록을 남기지 못함

### 다음에는
- **Test Plan 먼저**: 구현 전에 테스트 전략 수립
- **지속적 문서화**: 각 단계마다 학습 내용 기록
- **Code Review**: 동료와 함께 Mock 정확성 검증

## 🔄 향후 발전 방향

### 단기 (1-2주)
- 다른 Infrastructure 컴포넌트에 pytest 적용
- 테스트 커버리지 측정 및 개선
- CI/CD 파이프라인에 테스트 통합

### 중기 (1-2개월)
- Property-based Testing 도입 (Hypothesis)
- 성능 테스트 및 부하 테스트 추가
- 테스트 데이터 팩토리 패턴 적용

### 장기 (3-6개월)
- 전체 시스템 E2E 테스트 구축
- 테스트 자동화 및 리포팅 시스템
- 테스트 기반 개발 문화 정착

---

**💡 핵심 메시지**: "완벽한 테스트는 코드의 신뢰성을 보장하고, 리팩토링의 자신감을 준다!"
