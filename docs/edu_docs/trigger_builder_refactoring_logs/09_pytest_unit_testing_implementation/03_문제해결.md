# 🔧 pytest 단위테스트 구현 - 문제해결 가이드

> **대상**: 주니어 개발자
> **목적**: pytest 구현 과정에서 발생한 실제 문제와 해결 과정 기록
> **작성일**: 2025-08-05

## 🚨 발생한 문제들과 해결 과정

### 🔴 문제 #1: ApiResponse 생성자 파라미터 오류

#### 증상
```bash
TypeError: ApiResponse.__init__() got an unexpected keyword argument 'response_time'.
Did you mean 'response_time_ms'?
```

#### 원인 분석
```python
# ❌ 잘못된 Mock 코드
mock_response = ApiResponse(
    success=True,
    data=mock_response_data,
    status_code=200,
    response_time=0.1  # 잘못된 파라미터명
)
```

#### 해결 과정
1. **실제 구현 확인**
   ```bash
   # 실제 ApiResponse 클래스 분석
   code upbit_auto_trading/infrastructure/external_apis/common/api_client_base.py
   ```

2. **정확한 구조 파악**
   ```python
   @dataclass
   class ApiResponse:
       status_code: int
       data: Any
       headers: Dict[str, str]
       request_time: datetime
       response_time_ms: float  # 정확한 파라미터명!
       success: bool
       error_message: Optional[str] = None
   ```

3. **수정된 코드**
   ```python
   # ✅ 올바른 Mock 코드
   from datetime import datetime

   mock_response = ApiResponse(
       success=True,
       data=mock_response_data,
       status_code=200,
       headers={},
       request_time=datetime.now(),
       response_time_ms=100.0  # 올바른 파라미터명
   )
   ```

#### 교훈
- **Mock 작성 전 실제 구현 분석 필수**
- **IDE의 자동완성보다 실제 소스코드 확인이 정확**

---

### 🔴 문제 #2: UpbitAuthenticator 헤더 검증 실패

#### 증상
```bash
AssertionError: assert 'User-Agent' in {'Accept': 'application/json', 'Content-Type': 'application/json'}
```

#### 원인 분석
```python
# ❌ 잘못된 기대값
def test_get_public_headers(self):
    auth = UpbitAuthenticator(None, None)
    headers = auth.get_public_headers()
    assert "User-Agent" in headers  # 실제로는 없음!
```

#### 해결 과정
1. **실제 구현 확인**
   ```python
   # upbit_auth.py의 실제 구현
   def get_public_headers(self) -> Dict[str, str]:
       return {
           'Accept': 'application/json',
           'Content-Type': 'application/json'
           # User-Agent는 없음!
       }
   ```

2. **테스트 수정**
   ```python
   # ✅ 실제 구현에 맞는 검증
   def test_get_public_headers(self):
       auth = UpbitAuthenticator(None, None)
       headers = auth.get_public_headers()

       # 실제로 존재하는 헤더만 검증
       assert "Accept" in headers
       assert "Content-Type" in headers
       assert headers["Accept"] == "application/json"
       assert headers["Content-Type"] == "application/json"
       assert "Authorization" not in headers
   ```

#### 교훈
- **가정하지 말고 실제 동작 확인**
- **테스트는 실제 구현의 계약(Contract)을 검증해야 함**

---

### 🔴 문제 #3: API 호출 파라미터 불일치

#### 증상
```bash
AssertionError: expected call not found.
Expected: params={'isDetails': 'true'}
Actual: params={'isDetails': 'false'}
```

#### 원인 분석
```python
# ❌ 잘못된 예상값
mock_request.assert_called_once_with(
    "GET", "/market/all",
    params={"isDetails": "true"}  # 실제 기본값과 다름
)
```

#### 해결 과정
1. **실제 메서드 시그니처 확인**
   ```python
   # upbit_public_client.py 분석
   async def get_markets(self, is_details: bool = False) -> List[Dict[str, Any]]:
       params = {'isDetails': 'true' if is_details else 'false'}
       # 기본값 False이므로 'false'가 정상!
   ```

2. **테스트 호출 방식 확인**
   ```python
   # 테스트에서 파라미터 없이 호출
   result = await client.get_markets()  # is_details=False (기본값)
   ```

3. **올바른 검증 코드**
   ```python
   # ✅ 실제 기본값에 맞는 검증
   mock_request.assert_called_once_with(
       "GET", "/market/all",
       params={"isDetails": "false"}  # 기본값 반영
   )
   ```

#### 교훈
- **기본값과 실제 호출 방식 정확히 파악**
- **메서드 시그니처 분석 필수**

---

### 🔴 문제 #4: 비동기 Mock 처리 오류

#### 증상
```bash
RuntimeError: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited
```

#### 원인 분석
```python
# ❌ 잘못된 Mock 설정
with patch.object(client, '_make_request', new_callable=Mock) as mock_request:
    # Mock 대신 AsyncMock이 필요!
```

#### 해결 과정
1. **비동기 특성 이해**
   - `_make_request`는 `async` 메서드
   - 일반 `Mock`으로는 `await` 처리 불가

2. **올바른 Mock 적용**
   ```python
   # ✅ 비동기 메서드에는 AsyncMock
   with patch.object(client, '_make_request', new_callable=AsyncMock) as mock_request:
       mock_request.return_value = mock_response
       result = await client.get_markets()  # 정상 동작
   ```

#### 교훈
- **비동기 메서드 Mock 시 반드시 AsyncMock 사용**
- **pytest-asyncio 설정 필요: `asyncio_mode = "auto"`**

---

### 🔴 문제 #5: API 키 로딩 복잡성

#### 증상
```python
FileNotFoundError: [Errno 2] No such file or directory: 'config/secure/api_keys.enc'
```

#### 원인 분석
- 프로젝트에 2가지 API 키 저장 방식 존재
- `.env` 파일과 암호화된 파일 동시 지원 필요
- 테스트 환경에서 유연한 처리 필요

#### 해결 과정
1. **이중 로딩 전략 설계**
   ```python
   def get_test_api_keys() -> Tuple[Optional[str], Optional[str]]:
       # 1순위: .env 파일 (개발 편의성)
       try:
           access_key, secret_key = load_from_env()
           if access_key and secret_key:
               return access_key, secret_key
       except Exception:
           pass

       # 2순위: 암호화 파일 (프로덕션 보안)
       try:
           return load_from_encrypted()
       except Exception:
           pass

       return None, None
   ```

2. **안전한 fallback 구현**
   ```python
   @pytest.fixture(scope="class")
   def api_keys(self):
       access_key, secret_key = get_test_api_keys()
       if not access_key or not secret_key:
           pytest.skip("실제 API 키가 없어서 테스트를 건너뜁니다")
       return access_key, secret_key
   ```

#### 교훈
- **다중 소스 지원으로 환경별 유연성 확보**
- **테스트는 의존성 없이도 실행 가능해야 함**

---

## 🛠️ 문제 해결 방법론

### 1. 체계적 문제 진단
```
문제 발생 → 오류 메시지 분석 → 관련 코드 확인 → 실제 구현 분석 → 수정 → 검증
```

### 2. 효과적인 디버깅 도구
```bash
# 상세한 오류 정보
pytest -vvv --tb=long

# 특정 테스트만 실행
pytest tests/specific_test.py::TestClass::test_method -v

# pdb 디버거 사용
pytest --pdb
```

### 3. 실제 구현 확인 방법
```bash
# 소스코드 직접 확인
code upbit_auto_trading/infrastructure/external_apis/common/api_client_base.py

# 클래스 구조 분석
python -c "
from upbit_auto_trading.infrastructure.external_apis.common.api_client_base import ApiResponse
import inspect
print(inspect.signature(ApiResponse.__init__))
"
```

## 🎯 예방 가이드라인

### Mock 테스트 작성 시
1. **실제 구현 먼저 분석**: Mock 작성 전 실제 클래스/메서드 확인
2. **파라미터 정확성**: 생성자, 메서드 시그니처 정확히 일치
3. **비동기 고려**: async 메서드는 AsyncMock 필수
4. **리소스 정리**: yield 패턴으로 테스트 후 정리

### 실제 API 테스트 작성 시
1. **의존성 최소화**: API 키 없어도 건너뛰기
2. **격리된 환경**: patch.dict로 환경변수 임시 설정
3. **현실적 검증**: 너무 엄격하지 않은 조건
4. **에러 처리**: 네트워크 오류 등 예외 상황 고려

### 테스트 실행 전략
1. **단계별 검증**: Mock → 실제 API 순서로 테스트
2. **마커 활용**: 빠른/느린 테스트 분리
3. **커버리지 확인**: 테스트되지 않은 코드 파악
4. **CI/CD 통합**: 자동화된 품질 검증

## 📚 참고 자료

### pytest 공식 문서
- [pytest-asyncio](https://pytest-asyncio.readthedocs.io/)
- [unittest.mock](https://docs.python.org/3/library/unittest.mock.html)
- [pytest fixtures](https://docs.pytest.org/en/latest/explanation/fixtures.html)

### 모범 사례
- [Testing async code](https://realpython.com/async-io-python/#testing-async-io-code)
- [API testing patterns](https://testdriven.io/blog/testing-third-party-apis/)

## 🔄 트러블슈팅 체크리스트

테스트 실패 시 순서대로 확인:

### 기본 체크 (5분)
- [ ] pytest 마커 설정 확인 (`@pytest.mark.asyncio`)
- [ ] import 경로 정확성 확인
- [ ] 파일명이 pytest 규칙에 맞는지 확인 (`test_*.py`)

### Mock 관련 (10분)
- [ ] AsyncMock vs Mock 적절한 선택
- [ ] 실제 클래스 시그니처와 Mock 일치성
- [ ] 파라미터명 정확성 (실제 구현 대조)
- [ ] 반환값 구조 정확성

### API 관련 (10분)
- [ ] API 키 로딩 상태 확인
- [ ] 네트워크 연결 상태 확인
- [ ] 환경변수 설정 확인
- [ ] pytest skip 조건 확인

### 시스템 관련 (15분)
- [ ] 의존성 패키지 설치 확인
- [ ] Python 버전 호환성 확인
- [ ] 프로젝트 경로 설정 확인
- [ ] 로그 파일에서 상세 오류 확인

---

**💡 핵심 원칙**: "추측하지 말고 확인하라. Mock은 실제 구현의 정확한 반영이어야 한다!"
