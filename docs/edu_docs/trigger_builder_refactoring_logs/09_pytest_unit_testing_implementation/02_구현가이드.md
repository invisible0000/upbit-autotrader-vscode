# 🛠️ pytest 단위테스트 시스템 구현 가이드

> **대상**: 주니어 개발자
> **목적**: Infrastructure Layer pytest 테스트 시스템 구현 방법론
> **난이도**: 중급
> **소요시간**: 2-3시간

## 📋 사전 준비사항

### 필수 라이브러리
```bash
# 기본 테스트 도구
pip install pytest pytest-asyncio pytest-cov

# Mock 및 패치 도구
pip install pytest-mock

# API 키 암호화 (선택사항)
pip install cryptography
```

### 프로젝트 구조
```
tests/
├── utils/
│   └── api_key_loader.py      # API 키 로딩 유틸리티
├── infrastructure/
│   └── external_apis/
│       └── test_upbit_clients.py  # 메인 테스트 파일
└── conftest.py                # pytest 설정
```

## 🎯 1단계: API 키 로딩 시스템 구축

### API 키 로더 유틸리티 작성
```python
# tests/utils/api_key_loader.py
import os
from pathlib import Path
from typing import Tuple, Optional

def get_test_api_keys() -> Tuple[Optional[str], Optional[str]]:
    """테스트용 API 키 로드 (이중 소스 지원)"""

    # 1순위: .env 파일 (개발 편의성)
    try:
        access_key, secret_key = load_from_env()
        if access_key and secret_key:
            print("✅ .env 파일에서 API 키 로드 성공")
            return access_key, secret_key
    except Exception as e:
        print(f"⚠️ .env 로드 실패: {e}")

    # 2순위: 암호화 파일 (프로덕션 보안)
    try:
        access_key, secret_key = load_from_encrypted()
        if access_key and secret_key:
            print("✅ 암호화 파일에서 API 키 로드 성공")
            return access_key, secret_key
    except Exception as e:
        print(f"⚠️ 암호화 파일 로드 실패: {e}")

    print("❌ API 키를 찾을 수 없습니다")
    return None, None

def load_from_env() -> Tuple[Optional[str], Optional[str]]:
    """환경변수/.env 파일에서 로드"""
    from dotenv import load_dotenv
    load_dotenv()

    return (
        os.getenv('UPBIT_ACCESS_KEY'),
        os.getenv('UPBIT_SECRET_KEY')
    )

def load_from_encrypted() -> Tuple[Optional[str], Optional[str]]:
    """암호화된 파일에서 로드"""
    try:
        from cryptography.fernet import Fernet

        # 암호화 키와 파일 경로 설정
        key_file = Path("config/secure/encryption.key")
        data_file = Path("config/secure/api_keys.enc")

        if not key_file.exists() or not data_file.exists():
            return None, None

        # 복호화 과정
        with open(key_file, 'rb') as kf:
            key = kf.read()

        fernet = Fernet(key)

        with open(data_file, 'rb') as df:
            encrypted_data = df.read()

        decrypted_data = fernet.decrypt(encrypted_data)
        lines = decrypted_data.decode().strip().split('\n')

        access_key = lines[0].split('=')[1] if len(lines) > 0 else None
        secret_key = lines[1].split('=')[1] if len(lines) > 1 else None

        return access_key, secret_key

    except Exception:
        return None, None
```

### 핵심 설계 원칙
1. **장애 허용**: 한 방식이 실패해도 다른 방식 시도
2. **명확한 피드백**: 각 단계의 성공/실패 상태 출력
3. **보안 우선**: 민감 정보 로깅하지 않음

## 🎯 2단계: pytest 구성 파일 설정

### pyproject.toml 설정
```toml
[tool.pytest.ini_options]
minversion = "6.0"
addopts = "-ra -q --strict-markers"
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
asyncio_mode = "auto"

# 테스트 마커 정의
markers = [
    "unit: 빠른 단위 테스트",
    "integration: 느린 통합 테스트",
    "real_api: 실제 API 호출 테스트",
    "slow: 시간이 오래 걸리는 테스트"
]
```

### 핵심 설정 포인트
- `asyncio_mode = "auto"`: 비동기 테스트 자동 처리
- `markers`: 테스트 분류로 선택적 실행 가능
- `python_*`: pytest 발견 규칙 명시

## 🎯 3단계: Mock 단위 테스트 구현

### 기본 테스트 클래스 구조
```python
import pytest
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime

class TestUpbitPublicClient:
    """공개 API 클라이언트 테스트"""

    @pytest.fixture
    async def client(self):
        """테스트용 클라이언트 픽스처"""
        client = UpbitPublicClient()
        yield client
        await client.close()  # 리소스 정리

    @pytest.mark.asyncio
    async def test_get_markets_success(self, client):
        """마켓 조회 성공 케이스"""
        # 1. Mock 데이터 준비
        mock_response_data = [
            {"market": "KRW-BTC", "korean_name": "비트코인"},
            {"market": "KRW-ETH", "korean_name": "이더리움"}
        ]

        # 2. API 응답 Mock 설정
        with patch.object(client, '_make_request', new_callable=AsyncMock) as mock_request:
            # 실제 ApiResponse 구조에 맞춘 Mock
            from upbit_auto_trading.infrastructure.external_apis.common.api_client_base import ApiResponse

            mock_response = ApiResponse(
                success=True,
                data=mock_response_data,
                status_code=200,
                headers={},
                request_time=datetime.now(),
                response_time_ms=100.0  # 정확한 파라미터명!
            )
            mock_request.return_value = mock_response

            # 3. 실제 메서드 호출
            result = await client.get_markets()

            # 4. 결과 검증
            assert len(result) == 2
            assert result[0]["market"] == "KRW-BTC"

            # 5. 호출 검증 (실제 구현과 일치하는 파라미터)
            mock_request.assert_called_once_with(
                "GET", "/market/all",
                params={"isDetails": "false"}  # 기본값 확인 필요!
            )
```

### Mock 구현 시 주의사항
1. **정확한 파라미터명**: `response_time_ms` (not `response_time`)
2. **실제 기본값**: 소스코드에서 확인한 정확한 기본값 사용
3. **리소스 정리**: `yield` 패턴으로 테스트 후 정리
4. **AsyncMock**: 비동기 메서드에는 반드시 `AsyncMock` 사용

## 🎯 4단계: 실제 API 통합 테스트

### 실제 API 테스트 클래스
```python
@pytest.mark.real_api
class TestRealApiIntegration:
    """실제 API 키를 사용한 통합 테스트"""

    @pytest.fixture(scope="class")
    def api_keys(self):
        """클래스 레벨 API 키 픽스처"""
        access_key, secret_key = get_test_api_keys()
        if not access_key or not secret_key:
            pytest.skip("실제 API 키가 없어서 테스트를 건너뜁니다")
        return access_key, secret_key

    @pytest.mark.asyncio
    async def test_real_public_api(self):
        """실제 공개 API 테스트"""
        from upbit_auto_trading.infrastructure.external_apis.api_client_factory import ApiClientFactory

        async with ApiClientFactory.create_public_only_client() as client:
            # 실제 마켓 조회
            markets = await client.get_markets()

            # 현실적인 검증
            assert len(markets) > 0
            assert any(market['market'].startswith('KRW-') for market in markets)

            # 추가 검증: 첫 번째 KRW 마켓 현재가 조회
            krw_markets = [m for m in markets if m['market'].startswith('KRW-')]
            if krw_markets:
                first_market = krw_markets[0]['market']
                tickers = await client.get_tickers([first_market])
                assert len(tickers) == 1
                assert 'trade_price' in tickers[0]
                assert tickers[0]['trade_price'] > 0

    @pytest.mark.asyncio
    async def test_real_private_api(self, api_keys):
        """실제 인증 API 테스트"""
        access_key, secret_key = api_keys

        # 환경변수 패치로 API 키 주입
        with patch.dict('os.environ', {
            'UPBIT_ACCESS_KEY': access_key,
            'UPBIT_SECRET_KEY': secret_key
        }):
            async with ApiClientFactory.create_upbit_client() as client:
                accounts = await client.get_accounts()

                # 최소한의 현실적 검증
                assert isinstance(accounts, list)
                krw_account = next((acc for acc in accounts if acc['currency'] == 'KRW'), None)
                assert krw_account is not None
                assert 'balance' in krw_account
```

### 실제 API 테스트 모범 사례
1. **scope="class"**: 비용이 큰 API 키 로딩을 클래스당 1번만
2. **pytest.skip()**: API 키 없으면 자동으로 건너뛰기
3. **patch.dict()**: 환경변수 임시 설정으로 격리된 테스트
4. **현실적 검증**: 너무 엄격하지 않은 검증 조건

## 🎯 5단계: 테스트 실행 전략

### 개발 중 빠른 피드백
```bash
# Mock 테스트만 (빠른 실행)
pytest tests/ -m "not real_api" -v

# 특정 테스트 클래스만
pytest tests/infrastructure/external_apis/test_upbit_clients.py::TestUpbitPublicClient -v
```

### CI/CD용 전체 검증
```bash
# 전체 테스트 (커버리지 포함)
pytest tests/ --cov=upbit_auto_trading --cov-report=html

# 실제 API 테스트만 (프로덕션 검증용)
pytest tests/ -m "real_api" -v
```

### 성능 모니터링
```bash
# 느린 테스트 식별
pytest tests/ --durations=10

# 병렬 실행 (pytest-xdist)
pytest tests/ -n auto
```

## 🔧 문제 해결 가이드

### 자주 발생하는 오류와 해결법

#### 1. ApiResponse 파라미터 오류
```
TypeError: ApiResponse.__init__() got an unexpected keyword argument 'response_time'
```
**해결**: `response_time_ms` 사용

#### 2. Mock 호출 검증 실패
```
AssertionError: expected call not found.
Expected: params={'isDetails': 'true'}
Actual: params={'isDetails': 'false'}
```
**해결**: 실제 구현의 기본값 확인

#### 3. 비동기 테스트 실패
```
RuntimeError: There is no current event loop
```
**해결**: `@pytest.mark.asyncio` 추가 및 `AsyncMock` 사용

### 디버깅 팁
1. **실제 구현 확인**: Mock 전에 실제 코드 분석
2. **단계별 검증**: 각 단계마다 print로 확인
3. **pytest -vvv**: 매우 상세한 출력으로 원인 파악

## 📊 테스트 품질 체크리스트

### Mock 테스트 품질
- [ ] 실제 API 응답 구조와 동일한 Mock 데이터
- [ ] 모든 파라미터명이 실제 구현과 일치
- [ ] 비동기 메서드에 AsyncMock 사용
- [ ] 리소스 정리 (yield 패턴)

### 실제 API 테스트 품질
- [ ] API 키 없으면 자동 skip
- [ ] 환경변수 격리 (patch.dict)
- [ ] 현실적이고 안정적인 검증 조건
- [ ] 외부 API 의존성 최소화

### 전체 시스템 품질
- [ ] 마커 기반 테스트 분류
- [ ] CI/CD 파이프라인 통합
- [ ] 커버리지 측정 및 리포팅
- [ ] 성능 모니터링

---

**🎯 성공의 핵심**: "Mock의 정확성 + 실제 API 검증 + 체계적인 실행 전략"
