# 🛠️ DDD 도메인 계층 구현 가이드

> **실제 코드로 배우는 도메인 주도 설계 구현법**

## 📋 개요

이 문서는 업비트 자동매매 시스템에서 실제로 구현한 도메인 계층 코드를 통해 DDD 원칙을 실무에 적용하는 방법을 설명합니다.

## 🏗️ 아키텍처 구조

### 전체 구조
```
upbit_auto_trading/domain/
├── entities/                 # 도메인 엔티티
│   ├── strategy.py          # 전략 엔티티 (핵심)
│   ├── trigger.py           # 트리거 엔티티  
│   ├── management_rule.py   # 관리 규칙 엔티티
│   └── strategy_factory.py  # 팩토리 클래스
├── value_objects/           # 값 객체
│   ├── strategy_id.py       # 전략 식별자
│   ├── trigger_id.py        # 트리거 식별자
│   └── comparison_operator.py # 비교 연산자
└── exceptions/              # 도메인 예외
    └── domain_exceptions.py
```

### 의존성 방향
```
UI Layer → Service Layer → Domain Layer
                      ↓
Repository Layer → Infrastructure Layer
```

## 💎 값 객체 (Value Objects) 구현

### 1. StrategyId - 전략 식별자

```python
@dataclass(frozen=True)
class StrategyId:
    """전략 고유 식별자 값 객체"""
    value: str

    def __post_init__(self):
        """도메인 규칙 검증"""
        if not isinstance(self.value, str):
            raise InvalidStrategyIdError("전략 ID는 문자열이어야 합니다")
        
        if not 3 <= len(self.value) <= 50:
            raise InvalidStrategyIdError(f"전략 ID는 3-50자여야 합니다: {self.value}")
        
        if not self.value[0].isalpha():
            raise InvalidStrategyIdError(f"전략 ID는 영문자로 시작해야 합니다: {self.value}")

    def __str__(self) -> str:
        return self.value
```

**🎓 핵심 포인트**:
- `frozen=True`: 불변성 보장
- `__post_init__`: 생성 시점에 도메인 규칙 검증
- 구체적인 비즈니스 규칙 (길이, 시작 문자 등)

### 2. ComparisonOperator - 비교 연산자

```python
class ComparisonOperator(Enum):
    """비교 연산자 값 객체"""
    GREATER_THAN = ">"
    LESS_THAN = "<"
    GREATER_EQUAL = ">="
    LESS_EQUAL = "<="
    EQUAL = "=="
    NOT_EQUAL = "!="
    APPROXIMATELY_EQUAL = "~="

    def evaluate(self, left: Union[int, float, Decimal], right: Union[int, float, Decimal]) -> bool:
        """실제 비교 수행"""
        # Decimal 타입 지원으로 정확한 금융 계산
        left_decimal = Decimal(str(left))
        right_decimal = Decimal(str(right))
        
        if self == ComparisonOperator.GREATER_THAN:
            return left_decimal > right_decimal
        elif self == ComparisonOperator.LESS_THAN:
            return left_decimal < right_decimal
        # ... 기타 연산자들
        
    def get_display_name(self) -> str:
        """UI 표시용 이름"""
        display_names = {
            ComparisonOperator.GREATER_THAN: "초과",
            ComparisonOperator.LESS_THAN: "미만",
            # ...
        }
        return display_names.get(self, self.value)
```

**🎓 핵심 포인트**:
- Enum으로 제한된 선택지 보장
- `evaluate()`: 값 객체가 자신의 책임 수행
- `Decimal` 사용: 금융 계산의 정확성

## 🏛️ 도메인 엔티티 구현

### 1. Strategy - 전략 엔티티 (Aggregate Root)

```python
@dataclass
class Strategy:
    """매매 전략 도메인 엔티티 (Aggregate Root)"""
    id: StrategyId
    config: StrategyConfig
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    domain_events: List[DomainEvent] = field(default_factory=list)
    management_strategies: List['ManagementRule'] = field(default_factory=list)

    def activate(self) -> None:
        """전략 활성화"""
        if not self.is_active:
            self.is_active = True
            self.updated_at = datetime.now()
            self._add_domain_event(DomainEvent(
                event_type="strategy_activated",
                aggregate_id=str(self.id),
                event_data={"activated_at": self.updated_at.isoformat()}
            ))

    def deactivate(self) -> None:
        """전략 비활성화"""
        if self.is_active:
            self.is_active = False
            self.updated_at = datetime.now()
            self._add_domain_event(DomainEvent(
                event_type="strategy_deactivated",
                aggregate_id=str(self.id),
                event_data={"deactivated_at": self.updated_at.isoformat()}
            ))

    def add_management_strategy(self, rule: 'ManagementRule') -> None:
        """관리 전략 추가"""
        self.management_strategies.append(rule)
        self.updated_at = datetime.now()
        self._add_domain_event(DomainEvent(
            event_type="management_strategy_added",
            aggregate_id=str(self.id),
            event_data={
                "rule_id": str(rule.id),
                "rule_type": rule.management_type.value
            }
        ))

    def _add_domain_event(self, event: DomainEvent) -> None:
        """도메인 이벤트 추가 (내부 메서드)"""
        self.domain_events.append(event)
```

**🎓 핵심 포인트**:
- **Aggregate Root**: 일관성 경계 정의
- **도메인 이벤트**: 상태 변화를 이벤트로 추적
- **비즈니스 메서드**: activate(), deactivate() 등
- **불변식 보장**: 내부 상태 일관성 유지

### 2. Trigger - 트리거 엔티티

```python
@dataclass
class Trigger:
    """매매 조건 트리거 도메인 엔티티"""
    id: TriggerId
    trigger_type: TriggerType
    variable: TradingVariable
    operator: ComparisonOperator
    target_value: str
    external_variable: Optional[TradingVariable] = None
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.now)
    domain_events: List[DomainEvent] = field(default_factory=list)

    def evaluate(self, market_data: Any = None) -> TriggerEvaluationResult:
        """트리거 조건 평가"""
        if not self.is_active:
            return TriggerEvaluationResult.failure("비활성 트리거")
        
        # 임시 구현 - 실제로는 market_data 기반 복잡한 로직
        evaluation_successful = True
        
        result = TriggerEvaluationResult.success() if evaluation_successful else TriggerEvaluationResult.failure("조건 불만족")
        
        self._add_domain_event(DomainEvent(
            event_type="trigger_evaluated",
            aggregate_id=str(self.id),
            event_data={
                "result": "success" if evaluation_successful else "failure",
                "evaluated_at": datetime.now().isoformat()
            }
        ))
        
        return result

    def check_compatibility(self, other_variable: TradingVariable) -> float:
        """다른 변수와의 호환성 점수 반환 (0.0 ~ 1.0)"""
        return self.variable.is_compatible_with(other_variable)

    def to_human_readable(self) -> str:
        """사용자 친화적 표현"""
        if self.external_variable:
            return f"{self.variable.display_name} {self.operator.get_display_name()} {self.external_variable.display_name}"
        else:
            return f"{self.variable.display_name} {self.operator.get_display_name()} {self.target_value}"
```

**🎓 핵심 포인트**:
- **도메인 서비스 호출**: 복잡한 평가 로직은 별도 서비스로 위임 예정
- **호환성 검증**: 다른 도메인 객체와의 상호작용
- **표현 메서드**: UI 표시를 위한 비즈니스 로직

## 🏭 팩토리 패턴 구현

### Strategy Factory

```python
class StrategyFactory:
    """전략 생성을 위한 팩토리 클래스"""
    
    @staticmethod
    def create_basic_7_rule_strategy() -> Strategy:
        """기본 7규칙 전략 생성"""
        strategy_id = StrategyId("BASIC_7_RULE_STRATEGY")
        config = StrategyConfig({
            "name": "기본 7규칙 전략",
            "description": "RSI 기반 진입 + 불타기/물타기 + 트레일링 스탑",
            "risk_level": 3,
            "expected_return": 15.0
        })
        
        strategy = Strategy(id=strategy_id, config=config)
        
        # 관리 전략들 추가
        strategy.add_management_strategy(create_scale_in_buying_rule())
        strategy.add_management_strategy(create_pyramid_buying_rule())
        strategy.add_management_strategy(create_trailing_stop_rule())
        
        return strategy

    @staticmethod  
    def create_conservative_strategy() -> Strategy:
        """보수적 전략 생성"""
        strategy_id = StrategyId("CONSERVATIVE_STRATEGY")
        config = StrategyConfig({
            "name": "보수적 전략",
            "description": "안정적인 수익 추구, 고정 손절/익절만 사용",
            "risk_level": 1,
            "expected_return": 8.0
        })
        
        strategy = Strategy(id=strategy_id, config=config)
        strategy.add_management_strategy(create_fixed_stop_take_rule())
        
        return strategy
```

**🎓 핵심 포인트**:
- **복잡성 캡슐화**: 복잡한 객체 생성 로직을 숨김
- **템플릿 제공**: 일반적인 사용 패턴을 미리 정의
- **확장성**: 새로운 전략 템플릿 쉽게 추가 가능

## 🎯 도메인 이벤트 시스템

### 도메인 이벤트 정의

```python
@dataclass
class DomainEvent:
    """도메인 이벤트 값 객체"""
    event_type: str
    aggregate_id: str
    timestamp: datetime = field(default_factory=datetime.now)
    event_data: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """직렬화를 위한 딕셔너리 변환"""
        return {
            "event_type": self.event_type,
            "aggregate_id": self.aggregate_id,
            "timestamp": self.timestamp.isoformat(),
            "event_data": self.event_data
        }
```

### 이벤트 활용 예시

```python
# 전략 생성 시
strategy = Strategy(id=strategy_id, config=config)
# 자동으로 strategy_created 이벤트 발생

# 관리 전략 추가 시  
strategy.add_management_strategy(rule)
# management_strategy_added 이벤트 발생

# 이벤트 처리 (향후 Event Handler에서)
for event in strategy.domain_events:
    if event.event_type == "strategy_created":
        # 감사 로그 기록, 알림 발송 등
        pass
```

**🎓 핵심 포인트**:
- **관심사 분리**: 핵심 로직과 부수 효과 분리
- **감사 추적**: 모든 도메인 변화 기록
- **확장성**: 새로운 이벤트 핸들러 쉽게 추가

## 🧪 테스트 전략

### 1. 값 객체 테스트

```python
def test_strategy_id_validation():
    """StrategyId 검증 규칙 테스트"""
    # 정상 케이스
    valid_id = StrategyId("BASIC_STRATEGY")
    assert str(valid_id) == "BASIC_STRATEGY"
    
    # 예외 케이스들
    with pytest.raises(InvalidStrategyIdError):
        StrategyId("AB")  # 너무 짧음
    
    with pytest.raises(InvalidStrategyIdError):
        StrategyId("1STRATEGY")  # 숫자로 시작
```

### 2. 엔티티 테스트

```python
def test_strategy_lifecycle():
    """전략 생명주기 테스트"""
    # Given
    strategy_id = StrategyId("TEST_STRATEGY")
    config = StrategyConfig({"risk_level": 3})
    strategy = Strategy(id=strategy_id, config=config)
    
    # When: 비활성화
    strategy.deactivate()
    
    # Then: 상태 변화 확인
    assert strategy.is_active == False
    assert len(strategy.domain_events) == 2  # created + deactivated
    
    # When: 재활성화
    strategy.activate()
    
    # Then
    assert strategy.is_active == True
    assert len(strategy.domain_events) == 3  # created + deactivated + activated
```

### 3. 팩토리 테스트

```python
def test_factory_creates_valid_strategy():
    """팩토리가 올바른 전략을 생성하는지 테스트"""
    # When
    strategy = create_basic_7_rule_strategy()
    
    # Then
    assert isinstance(strategy.id, StrategyId)
    assert strategy.is_active == True
    assert len(strategy.management_strategies) == 3  # 불타기, 물타기, 트레일링 스탑
    assert strategy.config.name == "기본 7규칙 전략"
```

**🎓 핵심 포인트**:
- **도메인 규칙 검증**: 비즈니스 규칙이 올바르게 적용되는지 확인
- **상태 변화 추적**: 도메인 이벤트로 상태 변화 검증
- **팩토리 검증**: 복잡한 객체가 올바르게 생성되는지 확인

## ⚠️ 주의사항과 Best Practices

### 1. 순환 참조 방지

```python
# ❌ 잘못된 방법
# strategy.py
from .management_rule import ManagementRule

# management_rule.py
from .strategy import Strategy  # 순환 참조!

# ✅ 올바른 방법
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .strategy import Strategy
```

### 2. 도메인 순수성 유지

```python
# ❌ 도메인 엔티티에 인프라 의존성
class Strategy:
    def save_to_database(self):  # 잘못됨!
        db.session.add(self)

# ✅ Repository 패턴으로 분리
class StrategyRepository:
    def save(self, strategy: Strategy) -> None:
        # DB 저장 로직
```

### 3. 불변성 보장

```python
# ✅ 값 객체는 불변
@dataclass(frozen=True)
class StrategyId:
    value: str

# ✅ 엔티티는 제어된 변경만 허용
class Strategy:
    def update_name(self, new_name: str) -> None:
        # 비즈니스 규칙 검증 후 변경
        if len(new_name) < 3:
            raise ValueError("전략 이름은 3자 이상이어야 합니다")
        self.config.name = new_name
        self.updated_at = datetime.now()
```

## 🔗 다음 단계

### Repository 패턴
```python
class StrategyRepository(ABC):
    @abstractmethod
    def save(self, strategy: Strategy) -> None: pass
    
    @abstractmethod
    def find_by_id(self, strategy_id: StrategyId) -> Optional[Strategy]: pass
```

### Application Service
```python
class StrategyApplicationService:
    def __init__(self, strategy_repo: StrategyRepository):
        self.strategy_repo = strategy_repo
    
    def create_basic_strategy(self) -> StrategyId:
        strategy = create_basic_7_rule_strategy()
        self.strategy_repo.save(strategy)
        return strategy.id
```

## 📚 학습 자료

### 추천 도서
- "도메인 주도 설계" - 에릭 에반스
- "만들면서 배우는 클린 아키텍처" - 톰 홈버그

### 핵심 개념
- **Aggregate**: 일관성 경계
- **Value Object**: 불변 값 객체
- **Domain Event**: 도메인 변화 추적
- **Factory**: 복잡한 객체 생성

---

**🎯 요약**: DDD는 복잡한 비즈니스 로직을 체계적으로 관리하는 방법론입니다. 완벽한 이론보다는 **실무에 맞는 점진적 적용**이 성공의 열쇠입니다.
