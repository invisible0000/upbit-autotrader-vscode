# TASK-12 Infrastructure Layer 통합 문제해결 가이드

## 🚨 이 문서의 목적
TASK-12 Infrastructure Layer 통합 과정에서 실제 마주한 문제들과 해결 방법을 정리한 실무 트러블슈팅 가이드입니다. 같은 문제로 고생하는 개발자들의 시간을 절약하고자 작성되었습니다.

## 🔍 문제 분류 체계

### 심각도 분류
- 🔴 **Critical**: 애플리케이션 실행 불가
- 🟡 **Major**: 핵심 기능 동작하지 않음
- 🟢 **Minor**: 일부 기능 제한적 동작

### 영역별 분류
- **Environment**: 개발 환경 설정 문제
- **Integration**: 시스템 통합 문제
- **Performance**: 성능 관련 문제
- **Testing**: 테스트 실행 문제

## 🔧 Environment 문제들

### 🔴 Problem #1: VSCode 터미널 자동화 실패
**문제 상황**:
```
❌ LLM 에이전트의 run_in_terminal 도구가 명령을 실행하지 못함
❌ 터미널 ID 불일치로 출력 조회 실패
❌ PowerShell 확장과의 충돌
```

**원인 분석**:
```json
// .vscode/settings.json의 문제 설정들
{
    "python.experiments.optInto": ["pythonTerminalEnvVarActivation"],  // 실험 기능 활성화
    "terminal.integrated.defaultProfile.windows": "PowerShell (venv)", // 잘못된 프로필
    "extensions.ignoreRecommendations": false  // PowerShell 확장 자동 설치
}
```

**해결 과정**:
```json
// 1단계: 실험 기능 비활성화
{
    "python.experiments.optOutFrom": ["pythonTerminalEnvVarActivation"]
}

// 2단계: 터미널 프로필 최적화
{
    "terminal.integrated.profiles.windows": {
        "PowerShell (venv)": {
            "source": "PowerShell",
            "args": ["-ExecutionPolicy", "Bypass", "-NoExit", "-Command", "& '.\\venv\\Scripts\\Activate.ps1'"]
        }
    }
}

// 3단계: 자동화 설정 추가
{
    "terminal.integrated.automationProfile.windows": {
        "path": "pwsh.exe",
        "args": ["-NoProfile"]
    }
}
```

**최종 해결책**:
```json
// .vscode/settings.json (작동하는 버전)
{
    "python.defaultInterpreterPath": "./venv/Scripts/python.exe",
    "python.experiments.optOutFrom": ["pythonTerminalEnvVarActivation"],
    "terminal.integrated.defaultProfile.windows": "PowerShell (venv)",
    "terminal.integrated.profiles.windows": {
        "PowerShell (venv)": {
            "source": "PowerShell",
            "args": ["-ExecutionPolicy", "Bypass", "-NoExit", "-Command", "& '.\\venv\\Scripts\\Activate.ps1'"]
        }
    },
    "terminal.integrated.automationProfile.windows": {
        "path": "pwsh.exe",
        "args": ["-NoProfile"]
    }
}
```

**예방법**: Python 확장의 실험 기능을 함부로 활성화하지 말고, 터미널 자동화 설정을 명시적으로 구성

---

### 🟡 Problem #2: Python 가상환경 활성화 문제
**문제 상황**:
```bash
PS D:\projects\upbit-autotrader-vscode> python -m pytest
# 시스템 Python이 실행되어 패키지 누락 오류
```

**원인**: 터미널 자동 활성화 실패

**해결책**:
```bash
# 수동 활성화 스크립트
.\venv\Scripts\Activate.ps1

# 또는 직접 실행
.\venv\Scripts\python.exe -m pytest tests/infrastructure/
```

**자동화 설정**:
```json
// .vscode/settings.json
{
    "python.terminal.activateEnvironment": true,
    "python.terminal.activateEnvInCurrentTerminal": true
}
```

## 🔗 Integration 문제들

### 🔴 Problem #3: DI Container 의존성 순환 참조
**문제 상황**:
```python
# 실패 예시
RecursionError: maximum recursion depth exceeded
# ThemeService → SettingsService → ConfigLoader → ThemeService
```

**원인 분석**:
```python
# 잘못된 등록 순서
di_container.register_singleton(IThemeService, ThemeService)  # SettingsService 필요
di_container.register_singleton(ISettingsService, SettingsService)  # ConfigLoader 필요
# ConfigLoader는 아직 등록되지 않음!
```

**해결 과정**:
```python
def register_ui_services(app_context):
    """올바른 의존성 등록 순서"""
    di_container = app_context.get_di_container()

    # 1. 기본 서비스 (의존성 없음)
    di_container.register_singleton('LoggerFactory', LoggerFactory)
    di_container.register_singleton('StyleManager', StyleManager)

    # 2. ApplicationContext에서 ConfigLoader 가져오기
    config_loader = app_context.get_config_loader()  # 이미 초기화됨

    # 3. ConfigLoader 의존 서비스
    settings_service = SettingsService(config_loader)
    di_container.register_singleton(ISettingsService, settings_service)

    # 4. 복합 의존성 서비스
    style_manager = di_container.resolve('StyleManager')
    theme_service = ThemeService(settings_service, style_manager)
    di_container.register_singleton(IThemeService, theme_service)
```

**예방법**: 의존성 그래프를 먼저 그려보고, 순환 참조가 없는 순서로 등록

---

### 🟡 Problem #4: Qt 시그널/슬롯 연결 실패
**문제 상황**:
```python
# 테마 변경이 UI에 반영되지 않음
theme_service.set_theme('dark')  # 실행되지만 UI 변화 없음
```

**원인**: 기존 theme_notifier와 새로운 ThemeService 간 연결 누락

**해결책**:
```python
class ThemeService(IThemeService):
    def set_theme(self, theme_name: str):
        # 1. StyleManager로 실제 적용
        self.style_manager.apply_theme(theme_name)

        # 2. 설정 저장
        self.settings_service.save_setting('ui.theme', theme_name)

        # 3. 새로운 시그널 발행
        self.theme_changed.emit(theme_name)

        # 4. 기존 시스템과 연결 (중요!)
        self._notify_theme_changed(theme_name)

    def _notify_theme_changed(self, theme_name: str):
        """기존 theme_notifier와 연결"""
        try:
            from upbit_auto_trading.ui.desktop.components.style.theme_notifier import theme_notifier
            theme_notifier.theme_changed.emit(theme_name)
        except ImportError:
            pass  # 기존 시스템이 없으면 무시
```

---

### 🟡 Problem #5: 설정 마이그레이션 충돌
**문제 상황**:
```python
# QSettings와 Infrastructure Layer 설정이 충돌
QSettings: theme = 'light'
ConfigLoader: theme = 'dark'
# 어느 것이 우선인지 모호함
```

**해결책**:
```python
def _load_theme(self):
    """우선순위 기반 설정 로드"""
    theme = 'light'  # 기본값

    # 1순위: Infrastructure Layer (새로운 방식)
    if self.settings_service:
        try:
            theme = self.settings_service.get_setting('ui.theme', theme)
            self._log_info(f"✅ IL에서 테마 로드: {theme}")
            return theme
        except Exception as e:
            self._log_warning(f"IL 테마 로드 실패: {e}")

    # 2순위: QSettings (기존 방식)
    try:
        settings = QSettings('UpbitAutoTrader', 'MainWindow')
        theme = settings.value('theme', theme)
        self._log_info(f"QSettings에서 테마 로드: {theme}")

        # 마이그레이션: IL로 복사
        if self.settings_service:
            self.settings_service.save_setting('ui.theme', theme)
            self._log_info("✅ 테마 설정 IL로 마이그레이션 완료")

    except Exception as e:
        self._log_warning(f"QSettings 테마 로드 실패: {e}")

    return theme
```

## 🧪 Testing 문제들

### 🔴 Problem #6: Qt 컴포넌트 테스트 실패
**문제 상황**:
```python
# 테스트 실행 시 Qt 메타클래스 오류
TypeError: metaclass conflict: the metaclass of a derived class
must be a (non-strict) subclass of the metaclasses of all its bases
```

**원인**: Qt 컴포넌트와 일반 Python 클래스 간 메타클래스 충돌

**해결책**:
```python
# 테스트용 Mock 객체 생성
class MockThemeService:  # QObject 상속하지 않음
    def __init__(self):
        self.current_theme = 'light'
        self.theme_changed_callbacks = []

    def set_theme(self, theme_name: str):
        self.current_theme = theme_name
        for callback in self.theme_changed_callbacks:
            callback(theme_name)

    def get_current_theme(self) -> str:
        return self.current_theme

# 테스트에서 Mock 사용
def test_theme_service():
    mock_theme_service = MockThemeService()
    mock_theme_service.set_theme('dark')
    assert mock_theme_service.get_current_theme() == 'dark'
```

---

### 🟡 Problem #7: 메모리 누수 테스트 실패
**문제 상황**:
```python
# Qt 애플리케이션 테스트에서 메모리 정리 안됨
QApplication instance already exists
```

**해결책**:
```python
import gc
from PyQt6.QtWidgets import QApplication

def test_memory_leak_safe():
    """안전한 메모리 누수 테스트"""
    app = None
    try:
        # 기존 QApplication 확인
        existing_app = QApplication.instance()
        if existing_app is None:
            app = QApplication([])

        # 테스트 로직
        initial_memory = get_memory_usage()

        # 서비스 생성/해제 반복
        for i in range(100):
            service = create_test_service()
            del service
            gc.collect()

        final_memory = get_memory_usage()
        memory_increase = final_memory - initial_memory

        # 10% 이내 증가면 정상
        assert memory_increase < initial_memory * 0.1

    finally:
        # 정리
        if app:
            app.quit()
            del app
        gc.collect()
```

## 📊 Performance 문제들

### 🟡 Problem #8: DI Container 해결 성능 저하
**문제 상황**:
```python
# 매번 resolve()할 때마다 느려짐
for i in range(1000):
    service = di_container.resolve('HeavyService')  # 매번 생성?
```

**해결책**:
```python
# 싱글톤 vs 임시 객체 올바른 선택
class ServiceRegistration:
    def register_services(self, di_container):
        # 무거운 객체는 싱글톤
        di_container.register_singleton('StyleManager', StyleManager)
        di_container.register_singleton('DatabaseService', DatabaseService)

        # 가벼운 객체나 상태를 가져야 하는 객체는 임시
        di_container.register_transient('RequestHandler', RequestHandler)
        di_container.register_transient('DataProcessor', DataProcessor)

# 캐싱 패턴 적용
class MainWindow:
    def __init__(self, di_container):
        self.di_container = di_container
        self._cached_services = {}

    def get_service(self, service_name):
        if service_name not in self._cached_services:
            self._cached_services[service_name] = self.di_container.resolve(service_name)
        return self._cached_services[service_name]
```

## 🛠️ 일반적인 디버깅 기법

### 로깅 기반 디버깅
```python
def debug_di_container(di_container):
    """DI Container 상태 디버깅"""
    logger = LoggerFactory.get_logger("DI_DEBUG")

    # 등록된 서비스 목록
    registered_services = di_container.get_registered_services()
    logger.info(f"등록된 서비스: {list(registered_services.keys())}")

    # 의존성 체인 검증
    for service_name in registered_services:
        try:
            service = di_container.resolve(service_name)
            logger.info(f"✅ {service_name}: {type(service).__name__}")
        except Exception as e:
            logger.error(f"❌ {service_name}: {e}")

def debug_theme_system():
    """테마 시스템 디버깅"""
    logger = LoggerFactory.get_logger("THEME_DEBUG")

    # 각 단계별 확인
    logger.info("=== 테마 시스템 디버깅 ===")

    # 1. ThemeService 존재 확인
    if hasattr(self, 'theme_service'):
        logger.info(f"✅ ThemeService: {type(self.theme_service).__name__}")
        logger.info(f"현재 테마: {self.theme_service.get_current_theme()}")
    else:
        logger.error("❌ ThemeService 없음")

    # 2. StyleManager 확인
    if hasattr(self, 'style_manager'):
        logger.info(f"✅ StyleManager: {type(self.style_manager).__name__}")
    else:
        logger.error("❌ StyleManager 없음")

    # 3. theme_notifier 확인
    try:
        from upbit_auto_trading.ui.desktop.components.style.theme_notifier import theme_notifier
        logger.info("✅ theme_notifier 사용 가능")
    except ImportError as e:
        logger.error(f"❌ theme_notifier 없음: {e}")
```

### 단계별 검증 패턴
```python
def verify_infrastructure_integration():
    """Infrastructure Layer 통합 단계별 검증"""
    checks = []

    # 1. ApplicationContext 확인
    try:
        from upbit_auto_trading.infrastructure.application_context import ApplicationContext
        checks.append("✅ ApplicationContext import 성공")
    except ImportError as e:
        checks.append(f"❌ ApplicationContext import 실패: {e}")
        return checks

    # 2. ApplicationContext 초기화 확인
    try:
        ApplicationContext.initialize()
        checks.append("✅ ApplicationContext 초기화 성공")
    except Exception as e:
        checks.append(f"❌ ApplicationContext 초기화 실패: {e}")
        return checks

    # 3. DI Container 확인
    try:
        di_container = ApplicationContext.get_di_container()
        checks.append(f"✅ DI Container 획득: {type(di_container).__name__}")
    except Exception as e:
        checks.append(f"❌ DI Container 획득 실패: {e}")

    return checks
```

## 🎯 예방 지침

### 개발 시 체크리스트
```markdown
## Infrastructure Layer 통합 전 체크리스트

### 환경 준비
- [ ] 가상환경 활성화 확인 (`python --version` 체크)
- [ ] VSCode Python 인터프리터 설정 확인
- [ ] .vscode/settings.json 백업
- [ ] 기존 코드 백업 (run_desktop_ui_old.py, main_window_old.py)

### 의존성 설계
- [ ] 의존성 그래프 작성
- [ ] 순환 참조 검증
- [ ] 인터페이스 정의 완료
- [ ] Mock 객체 준비 (테스트용)

### 통합 과정
- [ ] 한 번에 하나의 서비스만 통합
- [ ] 각 단계마다 애플리케이션 실행 테스트
- [ ] 폴백 메커니즘 구현
- [ ] 로깅으로 상태 추적

### 테스트
- [ ] 단위 테스트 통과 확인
- [ ] 통합 테스트 시나리오 실행
- [ ] 메모리 누수 테스트
- [ ] 성능 regression 체크
```

### 코드 리뷰 체크포인트
```python
# 1. DI 등록 순서 확인
def check_di_registration_order():
    """의존성 등록 순서가 올바른가?"""
    # 기본 서비스 → 의존성 있는 서비스 순으로 등록되었는가?

# 2. 폴백 메커니즘 확인
def check_fallback_mechanism():
    """DI 실패 시 폴백이 있는가?"""
    # try-except로 기존 방식 보장하는가?

# 3. 리소스 정리 확인
def check_resource_cleanup():
    """리소스 정리가 적절한가?"""
    # dispose() 메서드나 컨텍스트 매니저 사용하는가?

# 4. 로깅 일관성 확인
def check_logging_consistency():
    """로깅이 일관되게 적용되었는가?"""
    # print() 대신 구조화된 로깅 사용하는가?
```

이 문서를 통해 같은 문제를 겪는 개발자들이 빠르게 해결책을 찾고, 더 나은 코드를 작성할 수 있기를 바랍니다. 문제가 해결되지 않으면 로깅을 상세히 남기고 단계별로 검증하는 것이 핵심입니다.
