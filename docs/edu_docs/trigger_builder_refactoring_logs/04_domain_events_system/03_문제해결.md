# ğŸ”§ ë„ë©”ì¸ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ ë¬¸ì œí•´ê²° ê°€ì´ë“œ

> **ëŒ€ìƒ**: ë„ë©”ì¸ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì—ì„œ ë¬¸ì œë¥¼ ê²ªê³  ìˆëŠ” ê°œë°œì  
> **ëª©ì **: ì‹¤ì œ ë¬¸ì œ ìƒí™©ê³¼ í•´ê²°ì±… ì œê³µ  
> **ë²”ìœ„**: êµ¬í˜„, ì„±ëŠ¥, ë©”ëª¨ë¦¬, í†µí•© ë¬¸ì œ í¬ê´„

## ğŸš¨ ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œë“¤

### ğŸ“‹ ë¬¸ì œ ì¹´í…Œê³ ë¦¬
1. **êµ¬í˜„ ë¬¸ì œ**: ê¸°ë³¸ êµ¬ì¡°ì™€ íŒ¨í„´ ê´€ë ¨
2. **ì„±ëŠ¥ ë¬¸ì œ**: ì²˜ë¦¬ ì†ë„ì™€ í™•ì¥ì„± ê´€ë ¨  
3. **ë©”ëª¨ë¦¬ ë¬¸ì œ**: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ì™€ ìì› ê´€ë¦¬
4. **í†µí•© ë¬¸ì œ**: ë‹¤ë¥¸ ì‹œìŠ¤í…œê³¼ì˜ ì—°ë™
5. **í…ŒìŠ¤íŠ¸ ë¬¸ì œ**: í…ŒìŠ¤íŠ¸ ì‘ì„±ê³¼ ê²€ì¦

## ğŸ› ï¸ êµ¬í˜„ ë¬¸ì œ í•´ê²°

### ë¬¸ì œ 1: "dataclass ìƒì† ì¶©ëŒ"
```
TypeError: multiple bases have instance lay-out conflict
```

#### ì¦ìƒ
- `@dataclass`ì™€ `DomainEvent` ë™ì‹œ ìƒì† ì‹œ ë°œìƒ
- Pythonì˜ ë‹¤ì¤‘ ìƒì† ì œì•½ ë•Œë¬¸ì— ë°œìƒ

#### í•´ê²°ì±…
```python
# âŒ ë¬¸ì œê°€ ë˜ëŠ” ì½”ë“œ
@dataclass
class TriggerCreated(DomainEvent):
    trigger_id: str
    trigger_name: str

# âœ… í•´ê²°ëœ ì½”ë“œ
class TriggerCreated(DomainEvent):
    def __init__(self, trigger_id: str, trigger_name: str):
        super().__init__()
        self.trigger_id = trigger_id
        self.trigger_name = trigger_name
        
    @property
    def event_type(self) -> str:
        return "trigger.created"
```

#### ì¶”ê°€ íŒ
- DDD ì›ì¹™ì—ì„œëŠ” ì¼ë°˜ í´ë˜ìŠ¤ ì‚¬ìš©ì´ ë” ì í•©
- íƒ€ì… íŒíŠ¸ë¡œ ì•ˆì „ì„± í™•ë³´
- `__post_init__` ë©”ì„œë“œë¡œ ì¶”ê°€ ê²€ì¦ ê°€ëŠ¥

### ë¬¸ì œ 2: "ì´ë²¤íŠ¸ íƒ€ì… ë„¤ì´ë° ì¼ê´€ì„±"
```
KeyError: 'strategy_created' vs 'strategy.created'
```

#### ì¦ìƒ
- ì´ë²¤íŠ¸ íƒ€ì… ëª…ëª… ê·œì¹™ ë¶ˆì¼ì¹˜
- í•¸ë“¤ëŸ¬ ë“±ë¡ê³¼ ë°œí–‰ ì‹œ íƒ€ì… ë¶ˆì¼ì¹˜

#### í•´ê²°ì±…
```python
# âœ… ì¼ê´€ëœ ë„¤ì´ë° ê·œì¹™ ì ìš©
class EventTypes:
    """ì´ë²¤íŠ¸ íƒ€ì… ìƒìˆ˜ ê´€ë¦¬"""
    STRATEGY_CREATED = "strategy.created"
    STRATEGY_UPDATED = "strategy.updated"
    TRIGGER_CREATED = "trigger.created"
    
class StrategyCreated(DomainEvent):
    @property
    def event_type(self) -> str:
        return EventTypes.STRATEGY_CREATED
```

#### ëª¨ë²” ì‚¬ë¡€
- `{ë„ë©”ì¸}.{ì•¡ì…˜}` í˜•ì‹ í†µì¼
- ìƒìˆ˜ í´ë˜ìŠ¤ë¡œ ì¤‘ì•™ ê´€ë¦¬
- IDE ìë™ì™„ì„± í™œìš© ê°€ëŠ¥

### ë¬¸ì œ 3: "Required Field ê²€ì¦ ëˆ„ë½"
```
AttributeError: 'NoneType' object has no attribute 'strategy_id'
```

#### ì¦ìƒ
- í•„ìˆ˜ í•„ë“œ ê²€ì¦ ëˆ„ë½ìœ¼ë¡œ None ê°’ ì „ë‹¬
- ëŸ°íƒ€ì„ì—ì„œ ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬ ë°œìƒ

#### í•´ê²°ì±…
```python
class StrategyCreated(DomainEvent):
    def __init__(self, strategy_id: str, strategy_name: str):
        super().__init__()
        
        # âœ… í•„ìˆ˜ í•„ë“œ ê²€ì¦
        if not strategy_id:
            raise ValueError("strategy_idëŠ” í•„ìˆ˜ í•„ë“œì…ë‹ˆë‹¤")
        if not strategy_name:
            raise ValueError("strategy_nameì€ í•„ìˆ˜ í•„ë“œì…ë‹ˆë‹¤")
            
        self._strategy_id = strategy_id
        self._strategy_name = strategy_name
```

#### ê³ ê¸‰ ê²€ì¦ íŒ¨í„´
```python
from typing import Union

def validate_required(value: Union[str, int], field_name: str):
    """ë²”ìš© í•„ìˆ˜ í•„ë“œ ê²€ì¦ í•¨ìˆ˜"""
    if value is None or (isinstance(value, str) and not value.strip()):
        raise ValueError(f"{field_name}ëŠ” í•„ìˆ˜ í•„ë“œì…ë‹ˆë‹¤")
    return value

class StrategyCreated(DomainEvent):
    def __init__(self, strategy_id: str, strategy_name: str):
        super().__init__()
        self._strategy_id = validate_required(strategy_id, "strategy_id")
        self._strategy_name = validate_required(strategy_name, "strategy_name")
```

## âš¡ ì„±ëŠ¥ ë¬¸ì œ í•´ê²°

### ë¬¸ì œ 4: "ì´ë²¤íŠ¸ ë°œí–‰ ì„±ëŠ¥ ì €í•˜"
```
ì²˜ë¦¬ ì†ë„: 100 events/sec (ëª©í‘œ: 10,000+ events/sec)
```

#### ì¦ìƒ
- ëŒ€ëŸ‰ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œ ì„±ëŠ¥ ì €í•˜
- UI ë¸”ë¡œí‚¹ ë°œìƒ

#### ì§„ë‹¨ ë°©ë²•
```python
import time
import cProfile

def profile_event_publishing():
    """ì´ë²¤íŠ¸ ë°œí–‰ ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§"""
    publisher = DomainEventPublisher()
    
    # ì„±ëŠ¥ ì¸¡ì •
    start_time = time.time()
    
    for i in range(1000):
        event = StrategyCreated(f"STR_{i}", f"ì „ëµ_{i}")
        publisher.publish(event)
    
    end_time = time.time()
    events_per_second = 1000 / (end_time - start_time)
    print(f"ì„±ëŠ¥: {events_per_second:.0f} events/sec")

# cProfileë¡œ ìƒì„¸ ë¶„ì„
cProfile.run('profile_event_publishing()')
```

#### í•´ê²°ì±… 1: í•¸ë“¤ëŸ¬ ìºì‹±
```python
class OptimizedPublisher:
    def __init__(self):
        self._handlers_cache = {}
        self._cache_dirty = True
    
    def _rebuild_cache(self):
        """í•¸ë“¤ëŸ¬ ìºì‹œ ì¬êµ¬ì„±"""
        if self._cache_dirty:
            # ìì£¼ ì‚¬ìš©ë˜ëŠ” ì´ë²¤íŠ¸ íƒ€ì…ì„ ìºì‹œ
            for event_type in self._handlers:
                self._handlers_cache[event_type] = self._handlers[event_type].copy()
            self._cache_dirty = False
    
    def publish(self, event):
        """ìºì‹œëœ í•¸ë“¤ëŸ¬ë¡œ ë¹ ë¥¸ ë°œí–‰"""
        self._rebuild_cache()
        
        event_type = event.event_type
        handlers = self._handlers_cache.get(event_type, [])
        
        for handler in handlers:
            handler(event)
```

#### í•´ê²°ì±… 2: ë°°ì¹˜ ì²˜ë¦¬
```python
class BatchPublisher:
    def __init__(self, batch_size=100):
        self._batch_size = batch_size
        self._batch_events = []
        
    def publish(self, event):
        """ë°°ì¹˜ì— ì´ë²¤íŠ¸ ì¶”ê°€"""
        self._batch_events.append(event)
        
        if len(self._batch_events) >= self._batch_size:
            self._flush_batch()
    
    def _flush_batch(self):
        """ë°°ì¹˜ ì´ë²¤íŠ¸ ì¼ê´„ ì²˜ë¦¬"""
        try:
            for event in self._batch_events:
                self._process_single_event(event)
        finally:
            self._batch_events.clear()
```

### ë¬¸ì œ 5: "í•¸ë“¤ëŸ¬ ì‹¤í–‰ ë¸”ë¡œí‚¹"
```
UI ì‘ë‹µì„± ì €í•˜: í•¸ë“¤ëŸ¬ê°€ ì˜¤ë˜ ê±¸ë¦¬ëŠ” ì‘ì—… ì‹¤í–‰
```

#### í•´ê²°ì±…: ë¹„ë™ê¸° ì²˜ë¦¬
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncPublisher:
    def __init__(self):
        self._executor = ThreadPoolExecutor(max_workers=4)
        
    def publish_async(self, event):
        """ë¹„ë™ê¸° ì´ë²¤íŠ¸ ë°œí–‰"""
        asyncio.create_task(self._async_publish(event))
    
    async def _async_publish(self, event):
        """ë¹„ë™ê¸° í•¸ë“¤ëŸ¬ ì‹¤í–‰"""
        loop = asyncio.get_event_loop()
        
        for handler in self._get_handlers(event.event_type):
            if asyncio.iscoroutinefunction(handler):
                await handler(event)
            else:
                # ë™ê¸° í•¸ë“¤ëŸ¬ëŠ” ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
                await loop.run_in_executor(self._executor, handler, event)
```

## ğŸ’¾ ë©”ëª¨ë¦¬ ë¬¸ì œ í•´ê²°

### ë¬¸ì œ 6: "í•¸ë“¤ëŸ¬ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜"
```
ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ê³„ì† ì¦ê°€: 5.6% â†’ 15% â†’ 30%
```

#### ì§„ë‹¨ ë°©ë²•
```python
import psutil
import gc

def monitor_memory_usage():
    """ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§"""
    process = psutil.Process()
    
    initial_memory = process.memory_percent()
    print(f"ì´ˆê¸° ë©”ëª¨ë¦¬: {initial_memory:.2f}%")
    
    # ëŒ€ëŸ‰ ì´ë²¤íŠ¸ ì²˜ë¦¬
    for i in range(1000):
        publisher.subscribe(f"test.{i}", lambda e: None)
    
    # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
    gc.collect()
    
    final_memory = process.memory_percent()
    print(f"ìµœì¢… ë©”ëª¨ë¦¬: {final_memory:.2f}%")
    print(f"ì¦ê°€ëŸ‰: {final_memory - initial_memory:.2f}%")
```

#### í•´ê²°ì±… 1: ì•½í•œ ì°¸ì¡° ì‚¬ìš©
```python
import weakref

class WeakRefPublisher:
    def __init__(self):
        self._weak_handlers = {}
    
    def subscribe(self, event_type, handler):
        """ì•½í•œ ì°¸ì¡°ë¡œ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        if event_type not in self._weak_handlers:
            self._weak_handlers[event_type] = []
            
        # ì•½í•œ ì°¸ì¡°ë¡œ ì €ì¥
        weak_handler = weakref.ref(handler)
        self._weak_handlers[event_type].append(weak_handler)
    
    def publish(self, event):
        """ì•½í•œ ì°¸ì¡° í•¸ë“¤ëŸ¬ë¡œ ë°œí–‰"""
        event_type = event.event_type
        
        if event_type in self._weak_handlers:
            alive_handlers = []
            
            for weak_handler in self._weak_handlers[event_type]:
                handler = weak_handler()  # ì•½í•œ ì°¸ì¡° í•´ì œ
                
                if handler is not None:
                    handler(event)
                    alive_handlers.append(weak_handler)
            
            # ì£½ì€ í•¸ë“¤ëŸ¬ ì œê±°
            self._weak_handlers[event_type] = alive_handlers
```

#### í•´ê²°ì±… 2: í•¸ë“¤ëŸ¬ ì •ë¦¬ ì‹œìŠ¤í…œ
```python
class ManagedPublisher:
    def __init__(self):
        self._handlers = {}
        self._handler_metadata = {}
        
    def subscribe_with_lifecycle(self, event_type, handler, owner=None):
        """ìƒëª…ì£¼ê¸° ê´€ë¦¬ë˜ëŠ” í•¸ë“¤ëŸ¬ ë“±ë¡"""
        handler_id = id(handler)
        
        if event_type not in self._handlers:
            self._handlers[event_type] = {}
            
        self._handlers[event_type][handler_id] = handler
        self._handler_metadata[handler_id] = {
            'owner': owner,
            'registered_at': time.time(),
            'call_count': 0
        }
    
    def cleanup_unused_handlers(self, max_age_hours=24):
        """ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” í•¸ë“¤ëŸ¬ ì •ë¦¬"""
        current_time = time.time()
        removed_count = 0
        
        for handler_id, metadata in list(self._handler_metadata.items()):
            age_hours = (current_time - metadata['registered_at']) / 3600
            
            if age_hours > max_age_hours and metadata['call_count'] == 0:
                self._remove_handler_by_id(handler_id)
                removed_count += 1
        
        print(f"ì •ë¦¬ëœ í•¸ë“¤ëŸ¬ ìˆ˜: {removed_count}")
```

### ë¬¸ì œ 7: "ì´ë²¤íŠ¸ ê°ì²´ ëˆ„ì "
```
ìƒì„±ëœ ì´ë²¤íŠ¸ ê°ì²´ê°€ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ë˜ì§€ ì•ŠìŒ
```

#### í•´ê²°ì±…: ì´ë²¤íŠ¸ í’€ë§
```python
class EventPool:
    """ì´ë²¤íŠ¸ ê°ì²´ ì¬ì‚¬ìš© í’€"""
    
    def __init__(self):
        self._pools = {}
    
    def get_event(self, event_class, *args, **kwargs):
        """í’€ì—ì„œ ì´ë²¤íŠ¸ ê°ì²´ ê°€ì ¸ì˜¤ê¸°"""
        pool_key = event_class.__name__
        
        if pool_key not in self._pools:
            self._pools[pool_key] = []
        
        pool = self._pools[pool_key]
        
        if pool:
            event = pool.pop()
            event._reset(*args, **kwargs)  # ì¬ì´ˆê¸°í™”
            return event
        else:
            return event_class(*args, **kwargs)
    
    def return_event(self, event):
        """ì‚¬ìš© ì™„ë£Œëœ ì´ë²¤íŠ¸ë¥¼ í’€ì— ë°˜í™˜"""
        pool_key = event.__class__.__name__
        
        if pool_key in self._pools and len(self._pools[pool_key]) < 100:
            self._pools[pool_key].append(event)

# ì‚¬ìš© ì˜ˆ
event_pool = EventPool()

def create_strategy_event(strategy_id, name):
    return event_pool.get_event(StrategyCreated, strategy_id, name)
```

## ğŸ”Œ í†µí•© ë¬¸ì œ í•´ê²°

### ë¬¸ì œ 8: "Repository í†µí•© ì‹¤íŒ¨"
```
ì´ë²¤íŠ¸ê°€ ë°œí–‰ë˜ì§€ ì•Šê±°ë‚˜ ì¤‘ë³µ ë°œí–‰ë¨
```

#### ì¦ìƒ
- ì—”í‹°í‹° ì €ì¥ í›„ ì´ë²¤íŠ¸ ë¯¸ë°œí–‰
- ê°™ì€ ì´ë²¤íŠ¸ê°€ ì—¬ëŸ¬ ë²ˆ ë°œí–‰
- íŠ¸ëœì­ì…˜ ë¡¤ë°± ì‹œ ì´ë²¤íŠ¸ ëˆ„ì¶œ

#### í•´ê²°ì±…: Unit of Work íŒ¨í„´
```python
class UnitOfWork:
    """ì‘ì—… ë‹¨ìœ„ íŒ¨í„´ìœ¼ë¡œ ì´ë²¤íŠ¸ ê´€ë¦¬"""
    
    def __init__(self):
        self._entities = []
        self._committed = False
    
    def register_entity(self, entity):
        """ì—”í‹°í‹° ë“±ë¡"""
        self._entities.append(entity)
    
    def commit(self):
        """íŠ¸ëœì­ì…˜ ì»¤ë°‹ ë° ì´ë²¤íŠ¸ ë°œí–‰"""
        try:
            # 1. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
            for entity in self._entities:
                self._save_entity(entity)
            
            # 2. ëª¨ë“  ì €ì¥ ì„±ê³µ ì‹œì—ë§Œ ì´ë²¤íŠ¸ ë°œí–‰
            self._publish_domain_events()
            self._committed = True
            
        except Exception as e:
            # ì‹¤íŒ¨ ì‹œ ë¡¤ë°± (ì´ë²¤íŠ¸ ë°œí–‰ ì•ˆí•¨)
            self._rollback()
            raise e
    
    def _publish_domain_events(self):
        """ë„ë©”ì¸ ì´ë²¤íŠ¸ ì¼ê´„ ë°œí–‰"""
        for entity in self._entities:
            if hasattr(entity, 'get_domain_events'):
                events = entity.get_domain_events()
                
                for event in events:
                    publisher.publish(event)
                
                # ì´ë²¤íŠ¸ í´ë¦¬ì–´
                entity.clear_domain_events()
```

### ë¬¸ì œ 9: "ì™¸ë¶€ ì‹œìŠ¤í…œ ì—°ë™ ì‹¤íŒ¨"
```
ì™¸ë¶€ API í˜¸ì¶œ ì‹œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì¤‘ë‹¨
```

#### í•´ê²°ì±…: Outbox íŒ¨í„´
```python
class EventOutbox:
    """ì™¸ë¶€ ì‹œìŠ¤í…œ ì—°ë™ì„ ìœ„í•œ ì´ë²¤íŠ¸ ì•„ì›ƒë°•ìŠ¤"""
    
    def __init__(self):
        self._outbox_events = []
        self._failed_events = []
    
    def add_outbound_event(self, event, target_system):
        """ì™¸ë¶€ ì „ì†¡ìš© ì´ë²¤íŠ¸ ì¶”ê°€"""
        outbox_entry = {
            'event': event,
            'target_system': target_system,
            'attempts': 0,
            'created_at': datetime.now(),
            'status': 'pending'
        }
        self._outbox_events.append(outbox_entry)
    
    async def process_outbox(self):
        """ì•„ì›ƒë°•ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬"""
        for entry in self._outbox_events.copy():
            try:
                await self._send_to_external_system(entry)
                entry['status'] = 'sent'
                self._outbox_events.remove(entry)
                
            except Exception as e:
                entry['attempts'] += 1
                
                if entry['attempts'] >= 3:
                    entry['status'] = 'failed'
                    self._failed_events.append(entry)
                    self._outbox_events.remove(entry)
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ë¬¸ì œ í•´ê²°

### ë¬¸ì œ 10: "ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€"
```
ì´ë²¤íŠ¸ ë°œí–‰ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê¸° ì–´ë ¤ì›€
```

#### í•´ê²°ì±…: í…ŒìŠ¤íŠ¸ìš© ì´ë²¤íŠ¸ ìŠ¤íŒŒì´
```python
class EventSpy:
    """í…ŒìŠ¤íŠ¸ìš© ì´ë²¤íŠ¸ ê°ì‹œì"""
    
    def __init__(self):
        self.received_events = []
        self.event_counts = {}
    
    def capture_event(self, event):
        """ì´ë²¤íŠ¸ ìº¡ì²˜"""
        self.received_events.append(event)
        
        event_type = event.event_type
        self.event_counts[event_type] = self.event_counts.get(event_type, 0) + 1
    
    def assert_event_published(self, event_type, count=1):
        """íŠ¹ì • ì´ë²¤íŠ¸ ë°œí–‰ ê²€ì¦"""
        actual_count = self.event_counts.get(event_type, 0)
        assert actual_count == count, f"ì˜ˆìƒ: {count}, ì‹¤ì œ: {actual_count}"
    
    def get_events_of_type(self, event_type):
        """íŠ¹ì • íƒ€ì…ì˜ ì´ë²¤íŠ¸ ë°˜í™˜"""
        return [e for e in self.received_events if e.event_type == event_type]

# í…ŒìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©
def test_strategy_creation_publishes_event():
    # Given
    spy = EventSpy()
    publisher.subscribe_global(spy.capture_event)
    
    # When
    strategy = Strategy.create_new("í…ŒìŠ¤íŠ¸ ì „ëµ")
    repository.save(strategy)
    
    # Then
    spy.assert_event_published("strategy.created", 1)
    created_events = spy.get_events_of_type("strategy.created")
    assert created_events[0].strategy_name == "í…ŒìŠ¤íŠ¸ ì „ëµ"
```

### ë¬¸ì œ 11: "ë¹„ë™ê¸° ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸"
```
ë¹„ë™ê¸° í•¸ë“¤ëŸ¬ì˜ ì‹¤í–‰ ì™„ë£Œë¥¼ í™•ì¸í•˜ê¸° ì–´ë ¤ì›€
```

#### í•´ê²°ì±…: ë™ê¸°í™” ë„êµ¬ í™œìš©
```python
import asyncio
import threading

class AsyncEventTester:
    """ë¹„ë™ê¸° ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸ ë„ìš°ë¯¸"""
    
    def __init__(self):
        self.completion_events = {}
    
    async def wait_for_async_handlers(self, event_type, timeout=5.0):
        """ë¹„ë™ê¸° í•¸ë“¤ëŸ¬ ì™„ë£Œ ëŒ€ê¸°"""
        completion_event = asyncio.Event()
        self.completion_events[event_type] = completion_event
        
        try:
            await asyncio.wait_for(completion_event.wait(), timeout=timeout)
        except asyncio.TimeoutError:
            raise AssertionError(f"ë¹„ë™ê¸° í•¸ë“¤ëŸ¬ íƒ€ì„ì•„ì›ƒ: {event_type}")
    
    def mark_handler_completed(self, event_type):
        """í•¸ë“¤ëŸ¬ ì™„ë£Œ í‘œì‹œ"""
        if event_type in self.completion_events:
            self.completion_events[event_type].set()

# í…ŒìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©
@pytest.mark.asyncio
async def test_async_event_handler():
    # Given
    tester = AsyncEventTester()
    
    async def async_handler(event):
        await asyncio.sleep(0.1)  # ë¹„ë™ê¸° ì‘ì—… ì‹œë®¬ë ˆì´ì…˜
        tester.mark_handler_completed(event.event_type)
    
    publisher.subscribe_async("strategy.created", async_handler)
    
    # When
    event = StrategyCreated("STR_001", "í…ŒìŠ¤íŠ¸")
    publisher.publish(event)
    
    # Then
    await tester.wait_for_async_handlers("strategy.created")
```

## ğŸ“Š ë””ë²„ê¹… ë„êµ¬

### ì´ë²¤íŠ¸ í”Œë¡œìš° ì¶”ì 
```python
class EventTracer:
    """ì´ë²¤íŠ¸ íë¦„ ì¶”ì  ë„êµ¬"""
    
    def __init__(self):
        self.trace_log = []
    
    def trace_event(self, event, action, details=None):
        """ì´ë²¤íŠ¸ ì¶”ì  ë¡œê·¸ ê¸°ë¡"""
        trace_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_id': event.event_id,
            'event_type': event.event_type,
            'action': action,  # 'published', 'handled', 'failed'
            'details': details or {}
        }
        self.trace_log.append(trace_entry)
    
    def print_trace(self, event_id=None):
        """ì¶”ì  ë¡œê·¸ ì¶œë ¥"""
        filtered_log = self.trace_log
        
        if event_id:
            filtered_log = [entry for entry in self.trace_log 
                          if entry['event_id'] == event_id]
        
        for entry in filtered_log:
            print(f"[{entry['timestamp']}] {entry['action']}: "
                  f"{entry['event_type']} ({entry['event_id']})")

# ì „ì—­ ì¶”ì ê¸°
tracer = EventTracer()

# ë°œí–‰ìì— ì¶”ì  ê¸°ëŠ¥ ì¶”ê°€
original_publish = publisher.publish

def traced_publish(event):
    tracer.trace_event(event, 'published')
    try:
        result = original_publish(event)
        tracer.trace_event(event, 'handled')
        return result
    except Exception as e:
        tracer.trace_event(event, 'failed', {'error': str(e)})
        raise

publisher.publish = traced_publish
```

## ğŸ¯ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

### ìš´ì˜ í™˜ê²½ ëª¨ë‹ˆí„°ë§
```python
class EventMetrics:
    """ì´ë²¤íŠ¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
    
    def __init__(self):
        self.metrics = {
            'events_published': 0,
            'handlers_executed': 0,
            'errors_count': 0,
            'avg_processing_time': 0.0
        }
        
    def record_event_published(self):
        self.metrics['events_published'] += 1
    
    def record_handler_executed(self, processing_time):
        self.metrics['handlers_executed'] += 1
        
        # ì´ë™ í‰ê·  ê³„ì‚°
        current_avg = self.metrics['avg_processing_time']
        count = self.metrics['handlers_executed']
        self.metrics['avg_processing_time'] = (
            (current_avg * (count - 1) + processing_time) / count
        )
    
    def get_health_status(self):
        """ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸"""
        error_rate = (self.metrics['errors_count'] / 
                     max(1, self.metrics['events_published']))
        
        if error_rate > 0.05:  # 5% ì´ìƒ ì—ëŸ¬ìœ¨
            return "UNHEALTHY"
        elif self.metrics['avg_processing_time'] > 1.0:  # 1ì´ˆ ì´ìƒ ì²˜ë¦¬ ì‹œê°„
            return "DEGRADED"
        else:
            return "HEALTHY"
```

## ğŸ” ì²´í¬ë¦¬ìŠ¤íŠ¸

### ë¬¸ì œ ë°œìƒ ì‹œ í™•ì¸ì‚¬í•­
- [ ] ì´ë²¤íŠ¸ íƒ€ì… ë„¤ì´ë°ì´ ì¼ê´€ë˜ëŠ”ê°€?
- [ ] í•„ìˆ˜ í•„ë“œ ê²€ì¦ì´ ëˆ„ë½ë˜ì§€ ì•Šì•˜ëŠ”ê°€?
- [ ] í•¸ë“¤ëŸ¬ì—ì„œ ì˜ˆì™¸ê°€ ì ì ˆíˆ ì²˜ë¦¬ë˜ëŠ”ê°€?
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ê°€?
- [ ] ë¹„ë™ê¸° ì²˜ë¦¬ê°€ ì˜¬ë°”ë¥´ê²Œ êµ¬í˜„ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ê°€ ì¶©ë¶„í•œê°€?

### ì„±ëŠ¥ ìµœì í™” ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] í•¸ë“¤ëŸ¬ ìºì‹±ì´ í™œìš©ë˜ê³  ìˆëŠ”ê°€?
- [ ] ë°°ì¹˜ ì²˜ë¦¬ê°€ ì ìš©ë˜ì—ˆëŠ”ê°€?
- [ ] ë¶ˆí•„ìš”í•œ ì´ë²¤íŠ¸ ìƒì„±ì´ ì œê±°ë˜ì—ˆëŠ”ê°€?
- [ ] ì•½í•œ ì°¸ì¡°ë¡œ ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ë˜ê³  ìˆëŠ”ê°€?

---

**ğŸ’¡ ë¬¸ì œí•´ê²° í•µì‹¬ ì›ì¹™**: ë¬¸ì œë¥¼ ìˆ¨ê¸°ì§€ ë§ê³  ëª…í™•íˆ ì§„ë‹¨í•˜ê³  í•´ê²°í•˜ì. ë¡œê¹…ê³¼ ëª¨ë‹ˆí„°ë§ì„ í†µí•´ ë¬¸ì œë¥¼ ì¡°ê¸°ì— ë°œê²¬í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.
