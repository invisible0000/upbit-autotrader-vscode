# 🔧 도메인 이벤트 시스템 문제해결 가이드

> **대상**: 도메인 이벤트 시스템에서 문제를 겪고 있는 개발자  
> **목적**: 실제 문제 상황과 해결책 제공  
> **범위**: 구현, 성능, 메모리, 통합 문제 포괄

## 🚨 자주 발생하는 문제들

### 📋 문제 카테고리
1. **구현 문제**: 기본 구조와 패턴 관련
2. **성능 문제**: 처리 속도와 확장성 관련  
3. **메모리 문제**: 메모리 누수와 자원 관리
4. **통합 문제**: 다른 시스템과의 연동
5. **테스트 문제**: 테스트 작성과 검증

## 🛠️ 구현 문제 해결

### 문제 1: "dataclass 상속 충돌"
```
TypeError: multiple bases have instance lay-out conflict
```

#### 증상
- `@dataclass`와 `DomainEvent` 동시 상속 시 발생
- Python의 다중 상속 제약 때문에 발생

#### 해결책
```python
# ❌ 문제가 되는 코드
@dataclass
class TriggerCreated(DomainEvent):
    trigger_id: str
    trigger_name: str

# ✅ 해결된 코드
class TriggerCreated(DomainEvent):
    def __init__(self, trigger_id: str, trigger_name: str):
        super().__init__()
        self.trigger_id = trigger_id
        self.trigger_name = trigger_name
        
    @property
    def event_type(self) -> str:
        return "trigger.created"
```

#### 추가 팁
- DDD 원칙에서는 일반 클래스 사용이 더 적합
- 타입 힌트로 안전성 확보
- `__post_init__` 메서드로 추가 검증 가능

### 문제 2: "이벤트 타입 네이밍 일관성"
```
KeyError: 'strategy_created' vs 'strategy.created'
```

#### 증상
- 이벤트 타입 명명 규칙 불일치
- 핸들러 등록과 발행 시 타입 불일치

#### 해결책
```python
# ✅ 일관된 네이밍 규칙 적용
class EventTypes:
    """이벤트 타입 상수 관리"""
    STRATEGY_CREATED = "strategy.created"
    STRATEGY_UPDATED = "strategy.updated"
    TRIGGER_CREATED = "trigger.created"
    
class StrategyCreated(DomainEvent):
    @property
    def event_type(self) -> str:
        return EventTypes.STRATEGY_CREATED
```

#### 모범 사례
- `{도메인}.{액션}` 형식 통일
- 상수 클래스로 중앙 관리
- IDE 자동완성 활용 가능

### 문제 3: "Required Field 검증 누락"
```
AttributeError: 'NoneType' object has no attribute 'strategy_id'
```

#### 증상
- 필수 필드 검증 누락으로 None 값 전달
- 런타임에서 예상치 못한 에러 발생

#### 해결책
```python
class StrategyCreated(DomainEvent):
    def __init__(self, strategy_id: str, strategy_name: str):
        super().__init__()
        
        # ✅ 필수 필드 검증
        if not strategy_id:
            raise ValueError("strategy_id는 필수 필드입니다")
        if not strategy_name:
            raise ValueError("strategy_name은 필수 필드입니다")
            
        self._strategy_id = strategy_id
        self._strategy_name = strategy_name
```

#### 고급 검증 패턴
```python
from typing import Union

def validate_required(value: Union[str, int], field_name: str):
    """범용 필수 필드 검증 함수"""
    if value is None or (isinstance(value, str) and not value.strip()):
        raise ValueError(f"{field_name}는 필수 필드입니다")
    return value

class StrategyCreated(DomainEvent):
    def __init__(self, strategy_id: str, strategy_name: str):
        super().__init__()
        self._strategy_id = validate_required(strategy_id, "strategy_id")
        self._strategy_name = validate_required(strategy_name, "strategy_name")
```

## ⚡ 성능 문제 해결

### 문제 4: "이벤트 발행 성능 저하"
```
처리 속도: 100 events/sec (목표: 10,000+ events/sec)
```

#### 증상
- 대량 이벤트 처리 시 성능 저하
- UI 블로킹 발생

#### 진단 방법
```python
import time
import cProfile

def profile_event_publishing():
    """이벤트 발행 성능 프로파일링"""
    publisher = DomainEventPublisher()
    
    # 성능 측정
    start_time = time.time()
    
    for i in range(1000):
        event = StrategyCreated(f"STR_{i}", f"전략_{i}")
        publisher.publish(event)
    
    end_time = time.time()
    events_per_second = 1000 / (end_time - start_time)
    print(f"성능: {events_per_second:.0f} events/sec")

# cProfile로 상세 분석
cProfile.run('profile_event_publishing()')
```

#### 해결책 1: 핸들러 캐싱
```python
class OptimizedPublisher:
    def __init__(self):
        self._handlers_cache = {}
        self._cache_dirty = True
    
    def _rebuild_cache(self):
        """핸들러 캐시 재구성"""
        if self._cache_dirty:
            # 자주 사용되는 이벤트 타입을 캐시
            for event_type in self._handlers:
                self._handlers_cache[event_type] = self._handlers[event_type].copy()
            self._cache_dirty = False
    
    def publish(self, event):
        """캐시된 핸들러로 빠른 발행"""
        self._rebuild_cache()
        
        event_type = event.event_type
        handlers = self._handlers_cache.get(event_type, [])
        
        for handler in handlers:
            handler(event)
```

#### 해결책 2: 배치 처리
```python
class BatchPublisher:
    def __init__(self, batch_size=100):
        self._batch_size = batch_size
        self._batch_events = []
        
    def publish(self, event):
        """배치에 이벤트 추가"""
        self._batch_events.append(event)
        
        if len(self._batch_events) >= self._batch_size:
            self._flush_batch()
    
    def _flush_batch(self):
        """배치 이벤트 일괄 처리"""
        try:
            for event in self._batch_events:
                self._process_single_event(event)
        finally:
            self._batch_events.clear()
```

### 문제 5: "핸들러 실행 블로킹"
```
UI 응답성 저하: 핸들러가 오래 걸리는 작업 실행
```

#### 해결책: 비동기 처리
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AsyncPublisher:
    def __init__(self):
        self._executor = ThreadPoolExecutor(max_workers=4)
        
    def publish_async(self, event):
        """비동기 이벤트 발행"""
        asyncio.create_task(self._async_publish(event))
    
    async def _async_publish(self, event):
        """비동기 핸들러 실행"""
        loop = asyncio.get_event_loop()
        
        for handler in self._get_handlers(event.event_type):
            if asyncio.iscoroutinefunction(handler):
                await handler(event)
            else:
                # 동기 핸들러는 별도 스레드에서 실행
                await loop.run_in_executor(self._executor, handler, event)
```

## 💾 메모리 문제 해결

### 문제 6: "핸들러 메모리 누수"
```
메모리 사용량이 계속 증가: 5.6% → 15% → 30%
```

#### 진단 방법
```python
import psutil
import gc

def monitor_memory_usage():
    """메모리 사용량 모니터링"""
    process = psutil.Process()
    
    initial_memory = process.memory_percent()
    print(f"초기 메모리: {initial_memory:.2f}%")
    
    # 대량 이벤트 처리
    for i in range(1000):
        publisher.subscribe(f"test.{i}", lambda e: None)
    
    # 가비지 컬렉션 강제 실행
    gc.collect()
    
    final_memory = process.memory_percent()
    print(f"최종 메모리: {final_memory:.2f}%")
    print(f"증가량: {final_memory - initial_memory:.2f}%")
```

#### 해결책 1: 약한 참조 사용
```python
import weakref

class WeakRefPublisher:
    def __init__(self):
        self._weak_handlers = {}
    
    def subscribe(self, event_type, handler):
        """약한 참조로 핸들러 등록"""
        if event_type not in self._weak_handlers:
            self._weak_handlers[event_type] = []
            
        # 약한 참조로 저장
        weak_handler = weakref.ref(handler)
        self._weak_handlers[event_type].append(weak_handler)
    
    def publish(self, event):
        """약한 참조 핸들러로 발행"""
        event_type = event.event_type
        
        if event_type in self._weak_handlers:
            alive_handlers = []
            
            for weak_handler in self._weak_handlers[event_type]:
                handler = weak_handler()  # 약한 참조 해제
                
                if handler is not None:
                    handler(event)
                    alive_handlers.append(weak_handler)
            
            # 죽은 핸들러 제거
            self._weak_handlers[event_type] = alive_handlers
```

#### 해결책 2: 핸들러 정리 시스템
```python
class ManagedPublisher:
    def __init__(self):
        self._handlers = {}
        self._handler_metadata = {}
        
    def subscribe_with_lifecycle(self, event_type, handler, owner=None):
        """생명주기 관리되는 핸들러 등록"""
        handler_id = id(handler)
        
        if event_type not in self._handlers:
            self._handlers[event_type] = {}
            
        self._handlers[event_type][handler_id] = handler
        self._handler_metadata[handler_id] = {
            'owner': owner,
            'registered_at': time.time(),
            'call_count': 0
        }
    
    def cleanup_unused_handlers(self, max_age_hours=24):
        """사용되지 않는 핸들러 정리"""
        current_time = time.time()
        removed_count = 0
        
        for handler_id, metadata in list(self._handler_metadata.items()):
            age_hours = (current_time - metadata['registered_at']) / 3600
            
            if age_hours > max_age_hours and metadata['call_count'] == 0:
                self._remove_handler_by_id(handler_id)
                removed_count += 1
        
        print(f"정리된 핸들러 수: {removed_count}")
```

### 문제 7: "이벤트 객체 누적"
```
생성된 이벤트 객체가 가비지 컬렉션되지 않음
```

#### 해결책: 이벤트 풀링
```python
class EventPool:
    """이벤트 객체 재사용 풀"""
    
    def __init__(self):
        self._pools = {}
    
    def get_event(self, event_class, *args, **kwargs):
        """풀에서 이벤트 객체 가져오기"""
        pool_key = event_class.__name__
        
        if pool_key not in self._pools:
            self._pools[pool_key] = []
        
        pool = self._pools[pool_key]
        
        if pool:
            event = pool.pop()
            event._reset(*args, **kwargs)  # 재초기화
            return event
        else:
            return event_class(*args, **kwargs)
    
    def return_event(self, event):
        """사용 완료된 이벤트를 풀에 반환"""
        pool_key = event.__class__.__name__
        
        if pool_key in self._pools and len(self._pools[pool_key]) < 100:
            self._pools[pool_key].append(event)

# 사용 예
event_pool = EventPool()

def create_strategy_event(strategy_id, name):
    return event_pool.get_event(StrategyCreated, strategy_id, name)
```

## 🔌 통합 문제 해결

### 문제 8: "Repository 통합 실패"
```
이벤트가 발행되지 않거나 중복 발행됨
```

#### 증상
- 엔티티 저장 후 이벤트 미발행
- 같은 이벤트가 여러 번 발행
- 트랜잭션 롤백 시 이벤트 누출

#### 해결책: Unit of Work 패턴
```python
class UnitOfWork:
    """작업 단위 패턴으로 이벤트 관리"""
    
    def __init__(self):
        self._entities = []
        self._committed = False
    
    def register_entity(self, entity):
        """엔티티 등록"""
        self._entities.append(entity)
    
    def commit(self):
        """트랜잭션 커밋 및 이벤트 발행"""
        try:
            # 1. 데이터베이스 저장
            for entity in self._entities:
                self._save_entity(entity)
            
            # 2. 모든 저장 성공 시에만 이벤트 발행
            self._publish_domain_events()
            self._committed = True
            
        except Exception as e:
            # 실패 시 롤백 (이벤트 발행 안함)
            self._rollback()
            raise e
    
    def _publish_domain_events(self):
        """도메인 이벤트 일괄 발행"""
        for entity in self._entities:
            if hasattr(entity, 'get_domain_events'):
                events = entity.get_domain_events()
                
                for event in events:
                    publisher.publish(event)
                
                # 이벤트 클리어
                entity.clear_domain_events()
```

### 문제 9: "외부 시스템 연동 실패"
```
외부 API 호출 시 이벤트 처리 중단
```

#### 해결책: Outbox 패턴
```python
class EventOutbox:
    """외부 시스템 연동을 위한 이벤트 아웃박스"""
    
    def __init__(self):
        self._outbox_events = []
        self._failed_events = []
    
    def add_outbound_event(self, event, target_system):
        """외부 전송용 이벤트 추가"""
        outbox_entry = {
            'event': event,
            'target_system': target_system,
            'attempts': 0,
            'created_at': datetime.now(),
            'status': 'pending'
        }
        self._outbox_events.append(outbox_entry)
    
    async def process_outbox(self):
        """아웃박스 이벤트 처리"""
        for entry in self._outbox_events.copy():
            try:
                await self._send_to_external_system(entry)
                entry['status'] = 'sent'
                self._outbox_events.remove(entry)
                
            except Exception as e:
                entry['attempts'] += 1
                
                if entry['attempts'] >= 3:
                    entry['status'] = 'failed'
                    self._failed_events.append(entry)
                    self._outbox_events.remove(entry)
```

## 🧪 테스트 문제 해결

### 문제 10: "이벤트 테스트 어려움"
```
이벤트 발행 여부를 확인하기 어려움
```

#### 해결책: 테스트용 이벤트 스파이
```python
class EventSpy:
    """테스트용 이벤트 감시자"""
    
    def __init__(self):
        self.received_events = []
        self.event_counts = {}
    
    def capture_event(self, event):
        """이벤트 캡처"""
        self.received_events.append(event)
        
        event_type = event.event_type
        self.event_counts[event_type] = self.event_counts.get(event_type, 0) + 1
    
    def assert_event_published(self, event_type, count=1):
        """특정 이벤트 발행 검증"""
        actual_count = self.event_counts.get(event_type, 0)
        assert actual_count == count, f"예상: {count}, 실제: {actual_count}"
    
    def get_events_of_type(self, event_type):
        """특정 타입의 이벤트 반환"""
        return [e for e in self.received_events if e.event_type == event_type]

# 테스트에서 사용
def test_strategy_creation_publishes_event():
    # Given
    spy = EventSpy()
    publisher.subscribe_global(spy.capture_event)
    
    # When
    strategy = Strategy.create_new("테스트 전략")
    repository.save(strategy)
    
    # Then
    spy.assert_event_published("strategy.created", 1)
    created_events = spy.get_events_of_type("strategy.created")
    assert created_events[0].strategy_name == "테스트 전략"
```

### 문제 11: "비동기 이벤트 테스트"
```
비동기 핸들러의 실행 완료를 확인하기 어려움
```

#### 해결책: 동기화 도구 활용
```python
import asyncio
import threading

class AsyncEventTester:
    """비동기 이벤트 테스트 도우미"""
    
    def __init__(self):
        self.completion_events = {}
    
    async def wait_for_async_handlers(self, event_type, timeout=5.0):
        """비동기 핸들러 완료 대기"""
        completion_event = asyncio.Event()
        self.completion_events[event_type] = completion_event
        
        try:
            await asyncio.wait_for(completion_event.wait(), timeout=timeout)
        except asyncio.TimeoutError:
            raise AssertionError(f"비동기 핸들러 타임아웃: {event_type}")
    
    def mark_handler_completed(self, event_type):
        """핸들러 완료 표시"""
        if event_type in self.completion_events:
            self.completion_events[event_type].set()

# 테스트에서 사용
@pytest.mark.asyncio
async def test_async_event_handler():
    # Given
    tester = AsyncEventTester()
    
    async def async_handler(event):
        await asyncio.sleep(0.1)  # 비동기 작업 시뮬레이션
        tester.mark_handler_completed(event.event_type)
    
    publisher.subscribe_async("strategy.created", async_handler)
    
    # When
    event = StrategyCreated("STR_001", "테스트")
    publisher.publish(event)
    
    # Then
    await tester.wait_for_async_handlers("strategy.created")
```

## 📊 디버깅 도구

### 이벤트 플로우 추적
```python
class EventTracer:
    """이벤트 흐름 추적 도구"""
    
    def __init__(self):
        self.trace_log = []
    
    def trace_event(self, event, action, details=None):
        """이벤트 추적 로그 기록"""
        trace_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_id': event.event_id,
            'event_type': event.event_type,
            'action': action,  # 'published', 'handled', 'failed'
            'details': details or {}
        }
        self.trace_log.append(trace_entry)
    
    def print_trace(self, event_id=None):
        """추적 로그 출력"""
        filtered_log = self.trace_log
        
        if event_id:
            filtered_log = [entry for entry in self.trace_log 
                          if entry['event_id'] == event_id]
        
        for entry in filtered_log:
            print(f"[{entry['timestamp']}] {entry['action']}: "
                  f"{entry['event_type']} ({entry['event_id']})")

# 전역 추적기
tracer = EventTracer()

# 발행자에 추적 기능 추가
original_publish = publisher.publish

def traced_publish(event):
    tracer.trace_event(event, 'published')
    try:
        result = original_publish(event)
        tracer.trace_event(event, 'handled')
        return result
    except Exception as e:
        tracer.trace_event(event, 'failed', {'error': str(e)})
        raise

publisher.publish = traced_publish
```

## 🎯 모니터링 및 알림

### 운영 환경 모니터링
```python
class EventMetrics:
    """이벤트 메트릭 수집"""
    
    def __init__(self):
        self.metrics = {
            'events_published': 0,
            'handlers_executed': 0,
            'errors_count': 0,
            'avg_processing_time': 0.0
        }
        
    def record_event_published(self):
        self.metrics['events_published'] += 1
    
    def record_handler_executed(self, processing_time):
        self.metrics['handlers_executed'] += 1
        
        # 이동 평균 계산
        current_avg = self.metrics['avg_processing_time']
        count = self.metrics['handlers_executed']
        self.metrics['avg_processing_time'] = (
            (current_avg * (count - 1) + processing_time) / count
        )
    
    def get_health_status(self):
        """시스템 상태 확인"""
        error_rate = (self.metrics['errors_count'] / 
                     max(1, self.metrics['events_published']))
        
        if error_rate > 0.05:  # 5% 이상 에러율
            return "UNHEALTHY"
        elif self.metrics['avg_processing_time'] > 1.0:  # 1초 이상 처리 시간
            return "DEGRADED"
        else:
            return "HEALTHY"
```

## 🔍 체크리스트

### 문제 발생 시 확인사항
- [ ] 이벤트 타입 네이밍이 일관되는가?
- [ ] 필수 필드 검증이 누락되지 않았는가?
- [ ] 핸들러에서 예외가 적절히 처리되는가?
- [ ] 메모리 누수가 발생하지 않는가?
- [ ] 비동기 처리가 올바르게 구현되었는가?
- [ ] 테스트 커버리지가 충분한가?

### 성능 최적화 체크리스트
- [ ] 핸들러 캐싱이 활용되고 있는가?
- [ ] 배치 처리가 적용되었는가?
- [ ] 불필요한 이벤트 생성이 제거되었는가?
- [ ] 약한 참조로 메모리 관리가 되고 있는가?

---

**💡 문제해결 핵심 원칙**: 문제를 숨기지 말고 명확히 진단하고 해결하자. 로깅과 모니터링을 통해 문제를 조기에 발견하는 것이 가장 중요하다.
