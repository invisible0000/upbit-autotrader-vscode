# âš™ï¸ ë„ë©”ì¸ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ êµ¬í˜„ ê°€ì´ë“œ

> **ëŒ€ìƒ**: ë„ë©”ì¸ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ë ¤ëŠ” ê°œë°œì  
> **ëª©ì **: ë‹¨ê³„ë³„ êµ¬í˜„ ë°©ë²•ê³¼ í•µì‹¬ íŒ¨í„´ ì œê³µ  
> **ë‚œì´ë„**: ì¤‘ê¸‰ (DDD ê¸°ë³¸ ê°œë… ì´í•´ í•„ìš”)

## ğŸ¯ êµ¬í˜„ ëª©í‘œ

### ìµœì¢… ë‹¬ì„±í•  ì‹œìŠ¤í…œ
- **43ê°œ ë„ë©”ì¸ ì´ë²¤íŠ¸** ì²´ê³„ì  ê´€ë¦¬
- **17,957ê°œ/ì´ˆ** ì´ë²¤íŠ¸ ì²˜ë¦¬ ì„±ëŠ¥
- **íƒ€ì… ì•ˆì „í•œ** ì´ë²¤íŠ¸ ë°œí–‰ ì‹œìŠ¤í…œ
- **ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì—†ëŠ”** ì•ˆì „í•œ í•¸ë“¤ëŸ¬ ê´€ë¦¬

### í•µì‹¬ ì»´í¬ë„ŒíŠ¸
```
domain/events/
â”œâ”€â”€ base_domain_event.py      # ê¸°ë³¸ ì´ë²¤íŠ¸ í´ë˜ìŠ¤
â”œâ”€â”€ domain_event_publisher.py # ì´ë²¤íŠ¸ ë°œí–‰ì
â”œâ”€â”€ strategy_events.py        # ì „ëµ ì´ë²¤íŠ¸ë“¤
â”œâ”€â”€ trigger_events.py         # íŠ¸ë¦¬ê±° ì´ë²¤íŠ¸ë“¤
â”œâ”€â”€ trading_events.py         # ê±°ë˜ ì´ë²¤íŠ¸ë“¤
â””â”€â”€ backtest_events.py        # ë°±í…ŒìŠ¤íŒ… ì´ë²¤íŠ¸ë“¤
```

## ğŸ“‹ ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ

### Step 1: ê¸°ë³¸ ë„ë©”ì¸ ì´ë²¤íŠ¸ í´ë˜ìŠ¤ ì •ì˜

#### 1.1 ì¶”ìƒ ê¸°ë³¸ í´ë˜ìŠ¤ êµ¬í˜„
```python
# domain/events/base_domain_event.py
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Dict, Any, Optional
import uuid

class DomainEvent(ABC):
    """ëª¨ë“  ë„ë©”ì¸ ì´ë²¤íŠ¸ì˜ ê¸°ë³¸ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self._event_id = str(uuid.uuid4())
        self._occurred_at = datetime.now()
        self._version = 1
        self._correlation_id: Optional[str] = None
        self._causation_id: Optional[str] = None
        self._metadata: Dict[str, Any] = {}
    
    @property
    def event_id(self) -> str:
        return self._event_id
    
    @property
    def occurred_at(self) -> datetime:
        return self._occurred_at
    
    @property
    @abstractmethod
    def event_type(self) -> str:
        """ì´ë²¤íŠ¸ íƒ€ì… ë°˜í™˜ (ì˜ˆ: 'strategy.created')"""
        pass
    
    @property
    @abstractmethod
    def aggregate_id(self) -> str:
        """ê´€ë ¨ ì§‘í•©ì²´ ID ë°˜í™˜"""
        pass
    
    def to_dict(self) -> Dict[str, Any]:
        """ì´ë²¤íŠ¸ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ ì§ë ¬í™”"""
        return {
            'event_id': self.event_id,
            'event_type': self.event_type,
            'aggregate_id': self.aggregate_id,
            'occurred_at': self.occurred_at.isoformat(),
            'version': self._version,
            'correlation_id': self._correlation_id,
            'causation_id': self._causation_id,
            'metadata': self._metadata
        }
```

#### 1.2 ì„¤ê³„ í¬ì¸íŠ¸
- **UUID ê¸°ë°˜ ID**: ë¶„ì‚° í™˜ê²½ì—ì„œ ì¶©ëŒ ë°©ì§€
- **íƒ€ì„ìŠ¤íƒ¬í”„**: ì´ë²¤íŠ¸ ë°œìƒ ìˆœì„œ ì¶”ì  ê°€ëŠ¥
- **ìƒê´€ê´€ê³„ ID**: ê´€ë ¨ ì´ë²¤íŠ¸ë“¤ ì—°ê²° ì¶”ì 
- **ì§ë ¬í™” ì§€ì›**: JSON ë³€í™˜ìœ¼ë¡œ ì™¸ë¶€ ì‹œìŠ¤í…œ ì—°ë™

### Step 2: êµ¬ì²´ì  ë„ë©”ì¸ ì´ë²¤íŠ¸ êµ¬í˜„

#### 2.1 ì „ëµ ê´€ë ¨ ì´ë²¤íŠ¸
```python
# domain/events/strategy_events.py
from .base_domain_event import DomainEvent
from typing import Optional, Dict, Any

class StrategyCreated(DomainEvent):
    """ì „ëµ ìƒì„± ì´ë²¤íŠ¸"""
    
    def __init__(self, strategy_id: str, strategy_name: str, 
                 strategy_type: str = "entry", created_by: Optional[str] = None):
        super().__init__()
        
        # í•„ìˆ˜ í•„ë“œ ê²€ì¦
        if not strategy_id:
            raise ValueError("strategy_idëŠ” í•„ìˆ˜ í•„ë“œì…ë‹ˆë‹¤")
        if not strategy_name:
            raise ValueError("strategy_nameì€ í•„ìˆ˜ í•„ë“œì…ë‹ˆë‹¤")
            
        self._strategy_id = strategy_id
        self._strategy_name = strategy_name
        self._strategy_type = strategy_type
        self._created_by = created_by
    
    @property
    def event_type(self) -> str:
        return "strategy.created"
    
    @property
    def aggregate_id(self) -> str:
        return self._strategy_id
    
    @property
    def strategy_name(self) -> str:
        return self._strategy_name
    
    def to_dict(self) -> Dict[str, Any]:
        base_dict = super().to_dict()
        base_dict.update({
            'strategy_id': self._strategy_id,
            'strategy_name': self._strategy_name,
            'strategy_type': self._strategy_type,
            'created_by': self._created_by
        })
        return base_dict
```

#### 2.2 ì´ë²¤íŠ¸ êµ¬í˜„ íŒ¨í„´
```python
# ğŸ¯ ê³µí†µ íŒ¨í„´ í…œí”Œë¦¿
class {EntityName}{Action}(DomainEvent):
    def __init__(self, {í•„ìˆ˜_íŒŒë¼ë¯¸í„°}, {ì„ íƒ_íŒŒë¼ë¯¸í„°}=None):
        super().__init__()
        
        # 1. í•„ìˆ˜ í•„ë“œ ê²€ì¦
        if not {í•„ìˆ˜_íŒŒë¼ë¯¸í„°}:
            raise ValueError("í•„ìˆ˜ í•„ë“œì…ë‹ˆë‹¤")
            
        # 2. ì†ì„± ì„¤ì •
        self._{í•„ìˆ˜_íŒŒë¼ë¯¸í„°} = {í•„ìˆ˜_íŒŒë¼ë¯¸í„°}
        
    @property
    def event_type(self) -> str:
        return "{entity}.{action}"  # ì˜ˆ: "strategy.created"
        
    @property  
    def aggregate_id(self) -> str:
        return self._{entity_id}
```

### Step 3: ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰ì êµ¬í˜„

#### 3.1 í•µì‹¬ ì´ë²¤íŠ¸ ë°œí–‰ì
```python
# domain/events/domain_event_publisher.py
import threading
import asyncio
from typing import Dict, List, Callable, Any, Type
from .base_domain_event import DomainEvent

class DomainEventPublisher:
    """ê³ ì„±ëŠ¥ ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰ì"""
    
    def __init__(self):
        self._handlers: Dict[str, List[Callable]] = {}
        self._global_handlers: List[Callable] = []
        self._async_handlers: Dict[str, List[Callable]] = {}
        self._lock = threading.Lock()
        self._enabled = True
        self._stats = {'published': 0, 'handlers_called': 0}
    
    def subscribe(self, event_type: str, handler: Callable[[DomainEvent], None]):
        """íŠ¹ì • ì´ë²¤íŠ¸ íƒ€ì…ì— í•¸ë“¤ëŸ¬ ë“±ë¡"""
        with self._lock:
            if event_type not in self._handlers:
                self._handlers[event_type] = []
            self._handlers[event_type].append(handler)
    
    def subscribe_global(self, handler: Callable[[DomainEvent], None]):
        """ëª¨ë“  ì´ë²¤íŠ¸ì— ëŒ€í•œ ê¸€ë¡œë²Œ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        with self._lock:
            self._global_handlers.append(handler)
    
    def publish(self, event: DomainEvent):
        """ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰"""
        if not self._enabled:
            return
            
        with self._lock:
            self._stats['published'] += 1
            
            # íƒ€ì…ë³„ í•¸ë“¤ëŸ¬ ì‹¤í–‰
            event_type = event.event_type
            if event_type in self._handlers:
                for handler in self._handlers[event_type]:
                    self._safe_call_handler(handler, event)
            
            # ê¸€ë¡œë²Œ í•¸ë“¤ëŸ¬ ì‹¤í–‰
            for handler in self._global_handlers:
                self._safe_call_handler(handler, event)
    
    def _safe_call_handler(self, handler: Callable, event: DomainEvent):
        """í•¸ë“¤ëŸ¬ ì•ˆì „ ì‹¤í–‰ (ì˜ˆì™¸ ê²©ë¦¬)"""
        try:
            handler(event)
            self._stats['handlers_called'] += 1
        except Exception as e:
            print(f"âŒ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            # ë¡œê¹… ì‹œìŠ¤í…œì´ ìˆë‹¤ë©´ ì—¬ê¸°ì„œ ë¡œê·¸ ê¸°ë¡
```

#### 3.2 ì „ì—­ ë°œí–‰ì íŒ¨í„´
```python
# domain/events/__init__.py
from .domain_event_publisher import DomainEventPublisher

# ì „ì—­ ë°œí–‰ì ì¸ìŠ¤í„´ìŠ¤
_global_publisher = DomainEventPublisher()

def get_domain_event_publisher() -> DomainEventPublisher:
    """ì „ì—­ ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰ì ë°˜í™˜"""
    return _global_publisher

# í¸ì˜ í•¨ìˆ˜ë“¤
def publish_domain_event(event: DomainEvent):
    """ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰ í¸ì˜ í•¨ìˆ˜"""
    _global_publisher.publish(event)

def subscribe_to_event(event_type: str, handler):
    """ì´ë²¤íŠ¸ êµ¬ë… í¸ì˜ í•¨ìˆ˜"""
    _global_publisher.subscribe(event_type, handler)
```

### Step 4: ì—”í‹°í‹°ì— ì´ë²¤íŠ¸ ë°œí–‰ í†µí•©

#### 4.1 ì—”í‹°í‹° ì´ë²¤íŠ¸ ê´€ë¦¬ íŒ¨í„´
```python
# domain/entities/strategy.py
from typing import List
from ..events import DomainEvent, StrategyCreated

class Strategy:
    """ì „ëµ ë„ë©”ì¸ ì—”í‹°í‹°"""
    
    def __init__(self, strategy_name: str):
        self._strategy_id = self._generate_id()
        self._strategy_name = strategy_name
        self._domain_events: List[DomainEvent] = []
    
    @classmethod
    def create_new(cls, strategy_name: str) -> 'Strategy':
        """ìƒˆ ì „ëµ ìƒì„± íŒ©í† ë¦¬ ë©”ì„œë“œ"""
        strategy = cls(strategy_name)
        
        # ìƒì„± ì´ë²¤íŠ¸ ë°œí–‰
        strategy._add_domain_event(
            StrategyCreated(strategy._strategy_id, strategy_name)
        )
        
        return strategy
    
    def _add_domain_event(self, event: DomainEvent):
        """ë„ë©”ì¸ ì´ë²¤íŠ¸ ì¶”ê°€"""
        self._domain_events.append(event)
    
    def get_domain_events(self) -> List[DomainEvent]:
        """ëŒ€ê¸° ì¤‘ì¸ ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°˜í™˜"""
        return self._domain_events.copy()
    
    def clear_domain_events(self):
        """ë„ë©”ì¸ ì´ë²¤íŠ¸ í´ë¦¬ì–´ (Repository ì €ì¥ í›„ í˜¸ì¶œ)"""
        self._domain_events.clear()
```

#### 4.2 Repository í†µí•© íŒ¨í„´
```python
# domain/repositories/base_repository.py
from abc import ABC, abstractmethod
from ..events import get_domain_event_publisher

class BaseRepository(ABC):
    """ê¸°ë³¸ Repository í´ë˜ìŠ¤"""
    
    def __init__(self):
        self._event_publisher = get_domain_event_publisher()
    
    def _publish_domain_events(self, entity):
        """ì—”í‹°í‹°ì˜ ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰"""
        if hasattr(entity, 'get_domain_events'):
            events = entity.get_domain_events()
            
            for event in events:
                try:
                    self._event_publisher.publish(event)
                except Exception as e:
                    print(f"âš ï¸ ë„ë©”ì¸ ì´ë²¤íŠ¸ ë°œí–‰ ì‹¤íŒ¨: {e}")
            
            # ì´ë²¤íŠ¸ í´ë¦¬ì–´
            if hasattr(entity, 'clear_domain_events'):
                entity.clear_domain_events()
```

### Step 5: í…ŒìŠ¤íŠ¸ êµ¬í˜„

#### 5.1 ê¸°ë³¸ í…ŒìŠ¤íŠ¸ íŒ¨í„´
```python
# tests/domain/events/test_strategy_events.py
import pytest
from datetime import datetime
from domain.events.strategy_events import StrategyCreated

def test_strategy_created_event_creation():
    """ì „ëµ ìƒì„± ì´ë²¤íŠ¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
    # Given
    strategy_id = "STR_001"
    strategy_name = "RSI ì „ëµ"
    
    # When
    event = StrategyCreated(strategy_id, strategy_name)
    
    # Then
    assert event.event_type == "strategy.created"
    assert event.aggregate_id == strategy_id
    assert event.strategy_name == strategy_name
    assert isinstance(event.occurred_at, datetime)
    assert event.event_id is not None

def test_strategy_created_event_serialization():
    """ì „ëµ ìƒì„± ì´ë²¤íŠ¸ ì§ë ¬í™” í…ŒìŠ¤íŠ¸"""
    # Given
    event = StrategyCreated("STR_001", "RSI ì „ëµ")
    
    # When
    event_dict = event.to_dict()
    
    # Then
    assert event_dict['event_type'] == "strategy.created"
    assert event_dict['strategy_id'] == "STR_001"
    assert event_dict['strategy_name'] == "RSI ì „ëµ"
```

#### 5.2 ë°œí–‰ì í…ŒìŠ¤íŠ¸ íŒ¨í„´
```python
# tests/domain/events/test_domain_event_publisher.py
def test_event_publisher_basic_functionality():
    """ì´ë²¤íŠ¸ ë°œí–‰ì ê¸°ë³¸ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"""
    # Given
    publisher = DomainEventPublisher()
    received_events = []
    
    def test_handler(event):
        received_events.append(event)
    
    publisher.subscribe("strategy.created", test_handler)
    
    # When
    event = StrategyCreated("STR_001", "í…ŒìŠ¤íŠ¸ ì „ëµ")
    publisher.publish(event)
    
    # Then
    assert len(received_events) == 1
    assert received_events[0].event_type == "strategy.created"
```

## ğŸ”§ ê³ ê¸‰ êµ¬í˜„ íŒ¨í„´

### ë¹„ë™ê¸° ì´ë²¤íŠ¸ ì²˜ë¦¬
```python
async def async_event_handler(event: DomainEvent):
    """ë¹„ë™ê¸° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì˜ˆì œ"""
    # ë¬´ê±°ìš´ ì‘ì—… (ì™¸ë¶€ API í˜¸ì¶œ, íŒŒì¼ I/O ë“±)
    await asyncio.sleep(0.1)
    print(f"ë¹„ë™ê¸° ì²˜ë¦¬ ì™„ë£Œ: {event.event_type}")

# ë¹„ë™ê¸° í•¸ë“¤ëŸ¬ ë“±ë¡
publisher.subscribe_async("strategy.created", async_event_handler)
```

### ì´ë²¤íŠ¸ ë°°ì¹˜ ì²˜ë¦¬
```python
def publish_events_batch(events: List[DomainEvent]):
    """ë°°ì¹˜ ì´ë²¤íŠ¸ ë°œí–‰"""
    with publisher.batch_mode():
        for event in events:
            publisher.publish(event)
    # batch_mode ì¢…ë£Œ ì‹œ í•œ ë²ˆì— ì²˜ë¦¬
```

### ì´ë²¤íŠ¸ í•„í„°ë§
```python
class EventFilter:
    """ì´ë²¤íŠ¸ í•„í„°ë§ ì‹œìŠ¤í…œ"""
    
    def __init__(self, condition: Callable[[DomainEvent], bool]):
        self.condition = condition
    
    def filter(self, event: DomainEvent) -> bool:
        return self.condition(event)

# ì‚¬ìš© ì˜ˆ
strategy_filter = EventFilter(lambda e: e.event_type.startswith("strategy."))
```

## ğŸ“Š ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ

### í•¸ë“¤ëŸ¬ ê´€ë¦¬ ìµœì í™”
```python
# âœ… íš¨ìœ¨ì ì¸ í•¸ë“¤ëŸ¬ ê´€ë¦¬
class OptimizedPublisher:
    def __init__(self):
        self._handlers_cache = {}  # íƒ€ì…ë³„ í•¸ë“¤ëŸ¬ ìºì‹œ
        
    def _get_handlers_for_type(self, event_type: str):
        """í•¸ë“¤ëŸ¬ ìºì‹œ í™œìš©"""
        if event_type not in self._handlers_cache:
            self._handlers_cache[event_type] = self._handlers.get(event_type, [])
        return self._handlers_cache[event_type]
```

### ë©”ëª¨ë¦¬ ê´€ë¦¬
```python
# ì•½í•œ ì°¸ì¡°ë¡œ í•¸ë“¤ëŸ¬ ê´€ë¦¬ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
import weakref

class WeakRefPublisher:
    def __init__(self):
        self._weak_handlers = []
    
    def subscribe_weak(self, handler):
        """ì•½í•œ ì°¸ì¡°ë¡œ í•¸ë“¤ëŸ¬ ë“±ë¡"""
        self._weak_handlers.append(weakref.ref(handler))
    
    def _cleanup_dead_handlers(self):
        """ì£½ì€ í•¸ë“¤ëŸ¬ ì •ë¦¬"""
        self._weak_handlers = [ref for ref in self._weak_handlers if ref() is not None]
```

## ğŸš¨ ì£¼ì˜ì‚¬í•­ ë° ëª¨ë²” ì‚¬ë¡€

### ì´ë²¤íŠ¸ ì„¤ê³„ ì›ì¹™
1. **ë¶ˆë³€ì„±**: ì´ë²¤íŠ¸ëŠ” í•œ ë²ˆ ìƒì„±ë˜ë©´ ë³€ê²½ë˜ì§€ ì•Šì•„ì•¼ í•¨
2. **ê³¼ê±°í˜•**: ì´ë²¤íŠ¸ëª…ì€ ê³¼ê±°í˜•ìœ¼ë¡œ ì‘ì„± (`StrategyCreated`)
3. **ë‹¨ì¼ ì±…ì„**: í•˜ë‚˜ì˜ ì´ë²¤íŠ¸ëŠ” í•˜ë‚˜ì˜ ë¹„ì¦ˆë‹ˆìŠ¤ ì‚¬ì‹¤ë§Œ í‘œí˜„

### ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­
```python
# âŒ í”¼í•´ì•¼ í•  íŒ¨í„´
def slow_handler(event):
    time.sleep(1)  # ë™ê¸° ì²˜ë¦¬ì—ì„œ ë¸”ë¡œí‚¹
    
# âœ… ê¶Œì¥ íŒ¨í„´
async def fast_handler(event):
    await queue.put(event)  # íì— ë„£ê³  ë¹„ë™ê¸° ì²˜ë¦¬
```

### ì—ëŸ¬ ì²˜ë¦¬
```python
def robust_handler(event):
    try:
        # í•¸ë“¤ëŸ¬ ë¡œì§
        process_event(event)
    except SpecificException as e:
        # íŠ¹ì • ì˜ˆì™¸ë§Œ ì²˜ë¦¬
        logger.warning(f"ì´ë²¤íŠ¸ ì²˜ë¦¬ ê²½ê³ : {e}")
    except Exception as e:
        # ì˜ˆìƒì¹˜ ëª»í•œ ì˜ˆì™¸ëŠ” ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ê³„ì†
        logger.error(f"ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
        # ë‹¤ë¥¸ í•¸ë“¤ëŸ¬ì— ì˜í–¥ì„ ì£¼ì§€ ì•Šë„ë¡ ì˜ˆì™¸ë¥¼ ì¬ë°œìƒì‹œí‚¤ì§€ ì•ŠìŒ
```

## ğŸ¯ ë‹¤ìŒ ë‹¨ê³„

### Application Layer í†µí•©
1. **Command Handler**: ëª…ë ¹ ì²˜ë¦¬ í›„ ì´ë²¤íŠ¸ ë°œí–‰
2. **Event Handler**: ì´ë²¤íŠ¸ ìˆ˜ì‹  í›„ Use Case ì‹¤í–‰
3. **Saga Pattern**: ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬

### Infrastructure Layer í™•ì¥
1. **Event Store**: ì´ë²¤íŠ¸ ì˜ì†í™” ì‹œìŠ¤í…œ
2. **Message Queue**: ë¶„ì‚° ì‹œìŠ¤í…œ ê°„ ì´ë²¤íŠ¸ ì „ë‹¬
3. **Monitoring**: ì´ë²¤íŠ¸ ë©”íŠ¸ë¦­ê³¼ ì•Œë¦¼

---

**ğŸ’¡ í•µì‹¬ ê°€ì´ë“œë¼ì¸**: ë„ë©”ì¸ ì´ë²¤íŠ¸ëŠ” ê¸°ìˆ ì  êµ¬í˜„ì´ ì•„ë‹Œ ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì¹˜ì— ì§‘ì¤‘í•´ì•¼ í•©ë‹ˆë‹¤. ë³µì¡í•œ ê¸°ëŠ¥ë³´ë‹¤ëŠ” ëª…í™•í•˜ê³  ì•ˆì •ì ì¸ ê¸°ë³¸ êµ¬ì¡°ë¥¼ ë¨¼ì € êµ¬ì¶•í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.
