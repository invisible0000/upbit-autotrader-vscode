# ⚙️ 도메인 이벤트 시스템 구현 가이드

> **대상**: 도메인 이벤트 시스템을 구현하려는 개발자  
> **목적**: 단계별 구현 방법과 핵심 패턴 제공  
> **난이도**: 중급 (DDD 기본 개념 이해 필요)

## 🎯 구현 목표

### 최종 달성할 시스템
- **43개 도메인 이벤트** 체계적 관리
- **17,957개/초** 이벤트 처리 성능
- **타입 안전한** 이벤트 발행 시스템
- **메모리 누수 없는** 안전한 핸들러 관리

### 핵심 컴포넌트
```
domain/events/
├── base_domain_event.py      # 기본 이벤트 클래스
├── domain_event_publisher.py # 이벤트 발행자
├── strategy_events.py        # 전략 이벤트들
├── trigger_events.py         # 트리거 이벤트들
├── trading_events.py         # 거래 이벤트들
└── backtest_events.py        # 백테스팅 이벤트들
```

## 📋 단계별 구현 가이드

### Step 1: 기본 도메인 이벤트 클래스 정의

#### 1.1 추상 기본 클래스 구현
```python
# domain/events/base_domain_event.py
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Dict, Any, Optional
import uuid

class DomainEvent(ABC):
    """모든 도메인 이벤트의 기본 클래스"""
    
    def __init__(self):
        self._event_id = str(uuid.uuid4())
        self._occurred_at = datetime.now()
        self._version = 1
        self._correlation_id: Optional[str] = None
        self._causation_id: Optional[str] = None
        self._metadata: Dict[str, Any] = {}
    
    @property
    def event_id(self) -> str:
        return self._event_id
    
    @property
    def occurred_at(self) -> datetime:
        return self._occurred_at
    
    @property
    @abstractmethod
    def event_type(self) -> str:
        """이벤트 타입 반환 (예: 'strategy.created')"""
        pass
    
    @property
    @abstractmethod
    def aggregate_id(self) -> str:
        """관련 집합체 ID 반환"""
        pass
    
    def to_dict(self) -> Dict[str, Any]:
        """이벤트를 딕셔너리로 직렬화"""
        return {
            'event_id': self.event_id,
            'event_type': self.event_type,
            'aggregate_id': self.aggregate_id,
            'occurred_at': self.occurred_at.isoformat(),
            'version': self._version,
            'correlation_id': self._correlation_id,
            'causation_id': self._causation_id,
            'metadata': self._metadata
        }
```

#### 1.2 설계 포인트
- **UUID 기반 ID**: 분산 환경에서 충돌 방지
- **타임스탬프**: 이벤트 발생 순서 추적 가능
- **상관관계 ID**: 관련 이벤트들 연결 추적
- **직렬화 지원**: JSON 변환으로 외부 시스템 연동

### Step 2: 구체적 도메인 이벤트 구현

#### 2.1 전략 관련 이벤트
```python
# domain/events/strategy_events.py
from .base_domain_event import DomainEvent
from typing import Optional, Dict, Any

class StrategyCreated(DomainEvent):
    """전략 생성 이벤트"""
    
    def __init__(self, strategy_id: str, strategy_name: str, 
                 strategy_type: str = "entry", created_by: Optional[str] = None):
        super().__init__()
        
        # 필수 필드 검증
        if not strategy_id:
            raise ValueError("strategy_id는 필수 필드입니다")
        if not strategy_name:
            raise ValueError("strategy_name은 필수 필드입니다")
            
        self._strategy_id = strategy_id
        self._strategy_name = strategy_name
        self._strategy_type = strategy_type
        self._created_by = created_by
    
    @property
    def event_type(self) -> str:
        return "strategy.created"
    
    @property
    def aggregate_id(self) -> str:
        return self._strategy_id
    
    @property
    def strategy_name(self) -> str:
        return self._strategy_name
    
    def to_dict(self) -> Dict[str, Any]:
        base_dict = super().to_dict()
        base_dict.update({
            'strategy_id': self._strategy_id,
            'strategy_name': self._strategy_name,
            'strategy_type': self._strategy_type,
            'created_by': self._created_by
        })
        return base_dict
```

#### 2.2 이벤트 구현 패턴
```python
# 🎯 공통 패턴 템플릿
class {EntityName}{Action}(DomainEvent):
    def __init__(self, {필수_파라미터}, {선택_파라미터}=None):
        super().__init__()
        
        # 1. 필수 필드 검증
        if not {필수_파라미터}:
            raise ValueError("필수 필드입니다")
            
        # 2. 속성 설정
        self._{필수_파라미터} = {필수_파라미터}
        
    @property
    def event_type(self) -> str:
        return "{entity}.{action}"  # 예: "strategy.created"
        
    @property  
    def aggregate_id(self) -> str:
        return self._{entity_id}
```

### Step 3: 도메인 이벤트 발행자 구현

#### 3.1 핵심 이벤트 발행자
```python
# domain/events/domain_event_publisher.py
import threading
import asyncio
from typing import Dict, List, Callable, Any, Type
from .base_domain_event import DomainEvent

class DomainEventPublisher:
    """고성능 도메인 이벤트 발행자"""
    
    def __init__(self):
        self._handlers: Dict[str, List[Callable]] = {}
        self._global_handlers: List[Callable] = []
        self._async_handlers: Dict[str, List[Callable]] = {}
        self._lock = threading.Lock()
        self._enabled = True
        self._stats = {'published': 0, 'handlers_called': 0}
    
    def subscribe(self, event_type: str, handler: Callable[[DomainEvent], None]):
        """특정 이벤트 타입에 핸들러 등록"""
        with self._lock:
            if event_type not in self._handlers:
                self._handlers[event_type] = []
            self._handlers[event_type].append(handler)
    
    def subscribe_global(self, handler: Callable[[DomainEvent], None]):
        """모든 이벤트에 대한 글로벌 핸들러 등록"""
        with self._lock:
            self._global_handlers.append(handler)
    
    def publish(self, event: DomainEvent):
        """도메인 이벤트 발행"""
        if not self._enabled:
            return
            
        with self._lock:
            self._stats['published'] += 1
            
            # 타입별 핸들러 실행
            event_type = event.event_type
            if event_type in self._handlers:
                for handler in self._handlers[event_type]:
                    self._safe_call_handler(handler, event)
            
            # 글로벌 핸들러 실행
            for handler in self._global_handlers:
                self._safe_call_handler(handler, event)
    
    def _safe_call_handler(self, handler: Callable, event: DomainEvent):
        """핸들러 안전 실행 (예외 격리)"""
        try:
            handler(event)
            self._stats['handlers_called'] += 1
        except Exception as e:
            print(f"❌ 이벤트 핸들러 실행 실패: {e}")
            # 로깅 시스템이 있다면 여기서 로그 기록
```

#### 3.2 전역 발행자 패턴
```python
# domain/events/__init__.py
from .domain_event_publisher import DomainEventPublisher

# 전역 발행자 인스턴스
_global_publisher = DomainEventPublisher()

def get_domain_event_publisher() -> DomainEventPublisher:
    """전역 도메인 이벤트 발행자 반환"""
    return _global_publisher

# 편의 함수들
def publish_domain_event(event: DomainEvent):
    """도메인 이벤트 발행 편의 함수"""
    _global_publisher.publish(event)

def subscribe_to_event(event_type: str, handler):
    """이벤트 구독 편의 함수"""
    _global_publisher.subscribe(event_type, handler)
```

### Step 4: 엔티티에 이벤트 발행 통합

#### 4.1 엔티티 이벤트 관리 패턴
```python
# domain/entities/strategy.py
from typing import List
from ..events import DomainEvent, StrategyCreated

class Strategy:
    """전략 도메인 엔티티"""
    
    def __init__(self, strategy_name: str):
        self._strategy_id = self._generate_id()
        self._strategy_name = strategy_name
        self._domain_events: List[DomainEvent] = []
    
    @classmethod
    def create_new(cls, strategy_name: str) -> 'Strategy':
        """새 전략 생성 팩토리 메서드"""
        strategy = cls(strategy_name)
        
        # 생성 이벤트 발행
        strategy._add_domain_event(
            StrategyCreated(strategy._strategy_id, strategy_name)
        )
        
        return strategy
    
    def _add_domain_event(self, event: DomainEvent):
        """도메인 이벤트 추가"""
        self._domain_events.append(event)
    
    def get_domain_events(self) -> List[DomainEvent]:
        """대기 중인 도메인 이벤트 반환"""
        return self._domain_events.copy()
    
    def clear_domain_events(self):
        """도메인 이벤트 클리어 (Repository 저장 후 호출)"""
        self._domain_events.clear()
```

#### 4.2 Repository 통합 패턴
```python
# domain/repositories/base_repository.py
from abc import ABC, abstractmethod
from ..events import get_domain_event_publisher

class BaseRepository(ABC):
    """기본 Repository 클래스"""
    
    def __init__(self):
        self._event_publisher = get_domain_event_publisher()
    
    def _publish_domain_events(self, entity):
        """엔티티의 도메인 이벤트 발행"""
        if hasattr(entity, 'get_domain_events'):
            events = entity.get_domain_events()
            
            for event in events:
                try:
                    self._event_publisher.publish(event)
                except Exception as e:
                    print(f"⚠️ 도메인 이벤트 발행 실패: {e}")
            
            # 이벤트 클리어
            if hasattr(entity, 'clear_domain_events'):
                entity.clear_domain_events()
```

### Step 5: 테스트 구현

#### 5.1 기본 테스트 패턴
```python
# tests/domain/events/test_strategy_events.py
import pytest
from datetime import datetime
from domain.events.strategy_events import StrategyCreated

def test_strategy_created_event_creation():
    """전략 생성 이벤트 생성 테스트"""
    # Given
    strategy_id = "STR_001"
    strategy_name = "RSI 전략"
    
    # When
    event = StrategyCreated(strategy_id, strategy_name)
    
    # Then
    assert event.event_type == "strategy.created"
    assert event.aggregate_id == strategy_id
    assert event.strategy_name == strategy_name
    assert isinstance(event.occurred_at, datetime)
    assert event.event_id is not None

def test_strategy_created_event_serialization():
    """전략 생성 이벤트 직렬화 테스트"""
    # Given
    event = StrategyCreated("STR_001", "RSI 전략")
    
    # When
    event_dict = event.to_dict()
    
    # Then
    assert event_dict['event_type'] == "strategy.created"
    assert event_dict['strategy_id'] == "STR_001"
    assert event_dict['strategy_name'] == "RSI 전략"
```

#### 5.2 발행자 테스트 패턴
```python
# tests/domain/events/test_domain_event_publisher.py
def test_event_publisher_basic_functionality():
    """이벤트 발행자 기본 기능 테스트"""
    # Given
    publisher = DomainEventPublisher()
    received_events = []
    
    def test_handler(event):
        received_events.append(event)
    
    publisher.subscribe("strategy.created", test_handler)
    
    # When
    event = StrategyCreated("STR_001", "테스트 전략")
    publisher.publish(event)
    
    # Then
    assert len(received_events) == 1
    assert received_events[0].event_type == "strategy.created"
```

## 🔧 고급 구현 패턴

### 비동기 이벤트 처리
```python
async def async_event_handler(event: DomainEvent):
    """비동기 이벤트 핸들러 예제"""
    # 무거운 작업 (외부 API 호출, 파일 I/O 등)
    await asyncio.sleep(0.1)
    print(f"비동기 처리 완료: {event.event_type}")

# 비동기 핸들러 등록
publisher.subscribe_async("strategy.created", async_event_handler)
```

### 이벤트 배치 처리
```python
def publish_events_batch(events: List[DomainEvent]):
    """배치 이벤트 발행"""
    with publisher.batch_mode():
        for event in events:
            publisher.publish(event)
    # batch_mode 종료 시 한 번에 처리
```

### 이벤트 필터링
```python
class EventFilter:
    """이벤트 필터링 시스템"""
    
    def __init__(self, condition: Callable[[DomainEvent], bool]):
        self.condition = condition
    
    def filter(self, event: DomainEvent) -> bool:
        return self.condition(event)

# 사용 예
strategy_filter = EventFilter(lambda e: e.event_type.startswith("strategy."))
```

## 📊 성능 최적화 가이드

### 핸들러 관리 최적화
```python
# ✅ 효율적인 핸들러 관리
class OptimizedPublisher:
    def __init__(self):
        self._handlers_cache = {}  # 타입별 핸들러 캐시
        
    def _get_handlers_for_type(self, event_type: str):
        """핸들러 캐시 활용"""
        if event_type not in self._handlers_cache:
            self._handlers_cache[event_type] = self._handlers.get(event_type, [])
        return self._handlers_cache[event_type]
```

### 메모리 관리
```python
# 약한 참조로 핸들러 관리 (메모리 누수 방지)
import weakref

class WeakRefPublisher:
    def __init__(self):
        self._weak_handlers = []
    
    def subscribe_weak(self, handler):
        """약한 참조로 핸들러 등록"""
        self._weak_handlers.append(weakref.ref(handler))
    
    def _cleanup_dead_handlers(self):
        """죽은 핸들러 정리"""
        self._weak_handlers = [ref for ref in self._weak_handlers if ref() is not None]
```

## 🚨 주의사항 및 모범 사례

### 이벤트 설계 원칙
1. **불변성**: 이벤트는 한 번 생성되면 변경되지 않아야 함
2. **과거형**: 이벤트명은 과거형으로 작성 (`StrategyCreated`)
3. **단일 책임**: 하나의 이벤트는 하나의 비즈니스 사실만 표현

### 성능 고려사항
```python
# ❌ 피해야 할 패턴
def slow_handler(event):
    time.sleep(1)  # 동기 처리에서 블로킹
    
# ✅ 권장 패턴
async def fast_handler(event):
    await queue.put(event)  # 큐에 넣고 비동기 처리
```

### 에러 처리
```python
def robust_handler(event):
    try:
        # 핸들러 로직
        process_event(event)
    except SpecificException as e:
        # 특정 예외만 처리
        logger.warning(f"이벤트 처리 경고: {e}")
    except Exception as e:
        # 예상치 못한 예외는 로그만 남기고 계속
        logger.error(f"이벤트 처리 실패: {e}")
        # 다른 핸들러에 영향을 주지 않도록 예외를 재발생시키지 않음
```

## 🎯 다음 단계

### Application Layer 통합
1. **Command Handler**: 명령 처리 후 이벤트 발행
2. **Event Handler**: 이벤트 수신 후 Use Case 실행
3. **Saga Pattern**: 복잡한 비즈니스 프로세스 관리

### Infrastructure Layer 확장
1. **Event Store**: 이벤트 영속화 시스템
2. **Message Queue**: 분산 시스템 간 이벤트 전달
3. **Monitoring**: 이벤트 메트릭과 알림

---

**💡 핵심 가이드라인**: 도메인 이벤트는 기술적 구현이 아닌 비즈니스 가치에 집중해야 합니다. 복잡한 기능보다는 명확하고 안정적인 기본 구조를 먼저 구축하는 것이 중요합니다.
