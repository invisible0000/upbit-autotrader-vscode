업비트 마켓 데이터 통합 API 구현 평가 및 방안
REST vs WebSocket 기능 비교
요청/응답 구조: 업비트 REST API는 HTTP 요청/응답(request/response) 방식으로 동작하여 클라이언트가 요청을 보낼 때마다 서버가 한 번 응답합니다. 이에 반해 WebSocket은 Persistent Connection(지속 연결)을 통해 JSON 메시지 교환으로 동작하며, 초기에 한 번 구독 요청을 보내면 이후에는 서버가 실시간 데이터를 푸시(push)하는 구조입니다[1]. 예를 들어 REST로 현재가를 조회할 경우 /v1/ticker 엔드포인트에 GET 요청을 보내야 하지만, WebSocket에서는 아래와 같은 JSON 배열을 보내 한 번의 연결로 여러 종목의 현재가 구독이 가능합니다:
[
  { "ticket": "unique-id" },
  { "type": "ticker", "codes": ["KRW-BTC", "KRW-ETH"] },
  { "format": "DEFAULT" }
]
이처럼 REST는 요청 당 1회 응답이며 WebSocket은 한 번 연결로 연속 응답 스트림을 받습니다. 또한 REST 응답 데이터는 요청 시점의 스냅샷(snapshot)이고, WebSocket은 구독 시작 시 초기 스냅샷을 보내고 이후 변경 사항 실시간 업데이트(real-time updates)를 지속적으로 전송합니다[2][3].
지연시간(latency): REST API는 폴링(polling) 또는 주기적 호출로 데이터를 받으므로 수 초 내외의 지연이 발생할 수 있습니다. 실제 업비트 개발자 문서에 따르면 REST 시세 데이터는 약 1~2초 지연이 있는 반면, WebSocket을 통한 실시간 데이터는 100~500ms 수준의 저지연 업데이트가 가능합니다[4][1]. 예를 들어 분봉 캔들 데이터를 비교하면 REST로는 완성된 후 제공되어 최대 1~2초 지연되지만, WebSocket 스트림은 거래 발생 즉시 밀리초 단위로 가격 변화를 전달합니다[4]. 따라서 실시간성 측면에서 WebSocket이 우수합니다.
호출 빈도 및 Rate Limit(요청 수 제한): Upbit REST API는 초당 및 분당 호출 횟수에 엄격한 제한이 있습니다. 시세 조회(Quotation) REST API의 경우 초당 최대 10회까지 요청 가능하며 모든 시세 관련 엔드포인트가 공유하여 집계됩니다. 예를 들어 현재가(/ticker), 체결(/trades), 호가(/orderbook) 등의 요청을 합쳐 초당 10회를 넘길 수 없습니다. 분 단위 제한도 존재하며, Upbit 공식 문서 기준 시세 조회는 분당 600회로 제한됩니다[5]. 반면 WebSocket은 한번 연결한 후 데이터 수신에는 별도 호출 제한이 없습니다[1]. 다만 연결 자체 및 구독 메시지 전송에만 제한이 있어, 새 WebSocket 연결은 초당 5회까지만 허용되고 구독 메시지 전송도 초당 5회(분당 100회)로 제한됩니다. 데이터 수신 측면에서는 WebSocket이 Rate Limit 우회 효과가 있어, 실시간 시세 업데이트를 얼마나 자주 받아도 추가 제약이 없습니다[6]. 이러한 차이로 다수 종목 데이터를 빈번히 조회해야 하는 경우 REST는 곧바로 제한에 걸릴 수 있지만 WebSocket은 한 번 구독 후 무제한 스트림으로 대역폭을 효율적으로 활용합니다.
데이터 전달 범위: REST API는 일반적으로 한 요청당 특정 범위의 데이터를 반환합니다. 예를 들어 현재가(ticker)는 최대 100개 마켓까지, 호가(orderbook)는 최대 5개 마켓까지 한 번에 조회 가능하도록 제한되어 있습니다[7][8]. WebSocket은 한 연결 내에 다수 종목을 동시 구독할 수 있으며, 공식 제한상 명시된 종목 수는 없지만 실용적으로 수십 종목 이상의 시세를 동시에 스트리밍할 수 있습니다. 따라서 다중 마켓 동시 모니터링에는 WebSocket이 적합합니다. 또한 REST는 과거 데이터 조회(예: 역대 캔들 200개 등)에 강점이 있는데, WebSocket은 히스토리컬 데이터 조회 기능이 없습니다. WebSocket의 candle 타입도 완성 시점의 신규 캔들 정도만 실시간 제공할 뿐, 과거 데이터는 REST로만 가져올 수 있습니다[9].
연결 및 구현 복잡도: REST 호출은 HTTP 요청이므로 비교적 구현이 단순하고 연결 상태를 신경 쓸 필요가 없습니다. 실패 시 재시도 정도만 처리하면 되며, Python의 aiohttp 등을 통해 손쉽게 구현 가능합니다. WebSocket은 상시 연결 유지가 필요하며 Ping/Pong으로 heartbeat을 주고받거나 재연결 로직을 구현해야 하는 등 복잡성이 높습니다】[10]. 예를 들어 업비트 WebSocket은 120초 Idle Timeout이 있어서 주기적으로 Ping을 보내야 하며, 네트워크 단절시 자동 재연결 처리가 필요합니다[11][12]. 또한 WebSocket 구독 메시지 포맷이나 에러 처리 등 별도 프로토콜에 따른 코드가 추가됩니다. 요약하면 REST는 단순하지만 빈번 호출에 불리, WebSocket은 구현 부담이 있지만 실시간 대량 데이터에 유리**한 특성이 있습니다.
요청 유형별 REST vs WebSocket 사용 기준
REST API와 WebSocket의 특성을 조합하여 어떤 요청을 어떤 채널로 처리할지 기준을 정의하면 다음과 같습니다.
* 실시간 지속 데이터 ? WebSocket 우선 활용: 현재가(Ticker), 체결(Trade), 호가(Orderbook) 같이 고빈도 실시간 업데이트가 필요한 데이터는 WebSocket으로 구독하는 것이 효율적입니다[13]. 이러한 데이터는 초단위로 변동이 크고 다수 종목을 동시에 모니터링해야 할 수 있으므로, REST로 매초 다량 호출하면 곧 Rate Limit에 걸리지만 WebSocket 스트림으로 받으면 제약 없이 신속히 처리할 수 있습니다. 실제 업비트 가이드에서도 “WebSocket을 메인 데이터 소스”로 두고 “REST API는 백업”으로 사용할 것을 권장하고 있습니다[14].
* 저빈도 일회성 데이터 ? REST API 사용: 매 요청마다 변하지 않는 정보나 낮은 빈도로 조회하는 데이터는 REST로 처리하는 편이 낫습니다. 예를 들어 과거 시세 데이터(캔들 OHLCV) 조회, 과거 체결 내역 등은 한 번에 여러 개의 데이터를 가져오는 REST 엔드포인트가 있고, 과거 데이터는 WebSocket에서 제공하지 않으므로 REST를 사용해야 합니다[13]. 또한 초기 데이터 로드(예: 애플리케이션 시작 시 과거 200개의 캔들 불러오기 등)도 REST로 일괄 조회하는 것이 편리합니다. WebSocket은 실시간 스트림에는 강하지만, 히스토리 조회나 대량 데이터 일괄 요청에는 REST가 적합합니다.
* 계좌/주문 등 프라이빗 데이터 ? REST + 필요 시 WebSocket 이벤트: 계좌 잔고, 주문 리스트 등의 프라이빗 정보는 보통 REST Exchange API로 조회하며, 빈도가 높지 않고 보안상 요청 단위로 처리하는 게 안전합니다. 업비트의 경우 프라이빗 데이터 실시간 구독(WebSocket Private Channel)도 제공하지만, 이는 내 체결(myTrade), 내 주문 상태(myOrder) 등의 이벤트 알림 용도입니다[15]. 지속 polling이 부담되는 영역(예: 주문 체결 알림)은 WebSocket 이벤트로 처리하고, 그 외에는 REST로 수시 조회하는 하이브리드 운용이 바람직합니다. WebSocket 프라이빗 채널을 쓰려면 JWT 인증이 필요하고 구현이 복잡하므로, 통합 채널에서는 우선 주기적 REST 조회 + 중요 이벤트는 WebSocket 방식으로 기준을 세웁니다.
* 시스템 상태/메타 정보 ? REST 사용: API 키 관리, 지원 마켓 목록, 서버 시간 등 비교적 변동이 없거나 단발성 정보 조회는 REST로 충분합니다. 이러한 요청은 빈도가 낮고 WebSocket으로 제공하지 않으므로 자연스럽게 REST 경로를 택합니다.
요약하면, “한번 요청으로 많은 데이터 or 과거 데이터”는 REST, “지속적 업데이트/다중 종목 실시간 모니터링”은 WebSocket을 사용하는 것이 효율적입니다[16]. 특히 UI 실시간 가격 표시, 자동매매 트리거 등은 WebSocket으로 처리하고, 초기 로딩과 백테스트용 데이터 수집은 REST로 처리하는 전략을 취합니다[17].
스마트 채널 라우터(SmartChannelRouter) 설계 고려사항
REST와 WebSocket을 하나의 채널처럼 투명하게 사용할 수 있게 해주는 SmartChannelRouter를 설계할 때는 아래 조건들을 고려해야 합니다.
* 데이터 실시간성 vs 신뢰성: 라우터는 요청의 실시간 요구 수준을 판단하여 WebSocket 경로를 선택해야 합니다. 예를 들어 “최신 가격을 매 1초 계속 확인”하는 요청이면 WebSocket으로 라우팅하고, “특정 시점의 가격을 한 번 확인”하는 요청이면 REST로 처리하도록 합니다. 이 때 WebSocket의 경우 네트워크 불안정으로 일시 지연이나 끊김 가능성을 감안하여, 실시간성 필요도가 높지만 WS 문제가 있는 상황에서는 임시로 REST 대안 경로를 사용하는 폴백(fallback)도 고려해야 합니다[18][19]. 즉, 1순위 WebSocket이지만 연결 이상 시 자동 REST 대체가 이루어지도록 라우팅 조건을 설정합니다.
* 호출 빈도와 패턴 감지: 라우터는 특정 데이터에 대한 요청 빈도를 모니터링하여 일정 임계치를 넘으면 WebSocket 구독으로 전환하도록 설계할 수 있습니다. 예를 들어 프로그램이 1분 내 같은 마켓의 get_ticker를 수십 번 호출하면, 해당 마켓을 WebSocket으로 자동 구독하고 이후에는 REST 호출을 중단하는 방식입니다. 이를 위해 최근 요청 카운트, Rate Limit 여유 등을 추적하여 자동 채널 전환 조건을 만들어둡니다. 이때 전환 시에는 현재까지 수집한 데이터와의 연속성을 유지해야 하므로, REST로 받은 마지막 값과 WebSocket 최초 스냅샷을 비교·조율하는 작업이 필요합니다.
* 데이터 타입 지원 여부: 일부 데이터 타입은 WebSocket에서 제공되지 않거나 적합하지 않을 수 있으므로, 라우터는 요청된 API 타입에 따라 고정 라우팅도 해야 합니다. 예를 들어 주문 체결 내역(histories) 요청은 REST 전용이므로 무조건 REST로 보내야 하고, 실시간 호가 흐름 요청은 WebSocket 전용으로 보냅니다. 지원 채널 매트릭스를 미리 정의하여 (ticker/trade/orderbook -> WS, candles -> REST, account -> REST 등) 라우팅 조건의 기본 맵핑으로 활용합니다.
* 시스템 자원 및 연결 상태: WebSocket 연결은 수가 제한되므로 (업비트 websocket-connect 제한 초당 5회 등) 라우터는 현재 열린 WebSocket 연결 수와 상태를 고려해야 합니다. 이미 연결이 존재하고 구독 가능한 경우 새로운 요청을 굳이 REST로 할 필요가 없지만, 연결 생성이 빈번해지는 상황에서는 일부 요청은 REST로 처리하여 연결 남발을 막아야 합니다. 또한 연결 수명주기를 관리하여, 일정 시간 사용하지 않으면 연결을 정리하거나, 반대로 빈번히 쓰이는 경우 끊김 시 자동 재연결하는 등 커넥션 풀 및 재연결 전략을 내재화합니다[12].
* 초기 응답 속도 최적화: WebSocket 연결 후 첫 데이터 수신까지 약간의 세팅 시간이 필요할 수 있으므로, 라우팅 로직은 초기 응답을 빠르게 하기 위한 전략도 고려합니다. 예를 들어 UI에서 새로운 종목 차트를 열 때 REST로 해당 종목 최신 데이터 1회 조회한 후, 동시에 WebSocket을 구독시켜 이후 업데이트를 받는 방식을 들 수 있습니다[20]. 이렇게 하면 사용자는 즉시 첫 화면을 보고, 이후 실시간 갱신을 놓치지 않는 이점을 얻습니다. SmartChannelRouter는 이러한 듀얼 접근을 내부에서 자동으로 수행하여, “초기엔 REST, 이어서 WS 지속 업데이트” 패턴을 지원하도록 설계할 수 있습니다.
* 에러 및 예외 상황 대응: 라우터는 각 채널별 오류 상황에 따른 대응도 달리해야 합니다. WebSocket에서 연결 끊김/에러 발생 시 라우터는 해당 채널을 통한 데이터 전송을 일시 정지하고, 필요한 경우 REST로 대체하거나 재연결을 시도해야 합니다[18]. 예를 들어 WebSocket으로 호가를 수신하다가 연결이 끊기면, 라우터는 즉시 REST /orderbook 호출로 최신 호가를 가져와 준뒤 WebSocket을 재시도함으로써 데이터 공백을 최소화하는 식입니다. 반대로 REST에서 HTTP 429 Too Many Requests 오류가 발생하면, 라우터는 해당 데이터를 WebSocket으로 전환해서 지속 수신함으로써 Rate Limit 문제를 완화할 수 있습니다. 이러한 교차 보완 로직이 SmartChannelRouter에 포함되면 두 채널의 장점을 극대화할 수 있습니다.
* 사용자 요청 형태 추상화: 최종적으로 라우터는 통합 인터페이스 상에서 사용자에게 동일한 요청 메서드를 제공하지만 내부적으로는 상황 따라 다른 채널을 쓴다는 점을 투명하게 처리해야 합니다. 이를 위해 입력 파라미터나 메서드 유형으로부터 라우팅 힌트를 얻을 수 있어야 합니다. 예를 들어 subscribe=True 플래그가 달린 요청은 강제로 WebSocket 경로를 사용하게 하거나, 특정 메서드명 (stream_ prefix 등)이 붙으면 WebSocket을 쓰도록 약속할 수 있습니다. 또는 완전히 자동화하려면 위에서 언급한 빈도, 실시간성 조건을 코드가 판단하도록 하지만, 명시적인 힌트도 함께 운용하면 예측 가능성이 높아집니다.
단일 API 통합을 위한 데이터 구조 및 에러 처리 통일
REST와 WebSocket에서 오는 응답 데이터 구조가 미세하게 다르므로, 단일화된 API에서는 이를 공통된 구조로 표준화해야 합니다. 주요 고려사항은 다음과 같습니다.
* 필드 이름 및 포맷 통일: 업비트 REST API의 JSON 필드와 WebSocket 필드명이 약간 차이가 있습니다. 예를 들어 REST 현재가 응답은 { "market": "KRW-BTC", "trade_price": 1370000, ... } 형식인데, WebSocket 현재가 응답은 { "type": "ticker", "code": "KRW-BTC", "trade_price": 1370000, ... } 형태로 종목 코드를 표시하는 키가 market vs code로 다릅니다. 통합 API에서는 이런 차이를 추상화하여 일관된 키 사용으로 제공해야 합니다. 즉, 내부적으로 WebSocket에서 수신한 데이터의 "code"를 "market"으로 바꾸거나, 반대로 REST 데이터의 "market"을 "code"로 맞추는 등의 매핑을 수행합니다. 마찬가지로 타임스탬프 필드도 REST는 trade_timestamp(ms 단위)나 문자열 시간을 제공하고 WebSocket은 timestamp(ms) 필드와 별도로 trade_date, trade_time 등을 주는데, 이러한 시간 정보도 공통 포맷으로 변환합니다. 예컨대 모든 시간 값을 Python datetime 객체나 ISO8601 문자열 등 통일된 형식으로 노출하는 식입니다.
* 데이터 객체 모델링: 통합 채널에서 다루는 주요 시세 데이터 타입(호가, 티커, 체결, 캔들 등)에 대해 공용 데이터 클래스(또는 딕셔너리 구조)를 정의해두면 유용합니다. 예를 들어 MarketTicker 클래스에는 market, trade_price, high_price, low_price 등 필드를 가지고, REST 호출 결과나 WebSocket 티커 이벤트나 모두 이 클래스로 매핑해서 돌려주는 방식입니다. 이를 통해 사용자 코드가 .market이나 .trade_price 속성을 일관되게 사용하게 할 수 있고, 데이터 출처에 관계없이 동일한 데이터 구조를 다루게 됩니다. 호가(orderbook)의 경우 REST는 orderbook_units 리스트로 15호가를 주고 WebSocket도 유사한 구조를 주므로 비교적 통일하기 쉽지만, 실시간 체결(trade)은 REST는 과거 체결 리스트를 주고 WebSocket은 개별 체결 이벤트를 푸시하는 차이가 있습니다. 이럴 때 통합 API에서는 WebSocket으로 들어온 단일 체결 이벤트도 리스트에 담거나, REST 응답의 리스트도 이벤트 단위로 쪼개서 publish하는 등 형태를 맞춰서 제공해야 합니다. 목표는 사용자 입장에서 “어떤 채널이든 동일한 데이터 형태”를 받도록 하는 것입니다.
* 스트림 타입 처리: WebSocket 시세 응답에는 stream_type 필드로 SNAPSHOT인지 REALTIME 업데이트인지를 표시해 줍니다. REST 응답에는 이런 개념이 없고 항상 해당 시점의 스냅샷이므로, 통합 API에서 이 필드는 메타데이터로서 선택적으로 활용할 수 있습니다. 예컨대 최초 WebSocket 구독시 받은 스냅샷과 이후 실시간 업데이트를 구분하고 싶다면 통합 데이터 객체에 is_snapshot 같은 불리언을 두거나, 이벤트의 타입을 구분하여 전달할 수 있습니다. 사용자에게 굳이 노출할 필요가 없다면 모든 응답을 동일하게 취급하고 내부적으로만 사용할 수도 있습니다. 중요한 것은, 동일한 정보는 동일한 필드명/타입으로 노출하고 채널 고유의 부가 정보는 필요 시 별도 필드나 메타정보로 관리하는 접근입니다.
* 에러 처리 통합: REST와 WebSocket의 오류 전달 방식이 다르므로, 이를 단일 API에서는 일관된 예외 처리 흐름으로 통합해야 합니다. Upbit REST API는 잘못된 요청이나 Rate Limit 초과 시 HTTP 상태 코드와 JSON 메시지(예: 429 Too Many Requests 등)를 반환합니다. WebSocket은 연결 후 구독 요청이 잘못되면 별도의 오류 메시지 JSON을 보내는데, 예를 들어 인증 없이 프라이빗 구독을 하면 {"error":{"name":"INVALID_AUTH","message":"Authentication information is incorrect."}} 형식의 에러가 수신됩니다. 통합 API 레이어에서는 이런 WebSocket 오류 이벤트를 캐치하여 REST 예외와 동일한 형태의 Exception으로 변환하거나, 오류 코드를 공통 ENUM으로 관리하도록 합니다. 예를 들어 INVALID_AUTH가 오면 내부적으로 AuthenticationError 예외를 발생시키고, REST의 401 Unauthorized도 같은 AuthenticationError로 처리하여 사용자 코드가 동일한 방식으로 예외처리를 하도록 유도합니다. 마찬가지로 WRONG_FORMAT, NO_TICKET 등의 WebSocket 오류는 잘못된 요청 파라미터로 간주해 ApiClientError 또는 특정 Validation 예외로 매핑합니다. 또한 WebSocket 연결 끊김/타임아웃 상황도 하나의 예외로 규정하여 (예: NetworkError) REST 호출 실패시의 네트워크 오류와 같은 계열로 처리하면, 상위 로직에서 채널 종류에 상관없이 일관된 재시도 또는 사용자 통보 로직을 구현할 수 있습니다. 통합 API에서는 내부적으로 REST 응답의 error_message나 WebSocket 오류 메시지를 파싱한 후 統一된 Exception 클래스를 던지도록 하며, 로그에도 채널 구분 없이 동일한 에러 레벨과 포맷으로 남기도록 합니다.
* 스레딩/비동기 처리 통일: REST는 HTTP 요청으로 동기/비동기 호출 모두 구현하기 쉽고, WebSocket은 이벤트 드리븐으로 비동기로 동작합니다. 통합 API를 사용할 때 개발자가 크게 신경쓰지 않도록, 비동기 프로그래밍 모델을 기준으로 통일하는 것이 좋습니다. 예컨대 Python asyncio 환경에서 await unified_api.get_ticker("KRW-BTC")를 호출하면, 내부에서 이미 구독 중인 경우 캐시된 최신값을 바로 반환하거나 아니면 REST 호출을 await하여 반환하게 합니다. 또한 subscribe_ticker("KRW-BTC") 같은 메서드는 async 제너레이터나 콜백을 통해 스트림을 전달하게 하고, REST 방식으로 반복 호출하는 것과 유사한 인터페이스를 이벤트로 대체합니다. 이러한 비동기 통일은 기존 REST 호출부를 크게 변경하지 않으면서도 자연스럽게 WebSocket의 async 특성을 녹여내는 방법입니다. 동기 방식 코드와의 호환이 필요하다면, 통합 API에서 blocking 호출을 별도로 제공하거나, 사용자에게 명시적으로 run_until_complete 등을 안내하는 방식으로 조율할 수 있습니다.
기존 코드베이스에의 통합 API 연동 및 마이그레이션 제안
현재 사용자님의 코드(invisible0000/upbit-autotrader-vscode) 구조를 보면, REST용 UpbitPublicClient/UpbitPrivateClient와 WebSocket용 UpbitWebSocketQuotationClient 등이 분리되어 있고, 서비스 레이어에서 이를 따로 활용하고 있습니다. 예를 들어 시세 조회는 UpbitClient.public.get_tickers(...) 형태로 REST를 사용하고, 실시간 업데이트는 WebSocketMarketDataService를 통해 이벤트로 처리하고 있습니다. 이러한 구조에서 UnifiedMarketDataAPI를 도입/마이그레이션하는 방안은 다음과 같습니다.
1. UnifiedMarketDataAPI 클래스 구현: 새로운 통합 클래스(UnifiedMarketDataAPI)를 만들어 UpbitPublicClient와 UpbitWebSocketQuotationClient를 내부에 포함(composition)시킵니다. 이 클래스는 싱글톤이나 애플리케이션 전역 인스턴스로 운용하면서, 초기화 시 WebSocket 클라이언트를 연결 및 유지하고 필요하면 public client도 재사용하도록 합니다. 메서드로는 기존 UpbitPublicClient의 시세 조회 메서드들(get_ticker, get_orderbook, get_trades 등)과 WebSocket 구독 메서드(subscribe_ticker, subscribe_orderbook 등)를 동일한 인터페이스로 제공하되, 내부 구현은 SmartChannelRouter 로직을 따라 적절한 채널을 선택하게 합니다. 예를 들어 UnifiedMarketDataAPI.get_current_price(market)를 호출하면, 해당 마켓이 이미 WebSocket으로 구독된 상황이면 최신 캐시 값을 바로 반환하고, 구독 안 되어 있고 요청 빈도가 낮은 호출이라 판단되면 REST get_ticker를 호출하는 식입니다. 반대로 UnifiedMarketDataAPI.subscribe_ticker(market, callback)을 호출하면 내부적으로 WebSocket 구독을 설정하고, 콜백으로 틱 데이터가 들어올 때마다 callback(data)를 호출하거나, async 이터레이터로 이벤트 스트림을 반환합니다. 이렇게 단일 진입점 API를 만들면 기존 코드가 REST나 WS를 직접 다루지 않고 이 통합 클래스에만 의존하도록 리팩토링할 수 있습니다.
2. 기존 코드 수정 최소화: 마이그레이션시 이상적인 것은 외부 호출부의 코드 변경을 줄이는 것입니다. 이를 위해 UnifiedMarketDataAPI의 메서드 시그니처를 UpbitPublicClient와 가능하면 맞추고, 반환 데이터 구조도 앞서 통일한 형태로 동일하게 합니다. 예를 들어 기존에 prices = await upbit_client.get_tickers(["KRW-BTC","KRW-ETH"]) 하던 부분은 prices = await unified_api.get_tickers(["KRW-BTC","KRW-ETH"])로만 바꿔도 동일한 결과(List of dict 등)를 얻게 합니다. 내부적으로는 첫 호출이면 REST로 값을 받고 동시에 해당 종목들을 WebSocket 구독 걸어두어 다음 업데이트부터는 이벤트로 캐시를 갱신하도록 합니다. 만약 기존 코드가 주기적으로 get_tickers를 호출하고 있었다면, 통합 API로 교체한 뒤에는 주기 호출을 없애고 이벤트 드리븐으로 개선할 수 있습니다. 예컨대 기존의 while True: prices = get_tickers(...); ... time.sleep(1) 루프를, Unified API의 subscribe_ticker로 대체하고 가격 변화시 콜백을 처리하거나 이벤트 버스로 전달하는 형태로 변경합니다. 다행히 사용자님의 코드에는 WebSocketMarketDataService와 InMemoryEventBus를 이용해 이벤트 기반 구조가 마련되어 있으므로, 이를 적극 활용합니다. UnifiedMarketDataAPI 내에서도 이러한 이벤트 버스에 구독하여 도메인 이벤트(WebSocketTickerUpdateEvent 등)를 퍼블리시하고, 기존에 REST 폴링 결과를 처리하던 로직 대신 이벤트 수신 로직을 사용하도록 Application 계층을 리팩토링합니다.
3. 점진적 하이브리드 접근: 완전한 통합 전에, 우선 WebSocket 우선 전략으로 변경할 수 있는 부분부터 통합 API를 적용합니다. 예를 들어 UI의 실시간 차트나 호가창 갱신 부분은 이미 WebSocketMarketDataService를 쓰고 있다면, 이를 UnifiedMarketDataAPI로 교체하여 REST 백업 로직을 추가합니다. 반대로 백엔드의 특정 전략 모듈이 아직 REST로 가격을 주기 조회한다면, 우선 Unified API를 통해 REST + WS 혼용으로 동작하게 한 뒤 성능을 모니터링합니다. 즉, 실시간성 영향이 큰 모듈부터 WebSocket 활용도를 높이는 방향으로 통합을 진행합니다[14][16]. 이러한 하이브리드 단계에서는 예기치 않은 동시 구독 이슈나 데이터 동기화 문제를 발견해 조정할 수 있습니다.
4. 기존 컴포넌트와의 연계: 현재 UpbitClient가 public/private API 클라이언트를 감싸고 있으므로, UnifiedMarketDataAPI를 UpbitClient 내부에 옵션으로 포함시키는 방법도 있습니다. 예컨데 UpbitClient 생성 시 use_websocket=True 플래그를 주면 내부에서 UnifiedMarketDataAPI를 초기화하고, get_tickers 등 호출을 가로질러 통합 경로로 처리하게 만드는 것입니다. 또는 UpbitClient를 그대로 두고 별도의 MarketDataService 인터페이스를 도메인 계층에 주입하여, 실제 구현체로 UnifiedMarketDataAPI를 넣어주는 방식도 가능합니다 (의존성 주입). 중요 포인트는 기존 REST 전용 로직에 WebSocket을 개입시킬 지점을 찾아 코드 변경을 국소화하는 것입니다. 예를 들어 monitoring 모듈에 Rate Limit 감시를 하고 있다면, WS를 쓰면 호출 횟수가 줄어들어 해당 모듈 로직도 조정해야 할 수 있습니다. 이러한 연계 포인트들(모니터링, 로깅 등)을 함께 업데이트하여 통합 채널 사용에 따른 보조 로직도 일관성을 유지하도록 합니다.
5. 테스트 및 단계적 배포: 통합 API로의 마이그레이션은 철저한 테스트가 요구됩니다. WebSocket의 특성상 비동기 타이밍 이슈나, 연결 끊김시 재시도 등 예외 상황을 재현하여 검증해야 합니다. 기존 REST 코드와 결과가 100% 동일함을 보장하기 위해, 통합 API에서 얻은 값과 REST 개별 호출 값을 일정 기간 로그로 둘 다 남겨 비교하는 방법도 권장됩니다. 성능 측면에서는 WebSocket 전환으로 API 호출 수 감소, 반응 속도 향상 등의 이점을 얻을 것으로 기대되나, 실제 메모리 사용량(예: 모든 종목 구독 시 메모리)이나 네트워크 트래픽 변화도 살펴야 합니다. 문제 없다고 판단되면 점진적으로 전체 시스템에 적용하고, 사용하지 않는 옛 REST 호출 코드나 클래스(UpbitPublicClient 직접 사용 부분 등)는 정리합니다.
요약하면, UnifiedMarketDataAPI 도입으로 기존 구조에 큰 변화를 주지 않으면서 REST와 WebSocket의 장점을 모두 활용할 수 있습니다. 핵심 데이터 흐름을 통합 채널로 옮김으로써 실시간성 향상, 호출 부담 경감(Rate Limit 여유), 코드 일관성 향상을 기대할 수 있습니다. 최종적으로 개발자는 단일한 인터페이스를 사용하지만 내부에서는 스마트하게 REST/WS를 오가며 동작하게 되고, 시스템은 보다 견고하고 효율적으로 업비트 마켓 데이터를 처리하게 될 것입니다.
참고 자료: 업비트 공식 개발자 문서의 REST/WebSocket 가이드 및 Rate Limit 정책, 사용자 코드 리포지토리의 WebSocket 가이드 문서[3][16]. 이러한 내용을 바탕으로 설계된 통합 채널은 향후 업비트 API 변경에도 유연하게 대응할 수 있도록 추상화 계층을 제공한다는 추가 이점도 갖습니다.

[1] [3] [4] [5] [6] [9] [10] [12] [13] [14] [15] [16] [17] [18] [19] [20] GitHub
https://github.com/invisible0000/upbit-autotrader-vscode/blob/cf8a7b0941aae67d279a1166d204572c045c4273/docs/UPBIT_API_WEBSOCKET_GUIDE.md
[2] [11] GitHub
https://github.com/invisible0000/upbit-autotrader-vscode/blob/cf8a7b0941aae67d279a1166d204572c045c4273/docs/UPBIT_ORDERBOOK_API_GUIDE.md
[7] [8] GitHub
https://github.com/invisible0000/upbit-autotrader-vscode/blob/cf8a7b0941aae67d279a1166d204572c045c4273/upbit_auto_trading/infrastructure/external_apis/upbit/upbit_public_client.py
