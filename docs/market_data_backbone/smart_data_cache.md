캔들 캐시가 복잡한 이유를 논리적으로 추론하기 위해 업비트 API의 특성과 캔들 데이터의 특수성을 분석해보겠습니다. 이제 캔들 완성도 판단 로직을 더 자세히 확인해보겠습니다. ## 🧠 캔들 캐시 복잡성의 논리적 분석 결과

캔들 캐시가 복잡한 이유를 분석한 결과, **업비트 API의 근본적 특성**과 **실시간 트레이딩의 요구사항** 때문임을 확인했습니다.

### 🎯 핵심 문제: **업비트 API의 본질적 제약사항**

#### 1. **WebSocket vs REST API 패러독스**
```
🔄 WebSocket: 실시간 스트림 ONLY
- ✅ 최신 1개 캔들만 실시간 업데이트
- ❌ 과거 데이터/다중 데이터 불가능
- ❌ 미완성 캔들과 완성 캔들 구분 불가

📊 REST API: 히스토리 조회 전용
- ✅ 과거 데이터 조회 가능 (count, to 매개변수)
- ✅ 완성된 캔들만 반환 (빈 캔들 제외)
- ❌ 실시간 스트림 불가능
- ❌ Rate Limit (초당 10회, 분당 600회)
```

#### 2. **캔들 완성도 불확실성**
```python
# 업비트 API 특성
safety_margin_seconds = 30  # 안전 마진 30초

# 문제: 캔들 종료 시간 ≠ API 반영 시간
# 1분 캔들 09:00:00~09:01:00 → 실제 API 반영: 09:01:15~09:01:30
```

#### 3. **빈 캔들 vs 미수집 캔들 구분 필요**
```
❓ DB에 캔들이 없는 경우:
1. 실제로 거래가 없음 (빈 캔들) → 차트용 채움 필요
2. 아직 API 호출 안함 (미수집) → API 재요청 필요
3. API 호출했지만 아직 미완성 → 메모리 캐시 확인 필요
```

### 🏗️ 필연적 복잡성: **다층 캐시 구조의 논리적 근거**

#### **Layer 1: 실시간 메모리 캐시** (`RealtimeCandleManager`)
- **목적**: WebSocket의 미완성 캔들 관리
- **이유**:
  - WebSocket은 실시간으로 캔들 업데이트를 전송
  - 하지만 완성도를 알 수 없음
  - 미완성 캔들을 DB에 저장하면 데이터 오염

#### **Layer 2: 영구 SQLite 캐시** (`SqliteCandleRepository`)
- **목적**: 완성된 캔들의 확실한 저장소
- **이유**:
  - REST API Rate Limit 우회
  - 과거 데이터 고속 조회
  - 수집 상태 메타데이터 관리

#### **Layer 3: 응답 캐시** (`SmartRouter`)
- **목적**: API 응답의 임시 캐시
- **이유**:
  - 동일한 요청의 중복 API 호출 방지
  - 네트워크 지연 완충

#### **Layer 4: 수집 상태 관리** (`CollectionStatusManager`)
- **목적**: 빈 캔들과 미수집 구분
- **이유**:
  - 업비트 API는 빈 캔들을 반환하지 않음
  - 차트 연속성을 위해 빈 캔들 채움 필요
  - 무의미한 재요청 방지

### 🔬 **업비트 API 특성 분석**

#### **WebSocket 캔들의 문제점**
```python
# WebSocket에서 받은 캔들 데이터
{
    "market": "KRW-BTC",
    "candle_date_time_kst": "2025-08-23T14:30:00",
    "opening_price": 50000000,
    "trade_price": 50100000,
    # ... 하지만 완성도를 알 수 없음
}

# 문제: 이 캔들이 완성되었는지 미완성인지 판단 불가
# 해결: 시간 기반 완성도 추론 + 30초 안전 마진
```

#### **REST API 캔들의 한계**
```python
# REST API 특성
- 거래가 없으면 응답에 포함되지 않음
- 완성된 캔들만 반환
- Rate Limit으로 고빈도 조회 불가

# 예: 1분간 거래가 없었던 경우
# 요청: 09:30~09:35 (5개 캔들 기대)
# 응답: [09:30, 09:32, 09:35] (3개만 반환)
# 누락: 09:31, 09:34 → 빈 캔들임을 알 수 없음
```

### 💡 **결론: 복잡성의 필연성**

캔들 캐시의 복잡성은 **업비트 API의 구조적 한계**를 극복하기 위한 **필연적 설계**입니다:

1. **WebSocket 실시간성** + **REST 안정성** = 하이브리드 필요
2. **미완성 캔들 처리** + **완성 캔들 저장** = 이중 캐시 필요
3. **빈 캔들 구분** + **미수집 추적** = 메타데이터 관리 필요
4. **Rate Limit 회피** + **고속 조회** = 영구 캐시 필요

이는 **업비트 API의 제약을 우회하면서도 실시간 트레이딩의 요구사항을 만족**하기 위한 최적화된 설계입니다.

**단순화하면 기능이 제한되고, 복잡성을 받아들여야 완전한 솔루션을 제공할 수 있습니다.**
