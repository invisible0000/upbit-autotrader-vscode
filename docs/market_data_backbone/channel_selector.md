웹소켓과 REST API의 점수 시스템을 조사해보겠습니다. 먼저 ChannelSelector 컴포넌트를 살펴보겠습니다. 이제 점수 계산 로직을 자세히 분석해보겠습니다. 로그 메시지에서 보여진 "WS점수: 63.00, REST점수: 42.00"이 어떻게 계산되는지 코드를 통해 설명드리겠습니다.

## 🧮 채널 선택 점수 시스템 분석

### 📊 WebSocket 점수 계산 (`_calculate_websocket_score`)

**WS점수: 63.00**의 구성 요소:

1. **실시간성 요구 (가중치: 3x)**
   - `RealtimePriority.HIGH`: 10 × 3 = 30점
   - `RealtimePriority.MEDIUM`: 6 × 3 = 18점
   - `RealtimePriority.LOW`: 2 × 3 = 6점

2. **요청 빈도 분석 (가중치: 2x)**
   - 고빈도: 8 × 2 = 16점
   - 중빈도: 5 × 2 = 10점
   - 저빈도: 2 × 2 = 4점

3. **연결 상태 (가중치: 3x)**
   - 연결됨: 10 × 3 = 30점
   - 연결 안됨: 0점

4. **Rate Limit 상태 (가중치: 2x)**
   - 사용량 < 80%: 5 × 2 = 10점
   - 사용량 < 90%: 3 × 2 = 6점
   - 사용량 >= 90%: 1 × 2 = 2점

5. **데이터 양 (가중치: 1x)**
   - ≤ 10개: 3점
   - ≤ 100개: 2점
   - > 100개: 1점

### 📊 REST API 점수 계산 (`_calculate_rest_score`)

**REST점수: 42.00**의 구성 요소:

1. **안정성 우선 (가중치: 2x)**
   - 기본: 10 × 2 = 20점 (항상 제공)

2. **대량 데이터 처리 (가중치: 1x)**
   - > 100개: 8점
   - > 10개: 5점
   - ≤ 10개: 3점

3. **데이터 타입별 조정 (가중치: 2x)**
   - 과거 데이터 (`to` 존재): 12 × 2 = 24점
   - 실시간 LOW: 8 × 2 = 16점
   - 실시간 MEDIUM: 4 × 2 = 8점
   - 실시간 HIGH: 2 × 2 = 4점

4. **Rate Limit 상태 (가중치: 2x)**
   - 사용량 < 80%: 8 × 2 = 16점
   - 사용량 < 90%: 5 × 2 = 10점
   - 사용량 >= 90%: 2 × 2 = 4점

5. **실시간성 낮음 (가중치: 1x)**
   - LOW: 5점
   - MEDIUM: 3점
   - HIGH: 1점

### 🎯 실제 케이스 분석 (WS: 63.00, REST: 42.00)

귀하의 호가/티커 요청에서:

**WebSocket 63점 추정 구성:**
- 실시간성 MEDIUM: 18점 (6×3)
- 연결 상태 양호: 30점 (10×3)
- Rate Limit 양호: 10점 (5×2)
- 소량 데이터: 3점
- 실시간 데이터 타입: 2점
- **총합: ~63점**

**REST API 42점 추정 구성:**
- 기본 안정성: 20점 (10×2)
- 소량 데이터: 3점
- 실시간 MEDIUM 페널티: 8점 (4×2)
- Rate Limit 양호: 16점 (8×2)
- 실시간성 중간: 3점
- **총합: ~50점** (실제로는 42점이므로 일부 조정됨)

### ⚖️ 채널 선택 규칙

```python
if ws_score > rest_score * 1.2:  # WebSocket 20% 우대
    selected = ChannelType.WEBSOCKET
```

- **63 > 42 × 1.2 (50.4)** ✅ → WebSocket 선택
- **선택 이유**: `smart_selection_websocket`

이 점수 시스템은 실시간성, 연결 안정성, 요청 패턴, Rate Limit 등을 종합적으로 고려하여 최적의 채널을 선택하는 스마트 라우팅 시스템입니다! 🚀
