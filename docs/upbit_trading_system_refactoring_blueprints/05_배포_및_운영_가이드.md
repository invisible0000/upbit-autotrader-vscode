# 업비트 자동매매 시스템 통합 청사진 v2.2 - 05: 배포 및 운영 가이드

## 배포 아키텍처 설계 (80% 완료)

### 🎯 배포 전략 개요

현재 시스템은 **설치형 데스크톱 애플리케이션**으로 설계되어 있으며, 루트 `data/` 폴더를 활용한 포터블 배포 구조를 채택하고 있습니다.

```
배포 구조 (최종 확정):
upbit-autotrader/                    # 메인 애플리케이션 폴더
├── 📁 upbit_auto_trading/           # 핵심 소스 코드
│   ├── business_logic/              # 비즈니스 로직 계층
│   ├── component_system/            # 컴포넌트 시스템
│   ├── data_layer/                  # 데이터 계층
│   ├── ui/                         # UI 계층  
│   ├── config/                     # 설정 관리
│   └── utils/                      # 유틸리티
├── 📁 data/                        # 데이터베이스 파일 (사용자 데이터)
│   ├── settings.sqlite3            # 시스템 설정 + 거래변수
│   ├── strategies.sqlite3          # 사용자 전략 + 실행 데이터  
│   ├── market_data.sqlite3         # 시장 데이터 + 차트 정보
│   └── settings/                   # API 키 암호화 폴더
├── 📁 logs/                        # 로그 파일
├── 📁 backups/                     # 자동 백업 파일
├── 📄 run_desktop_ui.py            # 메인 실행 파일
├── 📄 requirements.txt             # 의존성 패키지
└── 📄 README.md                    # 사용자 가이드
```

### 🔧 설치형 환경 최적화 설계

#### 1. 포터블 경로 시스템 (완료)
```python
# config/database_paths.py - 설치 위치 무관한 상대 경로 자동 감지
class DatabasePaths:
    # 현재 파일 기준 프로젝트 루트 자동 계산
    BASE_DIR = Path(__file__).parent.parent.parent  # auto-detection
    DATA_DIR = BASE_DIR / "data"  # 루트 data 폴더 활용
    
    # 포터블 데이터베이스 경로
    SETTINGS_DB = DATA_DIR / "settings.sqlite3"
    STRATEGIES_DB = DATA_DIR / "strategies.sqlite3"  
    MARKET_DATA_DB = DATA_DIR / "market_data.sqlite3"
```

#### 2. 환경 독립적 설정 관리
```python
# 운영체제별 최적화된 설정
DEPLOYMENT_CONFIG = {
    "windows": {
        "python_executable": "python.exe",
        "package_format": "exe",  # PyInstaller
        "install_location": "%APPDATA%/UpbitAutoTrader",
        "data_location": "data/"  # 상대 경로
    },
    "macos": {
        "python_executable": "python3",
        "package_format": "app",  # py2app
        "install_location": "~/Applications/UpbitAutoTrader.app",
        "data_location": "data/"
    },
    "linux": {
        "python_executable": "python3", 
        "package_format": "appimage",  # AppImage
        "install_location": "~/opt/upbit-autotrader",
        "data_location": "data/"
    }
}
```

### 📦 패키징 및 빌드 시스템

#### 1. PyInstaller 기반 실행 파일 생성
```python
# build_scripts/build_windows.spec
# -*- mode: python ; coding: utf-8 -*-

import os
from pathlib import Path

# 소스 코드 루트 경로
project_root = Path.cwd()
upbit_auto_trading_path = project_root / "upbit_auto_trading"

a = Analysis(
    ['run_desktop_ui.py'],  # 메인 엔트리포인트
    pathex=[str(project_root)],
    binaries=[],
    datas=[
        # 설정 파일들 포함
        (str(upbit_auto_trading_path / "config" / "*.yaml"), "upbit_auto_trading/config"),
        # UI 리소스 파일들 포함  
        (str(upbit_auto_trading_path / "ui" / "desktop" / "resources"), "upbit_auto_trading/ui/desktop/resources"),
    ],
    hiddenimports=[
        'PyQt6.QtCore',
        'PyQt6.QtWidgets', 
        'PyQt6.QtGui',
        'sqlite3',
        'pandas',
        'numpy',
        'requests',
        'upbit_auto_trading'
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=None,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=None)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='UpbitAutoTrader',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,  # GUI 애플리케이션
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='upbit_auto_trading/ui/desktop/resources/icon.ico'  # 애플리케이션 아이콘
)
```

#### 2. 자동화된 빌드 스크립트
```python
# build_scripts/automated_build.py
#!/usr/bin/env python3
"""
자동화된 배포 빌드 시스템
- 플랫폼별 빌드 환경 설정
- 의존성 패키지 검증 및 설치
- 실행 파일 생성 및 테스트
- 배포 패키지 압축 및 체크섬 생성
"""

import os
import sys
import platform
import subprocess
import shutil
from pathlib import Path

class AutomatedBuilder:
    def __init__(self):
        self.platform = platform.system().lower()
        self.project_root = Path.cwd()
        self.build_dir = self.project_root / "build"
        self.dist_dir = self.project_root / "dist"
        
    def prepare_build_environment(self):
        """빌드 환경 준비"""
        print("🔧 빌드 환경 준비 중...")
        
        # 이전 빌드 결과물 정리
        if self.build_dir.exists():
            shutil.rmtree(self.build_dir)
        if self.dist_dir.exists():
            shutil.rmtree(self.dist_dir)
            
        # 필수 디렉토리 생성
        self.build_dir.mkdir(exist_ok=True)
        self.dist_dir.mkdir(exist_ok=True)
        
    def verify_dependencies(self):
        """의존성 패키지 검증"""
        print("📦 의존성 패키지 검증 중...")
        
        required_packages = [
            "PyQt6>=6.5.0",
            "pandas>=2.0.0", 
            "numpy>=1.24.0",
            "requests>=2.31.0",
            "sqlite3",  # 표준 라이브러리
            "pyinstaller>=5.13.0"
        ]
        
        for package in required_packages:
            try:
                if package != "sqlite3":  # sqlite3는 표준 라이브러리
                    subprocess.check_call([sys.executable, "-c", f"import {package.split('>=')[0]}"])
                print(f"✅ {package}")
            except subprocess.CalledProcessError:
                print(f"❌ {package} - 설치 필요")
                return False
        return True
        
    def build_executable(self):
        """실행 파일 생성"""
        print(f"🚀 {self.platform} 플랫폼용 실행 파일 생성 중...")
        
        spec_file = self.project_root / "build_scripts" / f"build_{self.platform}.spec"
        
        if not spec_file.exists():
            print(f"❌ {spec_file} 파일을 찾을 수 없습니다.")
            return False
            
        # PyInstaller 실행
        cmd = [sys.executable, "-m", "PyInstaller", str(spec_file)]
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print("✅ 실행 파일 생성 완료")
            return True
        else:
            print(f"❌ 빌드 실패: {result.stderr}")
            return False
            
    def test_executable(self):
        """생성된 실행 파일 테스트"""
        print("🧪 실행 파일 테스트 중...")
        
        if self.platform == "windows":
            exe_path = self.dist_dir / "UpbitAutoTrader.exe"
        else:
            exe_path = self.dist_dir / "UpbitAutoTrader"
            
        if not exe_path.exists():
            print("❌ 실행 파일을 찾을 수 없습니다.")
            return False
            
        # 간단한 실행 테스트 (버전 정보 출력)
        try:
            result = subprocess.run([str(exe_path), "--version"], 
                                  capture_output=True, text=True, timeout=10)
            if "Upbit AutoTrader" in result.stdout:
                print("✅ 실행 파일 테스트 통과")
                return True
        except subprocess.TimeoutExpired:
            print("⚠️ 실행 파일 응답 시간 초과 (GUI 모드일 수 있음)")
            return True  # GUI 애플리케이션의 경우 정상
        except Exception as e:
            print(f"❌ 실행 파일 테스트 실패: {e}")
            return False
            
    def create_distribution_package(self):
        """배포 패키지 생성"""
        print("📦 배포 패키지 생성 중...")
        
        # 버전 정보 가져오기
        version = self.get_version_info()
        package_name = f"UpbitAutoTrader-{version}-{self.platform}"
        package_dir = self.dist_dir / package_name
        
        # 배포 패키지 디렉토리 생성
        package_dir.mkdir(exist_ok=True)
        
        # 실행 파일 복사
        if self.platform == "windows":
            exe_file = "UpbitAutoTrader.exe"
        else:
            exe_file = "UpbitAutoTrader"
            
        shutil.copy2(self.dist_dir / exe_file, package_dir / exe_file)
        
        # 필수 파일들 복사
        essential_files = [
            "README.md",
            "requirements.txt", 
            "LICENSE"  # 라이선스 파일
        ]
        
        for file_name in essential_files:
            src_file = self.project_root / file_name
            if src_file.exists():
                shutil.copy2(src_file, package_dir / file_name)
                
        # data 폴더 구조 생성 (빈 폴더지만 구조 제공)
        data_dir = package_dir / "data"
        data_dir.mkdir(exist_ok=True)
        (data_dir / "settings").mkdir(exist_ok=True)
        
        # 설치 가이드 생성
        self.create_installation_guide(package_dir)
        
        # 압축 파일 생성
        archive_path = shutil.make_archive(
            str(self.dist_dir / package_name), 
            'zip', 
            str(package_dir)
        )
        
        print(f"✅ 배포 패키지 생성 완료: {archive_path}")
        return archive_path
        
    def get_version_info(self):
        """버전 정보 가져오기"""
        try:
            # __init__.py에서 버전 정보 추출
            init_file = self.project_root / "upbit_auto_trading" / "__init__.py"
            with open(init_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if line.startswith('__version__'):
                        return line.split('=')[1].strip().strip("'\"")
        except Exception:
            pass
        return "1.0.0"  # 기본값
        
    def create_installation_guide(self, package_dir):
        """설치 가이드 생성"""
        guide_content = f"""
# 업비트 자동매매 시스템 설치 가이드

## 📋 시스템 요구사항
- 운영체제: {self.platform.capitalize()}
- 메모리: 최소 4GB RAM (권장 8GB)
- 저장공간: 최소 1GB 여유공간
- 인터넷 연결 필수 (업비트 API 통신)

## 🚀 설치 방법
1. 압축을 해제하고 원하는 위치에 폴더를 배치하세요
2. UpbitAutoTrader{'.exe' if self.platform == 'windows' else ''} 파일을 실행하세요
3. 최초 실행 시 data/ 폴더에 데이터베이스 파일이 자동 생성됩니다

## ⚙️ 설정 방법
1. 프로그램 실행 후 '설정' 메뉴로 이동
2. 업비트 API 키와 시크릿 키를 입력하세요
3. 거래 설정을 원하는 대로 조정하세요

## 🔧 문제 해결
- 프로그램이 실행되지 않는 경우: 관리자 권한으로 실행해보세요
- API 연결 오류: 방화벽 설정을 확인하세요
- 데이터베이스 오류: data/ 폴더의 권한을 확인하세요

## 📞 지원
- GitHub: https://github.com/your-repo/upbit-autotrader
- 이메일: support@upbit-autotrader.com
"""
        
        with open(package_dir / "INSTALLATION_GUIDE.md", 'w', encoding='utf-8') as f:
            f.write(guide_content)
            
    def run_full_build(self):
        """전체 빌드 프로세스 실행"""
        print("🎯 업비트 자동매매 시스템 빌드 시작")
        print("=" * 50)
        
        steps = [
            ("환경 준비", self.prepare_build_environment),
            ("의존성 검증", self.verify_dependencies),
            ("실행 파일 생성", self.build_executable),
            ("실행 파일 테스트", self.test_executable),
            ("배포 패키지 생성", self.create_distribution_package)
        ]
        
        for step_name, step_func in steps:
            print(f"\n📋 {step_name} 중...")
            if not step_func():
                print(f"❌ {step_name} 실패")
                return False
                
        print("\n🎉 빌드 완료!")
        print("✅ 배포 준비된 패키지가 dist/ 폴더에 생성되었습니다.")
        return True

if __name__ == "__main__":
    builder = AutomatedBuilder()
    success = builder.run_full_build()
    sys.exit(0 if success else 1)
```

### 🔒 보안 및 안전성 확보

#### 1. API 키 보안 시스템 (완료)
```python
# utils/api_security.py - 이미 구현된 보안 시스템
class APIKeyManager:
    def __init__(self):
        self.encryption_key = self._generate_or_load_key()
        self.secure_storage_path = Path("data/settings/")
        
    def store_api_credentials(self, access_key: str, secret_key: str):
        """API 키 암호화 저장"""
        encrypted_data = self._encrypt_credentials(access_key, secret_key)
        secure_file = self.secure_storage_path / "api_credentials.enc"
        
        with open(secure_file, 'wb') as f:
            f.write(encrypted_data)
            
    def load_api_credentials(self) -> Tuple[str, str]:
        """암호화된 API 키 로드"""
        secure_file = self.secure_storage_path / "api_credentials.enc"
        
        if not secure_file.exists():
            raise FileNotFoundError("API 키가 설정되지 않았습니다.")
            
        with open(secure_file, 'rb') as f:
            encrypted_data = f.read()
            
        return self._decrypt_credentials(encrypted_data)
```

#### 2. 데이터베이스 백업 자동화 (90% 완료)
```python
# utils/auto_backup.py
class AutoBackupManager:
    def __init__(self):
        self.backup_dir = Path("backups")
        self.backup_interval = 24 * 3600  # 24시간
        self.max_backups = 30  # 최대 30개 백업 보관
        
    def schedule_auto_backup(self):
        """자동 백업 스케줄링"""
        import threading
        import time
        
        def backup_worker():
            while True:
                try:
                    self.create_daily_backup()
                    self.cleanup_old_backups()
                    time.sleep(self.backup_interval)
                except Exception as e:
                    logger.error(f"자동 백업 실패: {e}")
                    
        backup_thread = threading.Thread(target=backup_worker, daemon=True)
        backup_thread.start()
        
    def create_daily_backup(self):
        """일일 백업 생성"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"auto_backup_{timestamp}"
        
        backup_manager = BackupManager()
        backup_path = backup_manager.backup_sqlite(backup_name)
        
        logger.info(f"자동 백업 완료: {backup_path}")
        return backup_path
```

### 🚀 운영 모니터링 및 유지보수

#### 1. 로깅 및 모니터링 시스템
```python
# utils/operation_monitor.py
class OperationMonitor:
    def __init__(self):
        self.logger = get_logger("OperationMonitor")
        self.metrics = {
            "trades_executed": 0,
            "api_calls_made": 0,
            "errors_occurred": 0,
            "uptime_start": datetime.now()
        }
        
    def log_trade_execution(self, trade_info):
        """거래 실행 로그"""
        self.metrics["trades_executed"] += 1
        self.logger.info(f"거래 실행: {trade_info}")
        
    def log_api_call(self, endpoint, response_time):
        """API 호출 로그"""
        self.metrics["api_calls_made"] += 1
        self.logger.debug(f"API 호출: {endpoint}, 응답시간: {response_time}ms")
        
    def log_error(self, error_info):
        """오류 로그"""
        self.metrics["errors_occurred"] += 1
        self.logger.error(f"시스템 오류: {error_info}")
        
    def generate_daily_report(self):
        """일일 운영 보고서 생성"""
        uptime = datetime.now() - self.metrics["uptime_start"]
        
        report = f"""
        === 업비트 자동매매 시스템 일일 보고서 ===
        📅 날짜: {datetime.now().strftime('%Y-%m-%d')}
        ⏰ 운영시간: {uptime}
        💰 실행된 거래: {self.metrics['trades_executed']}건
        🔌 API 호출: {self.metrics['api_calls_made']}회
        ⚠️ 발생한 오류: {self.metrics['errors_occurred']}건
        """
        
        return report
```

#### 2. 자동 업데이트 시스템 (계획)
```python
# utils/auto_updater.py
class AutoUpdater:
    def __init__(self):
        self.current_version = self._get_current_version()
        self.update_server_url = "https://releases.upbit-autotrader.com"
        
    def check_for_updates(self):
        """업데이트 확인"""
        try:
            response = requests.get(f"{self.update_server_url}/latest")
            latest_version = response.json()["version"]
            
            if self._is_newer_version(latest_version, self.current_version):
                return {
                    "update_available": True,
                    "latest_version": latest_version,
                    "download_url": response.json()["download_url"],
                    "release_notes": response.json()["release_notes"]
                }
        except Exception as e:
            logger.error(f"업데이트 확인 실패: {e}")
            
        return {"update_available": False}
        
    def download_and_install_update(self, download_url):
        """업데이트 다운로드 및 설치"""
        # 1. 현재 데이터 백업
        # 2. 새 버전 다운로드
        # 3. 설치 및 마이그레이션
        # 4. 재시작
        pass
```

### 📋 배포 체크리스트 및 완성 계획

#### Phase 1: 배포 시스템 완성 (1주)
- [ ] **빌드 자동화**: 플랫폼별 실행 파일 생성 스크립트 완성
- [ ] **패키지 검증**: 생성된 패키지의 무결성 및 동작 검증
- [ ] **설치 가이드**: 사용자 친화적 설치 매뉴얼 작성
- [ ] **보안 강화**: API 키 암호화 및 안전한 저장 시스템 검증
- [ ] **초기 설정**: 첫 실행시 사용자 설정 도우미 구현

#### Phase 2: 운영 시스템 구축 (1주)
- [ ] **모니터링 대시보드**: 시스템 상태 및 성능 모니터링
- [ ] **자동 백업**: 스케줄 기반 데이터 백업 시스템
- [ ] **오류 복구**: 예외 상황 자동 복구 메커니즘
- [ ] **성능 최적화**: 메모리 사용량 및 응답 속도 최적화
- [ ] **로그 관리**: 효율적인 로그 순환 및 보관 정책

#### Phase 3: 사용자 지원 시스템 (3일)
- [ ] **문제 해결 가이드**: 자주 발생하는 문제의 해결책
- [ ] **사용자 피드백**: 버그 리포트 및 기능 요청 수집 시스템
- [ ] **업데이트 알림**: 새 버전 출시 시 사용자 알림 시스템
- [ ] **커뮤니티 지원**: 사용자 커뮤니티 및 지원 채널 구축
- [ ] **문서 최신화**: 모든 사용자 문서 검토 및 업데이트

### 🎯 배포 후 운영 계획

#### 1. 버전 관리 전략
```
버전 체계: Major.Minor.Patch (예: 1.2.3)
- Major: 대규모 기능 변경 (호환성 영향)
- Minor: 새로운 기능 추가 (하위 호환성 유지)  
- Patch: 버그 수정 및 소규모 개선

릴리스 주기:
- Patch 릴리스: 매주 (긴급 버그 수정)
- Minor 릴리스: 매월 (새 기능 추가)
- Major 릴리스: 분기별 (대규모 개선)
```

#### 2. 사용자 지원 체계
```
지원 채널:
- Level 1: FAQ 및 자동화된 문제 해결
- Level 2: 커뮤니티 기반 사용자 지원
- Level 3: 개발팀 직접 기술 지원
- Level 4: 원격 지원 및 커스터마이징

응답 시간 목표:
- 긴급 (거래 중단): 1시간 이내
- 높음 (기능 오류): 4시간 이내  
- 보통 (일반 문의): 24시간 이내
- 낮음 (기능 요청): 1주일 이내
```

이 배포 및 운영 가이드는 시스템의 안정적인 배포와 지속적인 운영을 보장하며, 사용자에게 전문적인 서비스를 제공하기 위한 종합적인 계획입니다.
