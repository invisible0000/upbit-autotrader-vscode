# 업비트 자동매매 시스템 통합 청사진 v2.2 - 03: 데이터 관리 및 UI 시스템

## 데이터 관리 시스템 (95% 완료)

### 🗄️ 3-Database 아키텍처 (최종 확정)

현재 시스템은 역할별로 분리된 3개의 SQLite 데이터베이스를 사용하며, `config/database_paths.py`에서 중앙 집중 관리됩니다.

```python
# 데이터베이스 구조 (확정된 최종 형태)
DATABASE_STRUCTURE = {
    "settings.sqlite3": {
        "purpose": "시스템 설정 + 거래변수 정의",
        "tables": 17,  # cfg_*, tv_*, sys_* 접두사
        "examples": ["tv_trading_variables", "cfg_app_settings", "sys_backup_info"]
    },
    "strategies.sqlite3": {
        "purpose": "사용자 전략 + 실행 데이터", 
        "tables": 16,  # strategies, trading_conditions, user_* 등
        "examples": ["strategies", "trading_conditions", "execution_history"]
    },
    "market_data.sqlite3": {
        "purpose": "시장 데이터 + 차트 정보",
        "tables": 20,  # candlestick_*, technical_*, real_time_* 등  
        "examples": ["candlestick_data_1d", "technical_indicators_1h", "real_time_quotes"]
    }
}
```

### 📊 테이블 매핑 시스템
```python
# TableMappings 클래스로 53개 테이블의 정확한 DB 할당
class TableMappings:
    @classmethod
    def get_db_for_table(cls, table_name: str) -> str:
        """테이블명에 따라 적절한 데이터베이스 경로 반환"""
        if table_name in cls.SETTINGS_TABLES:
            return str(DatabasePaths.SETTINGS_DB)
        elif table_name in cls.STRATEGIES_TABLES:
            return str(DatabasePaths.STRATEGIES_DB)
        elif table_name in cls.MARKET_DATA_TABLES:
            return str(DatabasePaths.MARKET_DATA_DB)

# 사용 예시
db_path = TableMappings.get_db_for_table('trading_conditions')
# → "data/strategies.sqlite3"
```

### 🔧 전역 데이터베이스 매니저 (완료)
```python
# utils/global_db_manager.py - 싱글톤 패턴으로 연결 관리
class DatabaseManager:
    def __init__(self):
        self._connections: Dict[str, sqlite3.Connection] = {}
        self._db_paths = {}
        self._table_mappings = {}
        
    def get_connection(self, table_name: str) -> sqlite3.Connection:
        """테이블명으로 적절한 DB 연결 반환"""
        db_name = self._table_mappings.get(table_name)
        if db_name not in self._connections:
            self._connections[db_name] = sqlite3.connect(self._db_paths[db_name])
        return self._connections[db_name]

# 전역 인스턴스
db_manager = DatabaseManager()
```

### 📁 데이터 백업 및 복원 시스템
```python
# data_layer/storage/backup_manager.py
class BackupManager:
    def backup_sqlite(self, backup_name: Optional[str] = None) -> str:
        """3개 DB 파일을 통합 백업"""
        
    def restore_from_backup(self, backup_path: str) -> bool:
        """백업에서 복원"""
        
    def create_migration_backup(self) -> str:
        """마이그레이션 전 안전 백업"""
```

## UI 시스템 아키텍처 (80% 완료)

### 🖥️ 데스크톱 UI 구조 (PyQt6 기반)

```
ui/desktop/
├── 📱 메인 애플리케이션
│   ├── main_window.py           # 메인 윈도우 프레임워크
│   └── navigation_bar.py        # 화면 간 네비게이션
├── 📊 화면별 컴포넌트 (screens/)
│   ├── dashboard/               # 대시보드 (90% 완료)
│   │   ├── portfolio_summary.py     # 포트폴리오 요약 위젯
│   │   ├── active_trades.py         # 활성 거래 목록
│   │   └── market_overview.py       # 시장 개요 위젯
│   ├── strategy_management/     # 전략 관리 (75% 완료)
│   │   ├── strategy_maker.py        # 전략 생성 인터페이스
│   │   └── trigger_builder/         # 트리거 빌더 시스템
│   ├── chart_view/             # 차트 뷰 (90% 완료)
│   │   ├── candlestick_chart.py     # 캔들스틱 차트
│   │   ├── indicator_overlay.py     # 기술적 지표 오버레이
│   │   └── trade_marker.py          # 거래 시점 마커
│   └── settings/               # 설정 화면 (95% 완료)
│       ├── database_settings.py     # 데이터베이스 설정
│       └── api_settings.py          # API 키 관리
└── 🧩 공통 컴포넌트 (common/)
    ├── base_widget.py          # 기본 위젯 클래스
    ├── theme_manager.py        # 다크/라이트 모드
    └── chart_components.py     # 공통 차트 요소
```

### ✅ 완성된 UI 기능들

#### 1. 대시보드 시스템 (90% 완료)
```python
# screens/dashboard/ - 실시간 모니터링 화면
class DashboardScreen:
    def __init__(self):
        self.portfolio_widget = PortfolioSummaryWidget()    # 도넛 차트로 자산 구성 표시
        self.trades_widget = ActiveTradesWidget()           # 현재 포지션 목록
        self.market_widget = MarketOverviewWidget()         # 주요 코인 시세
        
    def setup_auto_refresh(self):
        """5초 주기 자동 데이터 갱신"""
        self.timer = QTimer()
        self.timer.timeout.connect(self.refresh_all_data)
        self.timer.start(5000)  # 5초마다 갱신
```

#### 2. 차트 시각화 시스템 (90% 완료)
```python
# screens/chart_view/ - 고급 차트 분석 도구
class ChartViewScreen:
    def __init__(self):
        self.candlestick_chart = CandlestickChart()         # 기본 캔들차트
        self.indicator_overlay = IndicatorOverlay()         # SMA, EMA, 볼린저밴드
        self.trade_marker = TradeMarker()                   # 매수/매도 시점 표시
        
    def supported_indicators(self):
        return ["SMA", "EMA", "Bollinger Bands", "RSI", "MACD", "Stochastic"]
    
    def supported_timeframes(self):
        return ["1m", "5m", "15m", "1h", "4h", "1d", "1w"]
```

#### 3. 전략 관리 인터페이스 (75% 완료)
```python
# screens/strategy_management/ - 전략 생성 및 관리
class StrategyManagementScreen:
    def __init__(self):
        self.strategy_maker = StrategyMaker()               # 전략 생성 도구
        self.trigger_builder = TriggerBuilderSystem()       # 트리거 조건 설정
        self.backtest_runner = BacktestInterface()          # 백테스트 실행
        
class TriggerBuilderSystem:
    """드래그앤드롭 방식의 트리거 조건 설정"""
    def __init__(self):
        self.variable_selector = VariableSelector()         # 거래변수 선택
        self.parameter_builder = ParameterBuilder()         # 파라미터 설정
        self.condition_storage = ConditionStorage()         # 조건 저장
```

### 🚧 개발 중인 UI 기능들

#### 1. 고급 전략 빌더 (50% 완료)
```python
# 목표: 시각적 전략 설계 도구
class VisualStrategyBuilder:
    def __init__(self):
        self.component_palette = ComponentPalette()         # 컴포넌트 팔레트
        self.canvas = StrategyCanvas()                      # 드래그앤드롭 캔버스
        self.flow_validator = StrategyFlowValidator()       # 전략 흐름 검증
        
    def drag_and_drop_workflow(self):
        """컴포넌트를 드래그하여 전략 플로우 구성"""
        # 1. 트리거 선택 및 배치
        # 2. 조건 추가 및 연결  
        # 3. 액션 설정 및 연결
        # 4. 전략 검증 및 저장
```

#### 2. 실시간 모니터링 대시보드 (40% 완료)
```python
# 목표: 실거래 모니터링 전용 화면
class LiveTradingDashboard:
    def __init__(self):
        self.position_monitor = PositionMonitor()          # 포지션 실시간 추적
        self.pnl_tracker = PnLTracker()                    # 손익 실시간 계산
        self.alert_center = AlertCenter()                  # 알림 중앙 관리
        self.risk_meter = RiskMeter()                      # 리스크 지표 표시
```

#### 3. 웹 인터페이스 (계획 단계)
```python
# ui/web/ - 향후 웹 접근 지원
class WebInterface:
    """Flask/FastAPI 기반 웹 대시보드"""
    def __init__(self):
        self.api_server = APIServer()                      # RESTful API 서버
        self.websocket_handler = WebSocketHandler()        # 실시간 데이터 전송
        self.web_dashboard = WebDashboard()                # 웹 대시보드 UI
```

## 데이터 흐름 및 동기화

### 📊 실시간 데이터 파이프라인
```
1. 업비트 API → 2. 데이터 수집기 → 3. 전처리 → 4. DB 저장 → 5. UI 갱신
   ↓              ↓              ↓         ↓          ↓
WebSocket     DataCollector  Validator  DBManager  SignalBus
```

### 🔄 UI-비즈니스 로직 동기화 (어댑터 패턴)
```python
# UI 어댑터가 UI 이벤트를 비즈니스 요청으로 변환
class UIEventAdapter:
    def __init__(self):
        self.strategy_service = StrategyService()
        self.trading_service = TradingService()
        
    def handle_strategy_save(self, ui_form_data):
        """전략 저장 이벤트 처리"""
        business_request = self._convert_form_to_strategy(ui_form_data)
        validation_result = self.strategy_service.validate_strategy(business_request)
        
        if validation_result.is_valid:
            strategy_id = self.strategy_service.save_strategy(business_request)
            return {"success": True, "strategy_id": strategy_id}
        else:
            return {"success": False, "errors": validation_result.errors}
    
    def handle_trade_execution(self, trade_request):
        """거래 실행 이벤트 처리"""
        return self.trading_service.execute_trade(trade_request)
```

### 📢 이벤트 기반 통신 시스템
```python
# 컴포넌트 간 느슨한 결합을 위한 이벤트 시스템
class EventBus:
    def __init__(self):
        self.subscribers = {}
        
    def subscribe(self, event_type: str, handler: callable):
        """이벤트 구독"""
        
    def publish(self, event_type: str, data: any):
        """이벤트 발행"""
        
# 사용 예시
event_bus.subscribe("position_updated", dashboard.refresh_positions)
event_bus.subscribe("new_signal", trading_engine.process_signal)
event_bus.publish("trade_executed", trade_result)
```

## 성능 최적화 및 사용자 경험

### ⚡ 차트 렌더링 최적화
```python
# 대용량 차트 데이터 효율적 처리
class OptimizedChartRenderer:
    def __init__(self):
        self.viewport_manager = ViewportManager()          # 뷰포트 기반 렌더링
        self.data_sampler = DataSampler()                  # 데이터 샘플링
        self.cache_manager = ChartCacheManager()           # 차트 캐시 관리
        
    def render_candlesticks(self, data, viewport):
        """뷰포트에 보이는 영역만 렌더링"""
        visible_data = self.viewport_manager.get_visible_data(data, viewport)
        sampled_data = self.data_sampler.sample_for_viewport(visible_data)
        return self.cache_manager.get_or_render(sampled_data)
```

### 🎨 테마 및 사용자 설정
```python
# 다크/라이트 모드 및 사용자 커스터마이징
class ThemeManager:
    def __init__(self):
        self.current_theme = "dark"  # default
        self.custom_colors = {}
        
    def apply_theme(self, theme_name: str):
        """시스템 전체 테마 적용"""
        
    def save_user_preferences(self, preferences: dict):
        """사용자 설정 저장"""
        
# 지원 테마
AVAILABLE_THEMES = {
    "dark": {"bg": "#2b2b2b", "text": "#ffffff", "accent": "#007acc"},
    "light": {"bg": "#ffffff", "text": "#000000", "accent": "#0078d4"},
    "trading": {"bg": "#1a1a1a", "text": "#00ff00", "accent": "#ff4444"}  # 거래 특화
}
```

## 개발 우선순위 및 완성 계획

### 🎯 Phase 1: UI 시스템 완성 (3주)
- [ ] **시각적 전략 빌더**: 드래그앤드롭 방식 전략 설계 도구
- [ ] **실시간 모니터링**: 거래 중 포지션/손익 실시간 추적
- [ ] **알림 시스템**: 중요 이벤트 알림 (가격 도달, 거래 체결 등)
- [ ] **차트 고도화**: 더 많은 기술적 지표, 패턴 인식 기능
- [ ] **사용자 설정**: 개인화된 UI 레이아웃 및 테마

### 🎯 Phase 2: 데이터 시스템 고도화 (2주)  
- [ ] **데이터 분석 도구**: 거래 성과 상세 분석 및 보고서
- [ ] **백업 자동화**: 정기적 자동 백업 및 클라우드 동기화
- [ ] **데이터 압축**: 장기간 데이터 효율적 저장
- [ ] **외부 데이터**: 뉴스, SNS 감정 분석 데이터 통합
- [ ] **데이터 품질**: 데이터 무결성 검증 및 자동 복구

### 🎯 Phase 3: 통합 및 배포 준비 (1주)
- [ ] **성능 테스트**: 대용량 데이터 처리 성능 검증
- [ ] **사용자 테스트**: 실제 사용자 피드백 수집 및 개선
- [ ] **문서화**: 사용자 가이드 및 개발자 문서 완성
- [ ] **배포 패키징**: 설치형 프로그램 빌드 및 배포 준비
- [ ] **버전 관리**: 업데이트 시스템 및 롤백 기능

이 데이터 관리 및 UI 시스템은 사용자 친화적이면서도 전문적인 거래 도구를 제공하며, 확장성과 성능을 모두 고려한 설계입니다.
