# 업비트 자동매매 시스템 통합 청사진 v2.2 - 04: 테스팅 및 품질 보증

## 테스팅 전략 개요 (70% 완료)

### 🧪 다층 테스팅 아키텍처

현재 시스템은 컴포넌트 기반 모듈러 설계에 맞춰 계층별 테스팅 전략을 적용하고 있습니다.

```
테스팅 피라미드 구조:
    🔺 E2E 테스트 (10%)          ← 실제 거래 시뮬레이션
   ───────────────────
  🔺🔺 통합 테스트 (20%)         ← 컴포넌트 조합 검증  
 ───────────────────────
🔺🔺🔺 단위 테스트 (70%)         ← 개별 컴포넌트 검증
```

### ✅ 현재 구현된 테스트 시스템

#### 1. 단위 테스트 프레임워크 (pytest 기반)
```python
# tests/ 디렉토리 구조
tests/
├── unit/                        # 단위 테스트 (70% 완료)
│   ├── test_components/         # 컴포넌트별 테스트
│   │   ├── test_triggers.py     # 트리거 컴포넌트 테스트
│   │   ├── test_actions.py      # 액션 컴포넌트 테스트
│   │   └── test_conditions.py   # 조건 컴포넌트 테스트
│   ├── test_business_logic/     # 비즈니스 로직 테스트
│   │   ├── test_backtester.py   # 백테스팅 엔진 테스트
│   │   └── test_portfolio.py    # 포트폴리오 관리 테스트
│   └── test_data_layer/         # 데이터 계층 테스트
│       ├── test_collectors.py   # 데이터 수집기 테스트
│       └── test_processors.py   # 데이터 처리기 테스트
├── integration/                 # 통합 테스트 (50% 완료)
│   ├── test_strategy_execution/ # 전략 실행 통합 테스트
│   └── test_data_pipeline/      # 데이터 파이프라인 테스트
└── e2e/                        # E2E 테스트 (30% 완료)
    ├── test_trading_simulation/ # 거래 시뮬레이션 테스트
    └── test_ui_workflows/       # UI 워크플로우 테스트
```

#### 2. 컴포넌트 단위 테스트 예시
```python
# tests/unit/test_components/test_triggers.py
import pytest
from component_system.triggers.price_triggers import PriceChangeTrigger, PriceChangeConfig

class TestPriceChangeTrigger:
    def setup_method(self):
        """각 테스트 전 설정"""
        self.config = PriceChangeConfig(
            change_percent=-5.0,  # 5% 하락 시 트리거
            reference_price=50000
        )
        self.trigger = PriceChangeTrigger(self.config)
    
    def test_trigger_activation_on_price_drop(self):
        """가격 하락 시 트리거 활성화 테스트"""
        # Given: 5% 하락한 시장 데이터
        market_data = create_test_market_data(current_price=47500)  # 5% 하락
        
        # When: 트리거 조건 확인
        result = self.trigger.check_condition(market_data)
        
        # Then: 트리거가 활성화되어야 함
        assert result.triggered == True
        assert result.trigger_value == -5.0
        assert "가격이 5.0% 하락했습니다" in result.message
    
    def test_trigger_no_activation_on_insufficient_drop(self):
        """불충분한 가격 하락 시 트리거 비활성화 테스트"""
        # Given: 3% 하락한 시장 데이터 (임계값 미달)
        market_data = create_test_market_data(current_price=48500)  # 3% 하락
        
        # When: 트리거 조건 확인
        result = self.trigger.check_condition(market_data)
        
        # Then: 트리거가 활성화되지 않아야 함
        assert result.triggered == False
    
    @pytest.mark.parametrize("price,expected", [
        (47500, True),   # 5% 하락 - 트리거
        (47000, True),   # 6% 하락 - 트리거  
        (48500, False),  # 3% 하락 - 트리거 안됨
        (52000, False),  # 4% 상승 - 트리거 안됨
    ])
    def test_trigger_various_price_scenarios(self, price, expected):
        """다양한 가격 시나리오 테스트"""
        market_data = create_test_market_data(current_price=price)
        result = self.trigger.check_condition(market_data)
        assert result.triggered == expected
```

#### 3. 백테스팅 시스템 테스트
```python
# tests/unit/test_business_logic/test_backtester.py
class TestBacktestRunner:
    def setup_method(self):
        self.runner = BacktestRunner()
        self.test_strategy = create_test_pyramiding_strategy()
        self.test_data = load_test_market_data("KRW-BTC", "2024-01-01", "2024-03-31")
    
    def test_backtest_execution(self):
        """백테스트 실행 테스트"""
        # Given: 테스트 전략과 데이터
        
        # When: 백테스트 실행
        result = self.runner.run_backtest(
            strategy=self.test_strategy,
            market_data=self.test_data,
            initial_capital=1000000
        )
        
        # Then: 결과 검증
        assert result.total_trades > 0
        assert result.final_balance >= 0
        assert result.max_drawdown <= 1.0  # 최대 손실 100% 이하
        assert len(result.trade_history) == result.total_trades
    
    def test_backtest_risk_management(self):
        """백테스트 리스크 관리 테스트"""
        # Given: 리스크 제한이 있는 전략
        risky_strategy = create_high_risk_strategy()
        
        # When: 백테스트 실행
        result = self.runner.run_backtest(
            strategy=risky_strategy,
            market_data=self.test_data,
            initial_capital=1000000,
            max_position_size=0.1  # 포지션 크기 10% 제한
        )
        
        # Then: 리스크 제한 준수 확인
        for trade in result.trade_history:
            assert trade.position_size <= 0.1
```

### 🔄 통합 테스트 전략

#### 1. 전략 실행 통합 테스트
```python
# tests/integration/test_strategy_execution/test_component_integration.py
class TestStrategyComponentIntegration:
    def test_pyramiding_strategy_full_flow(self):
        """피라미딩 전략 전체 플로우 통합 테스트"""
        # Given: 완전한 피라미딩 전략 구성
        strategy = PyramidingStrategy(
            trigger=PriceChangeTrigger(change_percent=-5.0),
            action=BuyAction(amount_type="fixed", amount=10000),
            conditions=[
                AddBuyCountCondition(max_count=3),
                BalanceCondition(min_balance=50000)
            ]
        )
        
        # Mock 실행 환경 설정
        execution_context = create_mock_execution_context(
            current_balance=100000,
            current_price=50000,
            position_count=0
        )
        
        # When: 전략 실행
        result = strategy.execute(execution_context)
        
        # Then: 통합 결과 검증
        assert result.action_executed == True
        assert result.conditions_passed == True
        assert result.new_balance == 90000  # 10000원 매수 후
```

#### 2. 데이터 파이프라인 통합 테스트
```python
# tests/integration/test_data_pipeline/test_data_flow.py
class TestDataPipelineIntegration:
    def test_market_data_to_strategy_signal_flow(self):
        """시장 데이터부터 전략 신호까지 전체 흐름 테스트"""
        # Given: 실제 API 데이터 수집
        collector = UpbitDataCollector()
        processor = TechnicalIndicator()
        signal_generator = StrategySignalGenerator()
        
        # When: 데이터 파이프라인 실행
        raw_data = collector.collect_candle_data("KRW-BTC", "1h", limit=100)
        processed_data = processor.add_technical_indicators(raw_data)
        signals = signal_generator.generate_signals(processed_data)
        
        # Then: 각 단계 결과 검증
        assert len(raw_data) == 100
        assert "sma_20" in processed_data.columns
        assert "rsi" in processed_data.columns
        assert len(signals) > 0
        for signal in signals:
            assert signal.confidence >= 0.0
            assert signal.confidence <= 1.0
```

### 🎭 모킹 및 테스트 데이터 관리

#### 1. 업비트 API 모킹
```python
# tests/fixtures/mock_upbit_api.py
class MockUpbitAPI:
    """업비트 API 모킹 클래스"""
    
    def __init__(self):
        self.mock_responses = {}
        self.call_count = {}
    
    def get_candles(self, market, timeframe, count=200):
        """캔들 데이터 모킹"""
        self.call_count["get_candles"] = self.call_count.get("get_candles", 0) + 1
        return self._generate_mock_candle_data(market, timeframe, count)
    
    def get_orderbook(self, market):
        """호가 데이터 모킹"""
        return self._generate_mock_orderbook_data(market)
    
    def place_order(self, market, side, volume, price, ord_type):
        """주문 실행 모킹"""
        return self._generate_mock_order_response(market, side, volume, price)

@pytest.fixture
def mock_upbit_api():
    """pytest fixture로 모킹 API 제공"""
    return MockUpbitAPI()
```

#### 2. 테스트 데이터 생성기
```python
# tests/fixtures/test_data_generator.py
class TestDataGenerator:
    """테스트용 시장 데이터 생성"""
    
    @staticmethod
    def generate_trending_data(
        symbol: str,
        start_price: float,
        trend: str,  # "up", "down", "sideways"
        volatility: float,
        periods: int
    ) -> pd.DataFrame:
        """추세가 있는 테스트 데이터 생성"""
        
    @staticmethod
    def generate_crash_scenario(
        symbol: str,
        crash_day: int,
        crash_magnitude: float
    ) -> pd.DataFrame:
        """급락 시나리오 테스트 데이터"""
        
    @staticmethod
    def generate_bull_market_data(
        symbol: str,
        duration_days: int,
        total_gain: float
    ) -> pd.DataFrame:
        """상승장 시나리오 테스트 데이터"""
```

### 🚀 성능 및 부하 테스트

#### 1. 백테스팅 성능 테스트
```python
# tests/performance/test_backtest_performance.py
class TestBacktestPerformance:
    def test_large_dataset_backtest_performance(self):
        """대용량 데이터셋 백테스트 성능 테스트"""
        # Given: 1년치 1분봉 데이터 (525,600개 데이터 포인트)
        large_dataset = generate_large_test_dataset(periods=525600)
        strategy = create_test_strategy()
        
        # When: 백테스트 실행 시간 측정
        start_time = time.time()
        result = BacktestRunner().run_backtest(strategy, large_dataset)
        execution_time = time.time() - start_time
        
        # Then: 성능 기준 확인
        assert execution_time < 30.0  # 30초 이내 완료
        assert result.memory_usage < 500 * 1024 * 1024  # 500MB 이내
    
    def test_concurrent_strategy_execution(self):
        """동시 다중 전략 실행 성능 테스트"""
        strategies = [create_test_strategy() for _ in range(10)]
        
        start_time = time.time()
        results = execute_strategies_concurrently(strategies)
        execution_time = time.time() - start_time
        
        assert len(results) == 10
        assert execution_time < 60.0  # 1분 이내 완료
```

#### 2. 실시간 데이터 처리 부하 테스트
```python
# tests/performance/test_realtime_performance.py  
class TestRealtimePerformance:
    def test_high_frequency_data_processing(self):
        """고빈도 데이터 처리 성능 테스트"""
        # Given: 1초마다 100개 코인의 데이터 업데이트 시뮬레이션
        data_stream = simulate_high_frequency_stream(
            symbols=100,
            frequency="1s",
            duration_minutes=10
        )
        
        processor = RealTimeDataProcessor()
        processed_count = 0
        
        # When: 실시간 데이터 처리
        for data_point in data_stream:
            processor.process(data_point)
            processed_count += 1
        
        # Then: 처리 성능 확인
        assert processed_count == 60000  # 10분 * 100코인 * 60초
        assert processor.average_latency < 0.01  # 10ms 이내 평균 지연시간
```

### 🔍 품질 보증 및 코드 검증

#### 1. 코드 커버리지 목표
```python
# pytest-cov 설정으로 커버리지 측정
# 목표 커버리지: 85% 이상

COVERAGE_TARGETS = {
    "component_system/": 90,     # 컴포넌트 시스템 90% 이상
    "business_logic/": 85,       # 비즈니스 로직 85% 이상  
    "data_layer/": 80,          # 데이터 계층 80% 이상
    "ui/": 70,                  # UI 계층 70% 이상 (수동 테스트 병행)
}
```

#### 2. 정적 코드 분석
```python
# mypy, flake8, pylint 통합 품질 검사
QUALITY_CHECKS = {
    "type_hints": "mypy로 타입 힌트 100% 적용",
    "code_style": "flake8으로 PEP 8 준수",
    "complexity": "pylint으로 복잡도 관리 (10 이하)",
    "security": "bandit으로 보안 취약점 검사"
}
```

### 📋 테스팅 체크리스트 및 완성 계획

#### Phase 1: 핵심 테스트 완성 (2주)
- [ ] **컴포넌트 단위 테스트**: 모든 트리거/액션/조건 컴포넌트 100% 커버리지
- [ ] **백테스팅 테스트**: 다양한 시장 시나리오별 검증 테스트
- [ ] **데이터 무결성 테스트**: DB 연산 및 데이터 품질 검증
- [ ] **API 모킹 완성**: 업비트 API 모든 엔드포인트 모킹
- [ ] **성능 벤치마크**: 기준 성능 지표 설정 및 측정

#### Phase 2: 통합 테스트 확장 (2주)
- [ ] **전략 실행 통합**: 복잡한 전략 조합 시나리오 테스트
- [ ] **실시간 처리 테스트**: 고빈도 데이터 스트림 처리 검증
- [ ] **오류 복구 테스트**: 네트워크 오류, DB 연결 실패 등 예외 상황
- [ ] **메모리 누수 테스트**: 장시간 실행 시 메모리 사용량 모니터링
- [ ] **동시성 테스트**: 다중 스레드/프로세스 환경 안정성

#### Phase 3: E2E 및 사용자 테스트 (1주)
- [ ] **UI 자동화 테스트**: Selenium 기반 사용자 워크플로우 테스트
- [ ] **실거래 시뮬레이션**: 모의 거래 환경에서 전체 시스템 검증
- [ ] **사용자 수용 테스트**: 실제 사용자 시나리오 기반 테스트
- [ ] **배포 테스트**: 설치형 패키지 배포 및 환경별 호환성 테스트
- [ ] **문서화 테스트**: 사용자 가이드 및 API 문서 정확성 검증

이 테스팅 전략은 시스템의 안정성과 신뢰성을 보장하며, 실제 거래 환경에서의 안전한 운영을 위한 품질 기준을 설정합니다.
