### **기술 사양서: 외부 제어형 상태 변수(Externally-Controlled Stateful Variable) 시스템**

**문서 버전**: 1.0
**작성일**: 2025-08-14
**작성자**: Senior Programmer (Finance & Trading Systems)

-----

#### **1.0 개요 (Overview)**

본 문서는 기존의 하드코딩된 관리 전략(Management Strategies)을 대체하고, 사용자가 전략 빌더(Trigger Builder) 내에서 동적으로 조립할 수 있는 재사용 가능한 컴포넌트 시스템의 기술 사양을 정의합니다.

핵심 목표는 불타기(Pyramiding), 물타기(Cost-Averaging), 트레일링 스탑(Trailing Stop) 등 상태(state)를 기억해야 하는 복잡한 로직을 **'외부 제어형 상태 변수'** 라는 단일 아키텍처 패턴으로 통합하여, 시스템의 **유연성, 일관성, 확장성**을 확보하는 데 있습니다.

-----

#### **2.0 아키텍처 패턴 정의**

본 시스템은 `ARCHITECTURE_GUIDE.md`에 명시된 DDD(도메인 주도 설계) 원칙을 준수하며, 다음 두 가지 핵심 패턴을 기반으로 합니다.

  * **2.1 수동적 상태 변수 (Passive Stateful Variable)**

      * 상태를 가지는 모든 변수(예: 트레일링 스탑)는 자신의 상태를 관리하고 계산하는 로직에만 집중합니다.
      * 상태를 초기화하는 정책이나 시점을 스스로 결정하지 않으며, 외부의 명령에만 수동적으로 반응하는 `initialize(context)` 메서드를 외부에 노출합니다. 이는 도메인 객체의 순수성을 유지하기 위함입니다.

  * **2.2 시스템 주도 초기화 (System-Driven Reset)**

      * 상태 변수의 `initialize` 메서드를 호출하는 시점과 정책은 상위 계층인 **Application Layer**의 `StrategyExecutionService`가 전적으로 제어합니다.
      * 이를 통해 변수 자체는 단순하게 유지하고, 복잡한 실행 흐름 제어는 서비스 계층에 위임하여 역할과 책임을 명확히 분리합니다.

-----

#### **3.0 컴포넌트 기술 사양**

본 시스템은 두 종류의 상태 변수를 정의하며, 이들은 **통합된 파라미터 구조**를 공유하여 일관성을 유지합니다.

  * **3.1 비교 조건 변수 (ComparisonConditionVariable)**

      * **목적**: 불타기/물타기 전략에서 사용될 동적 \*\*'목표 가격(Target Price)'\*\*을 생성합니다.
      * **반환값**: 계산된 목표 가격 (`price_comparable`)
      * **파라미터 스키마 (`variable_parameters`)**:
        | `parameter_name` | `display_name_ko` | `parameter_type` | `help_text` |
        | :--- | :--- | :--- | :--- |
        | `base_variable` | 기준값 | `enum` | 목표가 계산의 기준 (예: `진입가`, `평단가`) |
        | `calculation_method` | 계산 방식 | `enum` | 목표가 계산 방식을 선택 (섹션 4.1 참조) |
        | `value` | 설정값 | `float` | 계산에 사용될 고정값 또는 비율(%) |
      * **사용 예시**: `현재가 >= ComparisonConditionVariable(base: 평단가, method: 평단가 대비 % 포인트, value: 5)` 조건 생성

  * **3.2 트레일링 스탑 변수 (TrailingStopVariable)**

      * **목적**: 포지션의 수익을 보존하기 위해 고점/저점을 추적하는 동적 \*\*'손절 라인(Stop Price)'\*\*을 생성합니다.
      * **반환값**: 계산된 손절 라인 가격 (`price_comparable`)
      * **파라미터 스키마 (`variable_parameters`)**:
        | `parameter_name` | `display_name_ko` | `parameter_type` | `help_text` |
        | :--- | :--- | :--- | :--- |
        | `tracking_target` | 추적 대상 지표 | `enum` | 고점/저점을 기록할 대상 (예: `종가`, `고가`) |
        | `trail_direction` | 추적 방향 | `enum` | `'상향'` (Long Position) 또는 `'하향'` (Short Position) |
        | `calculation_method` | 추적 거리 계산 방식 | `enum` | 손절 거리를 계산하는 방식을 선택 (섹션 4.1 참조) |
        | `value` | 설정값 | `float` | 계산에 사용될 고정값 또는 비율(%) |
      * **사용 예시**: `현재가 <= TrailingStopVariable(target: 고가, direction: 상향, method: 추적값 대비 비율, value: 3)` 조건 생성

-----

#### **4.0 공유 메커니즘 상세**

  * **4.1 통합 계산 방식 (`calculation_method`)**
    두 변수는 아래의 동일한 계산 방식 옵션을 공유하여 코드 재사용성을 높이고 사용자 혼란을 방지합니다.

    | `calculation_method` 옵션 | 설명 |
    | :--- | :--- |
    | `StaticValueOffset` | **정적 값 차이**: `설정값` 만큼의 고정된 가격 차이를 적용합니다. |
    | `PercentageOfTrackedValue` | **추적값 대비 비율**: `최고점/최저점` 대비 `설정값` % 만큼의 차이를 적용합니다. |
    | `PercentageOfEntryPrice` | **진입가 대비 퍼센트 포인트**: 포지션의 최초 `진입가` 대비 `설정값` % 만큼의 차이를 적용합니다. |
    | `PercentageOfAveragePrice` | **평단가 대비 퍼센트 포인트**: 포지션의 현재 `평단가` 대비 `설정값` % 만큼의 차이를 적용합니다. |

  * **4.2 상태 초기화 트리거 (State Initialization Triggers)**
    `StrategyExecutionService`는 다음 두 가지 조건에 따라 상태 변수의 `initialize()` 메서드를 호출해야 합니다.

    1.  **포지션 생애주기 기반 초기화 (기본 동작)**

          * **조건**: 시스템 설정이 '연속 거래' 모드일 때, 하나의 포지션이 완전히 청산(Closed)된 후 다음 거래를 위한 신규 포지션이 생성되기 직전.
          * **목적**: 모든 거래 사이클의 독립성을 보장. 이는 시스템 레벨에서 강제되어야 하는 필수 동작입니다.

    2.  **전략 설정 기반 초기화 (선택적 동작)**

          * **조건**: `user_strategies` 테이블의 `reset_variables_on_exit` 컬럼 값이 `true`일 때, 해당 전략에서 `EXIT` 타입의 시그널이 발생한 직후.
          * **목적**: 한 포지션 내에서 부분 익절 후, 나머지 관리 로직(예: 트레일링 스탑)의 기준점을 리셋하는 등 고급 전략 구현을 지원합니다.

-----

#### **5.0 구현 가이드라인**

  * **Domain Layer**:

      * `StatefulVariable` 추상 클래스 또는 인터페이스를 정의하고 `initialize(context)` 메서드를 포함시킵니다.
      * `ComparisonConditionVariable` 및 `TrailingStopVariable` 클래스는 위 인터페이스를 구현하며, 순수한 계산 로직을 담당합니다.

  * **Application Layer**:

      * `StrategyExecutionService`는 `StrategyRepository`, `PositionRepository`와 상호작용하며, 상기된 **4.2절**의 초기화 트리거 로직을 책임집니다.
      * **의사 코드**:
        ```python
        class StrategyExecutionService:
            def process_trade_cycle(self, strategy_id):
                strategy = self.strategy_repo.get_by_id(strategy_id)
                position = self.position_repo.get_by_strategy(strategy_id)

                # EXIT 시그널 확인
                exit_signal_fired = strategy.evaluate_for_exit_signal(data)

                # 전략 설정 기반 초기화
                if strategy.reset_variables_on_exit and exit_signal_fired:
                    for var in strategy.get_all_stateful_variables():
                        var.initialize(position)

                    self.close_position(position) # 포지션 청산

                # ... 기타 로직 ...

                # 포지션 생애주기 기반 초기화
                if position.is_closed() and strategy.is_continuous():
                    # 새 포지션 생성 전 모든 변수 초기화
                    for var in strategy.get_all_stateful_variables():
                        # 새 포지션 컨텍스트가 없으므로 None 또는 기본값으로 초기화
                        var.initialize(context=None)
        ```

상기된 사양에 따라 구현 시, 시스템은 견고하고 확장 가능한 관리 전략 프레임워크를 갖추게 될 것입니다.
