### ## 최종 요약: 지능형 트레이딩 시스템을 위한 딥 리서치 가이드

우리가 설계한 시스템은 단순히 코드를 실행하는 자동매매 프로그램을 넘어, **스스로의 상태를 인지하고 복잡한 규칙들의 상호작용을 지능적으로 조율하는 차세대 트레이딩 프레임워크**입니다. 이 시스템의 성공적인 구현을 위해 다음 세 가지 핵심 원칙을 이해하고, 세 가지 기술적 과제를 해결하며, 세 가지 미래 방향을 연구해야 합니다.

---

### **1. 핵심 설계 3원칙 (The 3 Core Design Principles) 🏛️**

1.  **추상화 (Abstraction): "모든 것은 부품이다"**
    * 모든 매매 로직은 **`트리거`, `액션`, `조건`** 이라는 원자적 컴포넌트(Atomic Components)로 분해됩니다. 이 설계는 "RSI가 30 아래일 때 매수한다"는 고정된 전략을 만드는 것이 아니라, 'RSI가 특정 값 아래일 때'라는 `트리거`와 '시장가 매수'라는 `액션`을 제공하여 사용자가 이를 자유롭게 조립하도록 합니다. 이 원칙은 시스템의 무한한 확장성을 보장하는 가장 근본적인 토대입니다.

2.  **조율 (Orchestration): "엔진은 지휘자다"**
    * **`ExecutionEngine`**은 단순한 규칙 실행기가 아니라, 포지션의 **`상태(State)`**를 파악하고, 여러 규칙의 **`우선순위(Priority)`**를 판단하며, 규칙 간의 통신을 위한 **`실행 컨텍스트(Execution Context)`**를 관리하는 지능형 지휘자입니다. 어떤 규칙을 언제 활성화하고, 신호 충돌 시 무엇을 선택할지 결정하는 모든 의사결정은 이 중앙화된 지휘자를 통해 이루어집니다.

3.  **시각화 (Visualization): "코딩이 아닌 조립이다"**
    * **`전략 메이커(Strategy Maker)` UI**는 단순한 인터페이스가 아니라 시스템의 핵심 설계 철학 그 자체입니다. 사용자는 코드를 작성하는 대신, 컴포넌트라는 레고 블록을 드래그 & 드롭하여 자신만의 논리를 시각적으로 구축합니다. 이는 복잡한 매매 로직의 진입 장벽을 낮추고, 사용자의 아이디어를 즉시 전략으로 전환시키는 핵심적인 사용자 경험입니다.

---

### **2. 반드시 해결해야 할 3가지 기술적 과제 ⚙️**

1.  **상태를 기억하는 실행 컨텍스트 (Stateful Execution Context)**
    * "급등 시 불타기 정지" 규칙에서 보았듯이, 한 규칙의 실행이 다른 규칙의 행동에 영향을 미치려면 모든 규칙이 공유하는 메모리, 즉 **`실행 컨텍스트`**가 필수적입니다. 이 컨텍스트의 상태(`is_pyramiding_paused` 등)를 어떻게 안정적으로 관리하고, 하나의 매매 사이클이 끝나면 어떻게 초기화할 것인지에 대한 명확한 생명주기 관리가 기술적인 핵심 과제입니다.

2.  **우선순위 기반 충돌 해결 (Priority-based Conflict Resolution)**
    * "급락 감지" 규칙처럼 여러 규칙이 한 틱에 동시 발동될 때, 시스템은 **`[후보 수집 → 우선순위 정렬 → 최우선 규칙 실행]`**의 명확한 프로세스를 따라야 합니다. 모든 규칙에 대해 모호함 없는 우선순위 정책을 어떻게 수립하고, 어떤 규칙에 어떤 우선순위를 부여할지에 대한 체계적인 설계가 필요합니다.

3.  **고성능 시계열 데이터 처리 (High-Performance Time-Series Handling)**
    * "1분 내 5% 급등"과 같은 시간 기반 트리거를 위해, 시스템은 최근 N개의 틱 데이터를 메모리 내 **슬라이딩 윈도우(Sliding Window / deque)**에 유지해야 합니다. 매 틱마다 전체 데이터베이스를 조회하는 것이 아니라, 이 메모리 버퍼 내에서 효율적으로 과거 데이터를 조회하고 계산하는 고성용 데이터 처리 방식의 구현이 필수적입니다.

---
### **완성된 전략을 구성하는 7개 규칙 요약표**

| 번호 | 규칙 이름 (역할) | 간단한 설명 |
| :--- | :--- | :--- |
| 1 | **RSI 과매도 진입** (ENTRY) | RSI 지표가 지정된 값(e.g., 20) 이하로 떨어지면 최초 진입합니다. |
| 2 | **수익 시 불타기** (SCALE\_IN) | 수익률이 지정된 값(e.g., 5%)에 도달할 때마다 정해진 횟수만큼 추가 매수합니다. |
| 3 | **계획된 익절** (EXIT) | '불타기'가 계획된 횟수를 모두 채운 후, 다음 수익 신호에 전량 매도하여 이익을 실현합니다. |
| 4 | **트레일링 스탑** (EXIT) | 지정된 수익률 도달 후, 고점 대비 일정 비율 하락 시 전량 매도하여 이익을 보호합니다. |
| 5 | **하락 시 물타기** (SCALE\_IN) | 평단가 대비 지정된 비율(e.g., -5%)만큼 하락 시, 정해진 횟수만큼 추가 매수합니다. |
| 6 | **급락 감지** (EXIT / RISK\_MGMT) | 단일 감시 주기 내에 가격이 폭락하면, 다른 모든 규칙을 무시하고 즉시 전량 매도합니다. |
| 7 | **급등 홀드** (MANAGEMENT) | 단기간에 가격이 급등하면, '불타기' 규칙을 일시 정지시켜 추격 매수의 위험을 막습니다. |

---

# 문서 #2: 규칙 #1 구현 - RSI 과매도 진입 (ENTRY)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙의 목적은 **시장이 과매도 상태에 진입했을 때 새로운 포지션을 시작**하는 것입니다. 이는 대표적인 역추세 진입 전략의 컴포넌트 구현입니다.

* **역할 (Role):** `ENTRY`
* **활성화 상태 (Activation State):** `READY` (포지션이 없는 상태에서만 작동)
* **핵심 컴포넌트 (Core Components):** `RSITrigger`, `MarketBuyAction`

---

### ## 2. 컴포넌트 구성 (Component Configuration)

이 규칙은 하나의 `트리거`와 하나의 `액션` 컴포넌트로 구성됩니다. 아래는 데이터베이스에 저장되거나 실행 엔진으로 전달될 때의 JSON 데이터 구조 예시입니다.

```json
{
  "rule_id": "entry_rsi_oversold",
  "description": "RSI가 20 이하로 하락 시, 자산의 10%를 시장가 매수하여 진입",
  "activation_state": "READY",
  "trigger": {
    "component": "RSITrigger",
    "config": {
      "period": 14,
      "threshold": 20,
      "direction": "below"
    }
  },
  "action": {
    "component": "MarketBuyAction",
    "config": {
      "amount_percent": 10,
      "position_tag": "AUTO"
    }
  }
}
````

#### **2.1. 트리거 설정 (`RSITrigger`)**

  * `component: "RSITrigger"`: RSI 지표의 특정 조건을 감시하는 컴포넌트를 사용합니다.
  * `period: 14`: RSI 값을 계산할 때 사용할 기간을 14로 설정합니다.
  * `threshold: 20`: 과매도 상태를 판단할 임계값을 20으로 설정합니다.
  * `direction: "below"`: RSI 값이 임계값(20) **아래로** 내려갔을 때 트리거가 발동하도록 설정합니다.

#### **2.2. 액션 설정 (`MarketBuyAction`)**

  * `component: "MarketBuyAction"`: 시장가 매수를 실행하는 컴포넌트를 사용합니다.
  * `amount_percent: 10`: 전체 가용 자산의 10%에 해당하는 금액만큼 매수합니다.
  * `position_tag: "AUTO"`: 이 액션으로 생성된 포지션에는 'AUTO' 태그를 부여하여, 이후 자동 전략만이 관리할 수 있도록 합니다.

-----

### \#\# 3. 실행 엔진에서의 동작 방식

1.  **감시 시작**: `ExecutionEngine`은 현재 포지션의 상태가 `READY`인 것을 확인하고, 이 규칙을 활성화하여 시장을 감시하기 시작합니다.
2.  **트리거 평가**: 새로운 시장 데이터 틱이 들어올 때마다, 엔진은 `RSITrigger`의 `evaluate()` 메서드를 호출합니다.
3.  **조건 충족**: `evaluate()` 메서드는 현재 14기간 RSI 값이 20 미만인지 확인합니다. 만약 RSI가 19.5로 계산되면, 메서드는 `True`를 반환합니다.
4.  **액션 실행**: 트리거가 `True`를 반환하면, 엔진은 이 규칙에 연결된 `MarketBuyAction`의 `execute()` 메서드를 호출합니다.
5.  **상태 전환**: `execute()` 메서드는 자산의 10%만큼 시장가 매수 주문을 실행합니다. 주문이 성공적으로 체결되면, 포지션 객체의 상태를 `READY`에서 \*\*`ACTIVE`\*\*로 변경합니다.
6.  **규칙 비활성화**: 다음 데이터 틱부터 포지션의 상태는 `ACTIVE`이므로, `activation_state`가 `READY`인 이 규칙은 더 이상 활성화되지 않습니다.

---

# 문서 #3: 규칙 #2 구현 - 수익 시 불타기 (SCALE_IN)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙의 목적은 **포지션이 수익 중일 때, 정해진 조건에 따라 추가 매수(불타기/Pyramiding)를 실행**하여 상승 추세에서 수익을 극대화하는 것입니다.

* **역할 (Role):** `SCALE_IN`
* **활성화 상태 (Activation State):** `ACTIVE` (포지션 보유 중에만 작동)
* **핵심 컴포넌트 (Core Components):** `ProfitLossTrigger`, `ExecutionCountCondition`, `AdditionalBuy`

---

### ## 2. 컴포넌트 구성 (Component Configuration)

이 규칙은 `트리거` 1개, `추가 조건` 1개, `액션` 1개로 구성되어 복합적인 행동을 정의합니다.

```json
{
  "rule_id": "scale_in_on_profit",
  "description": "수익률 5% 도달 시, 3회까지 10만원 추가 매수",
  "activation_state": "ACTIVE",
  "trigger": {
    "component": "ProfitLossTrigger",
    "config": {
      "profit_percent": 5,
      "direction": "above"
    }
  },
  "conditions": [
    {
      "component": "ExecutionCountCondition",
      "config": {
        "target_rule_id": "scale_in_on_profit",
        "less_than": 3
      }
    }
  ],
  "action": {
    "component": "AdditionalBuy",
    "config": {
      "amount": 100000
    }
  }
}
````

#### **2.1. 트리거 설정 (`ProfitLossTrigger`)**

  * `component: "ProfitLossTrigger"`: 현재 포지션의 수익 또는 손실률을 감시하는 컴포넌트를 사용합니다.
  * `profit_percent: 5`: 이 규칙의 발동 기준이 되는 수익률을 5%로 설정합니다. 평단가 대비 현재가의 수익률을 기준으로 계산됩니다.
  * `direction: "above"`: 수익률이 기준값(5%) **이상**이 되었을 때 트리거가 발동하도록 설정합니다.

#### **2.2. 추가 조건 설정 (`ExecutionCountCondition`)**

  * `component: "ExecutionCountCondition"`: 특정 규칙의 실행 횟수를 검사하는 조건 컴포넌트입니다.
  * `target_rule_id: "scale_in_on_profit"`: 자기 자신의 `rule_id`를 참조하여, 이 규칙이 몇 번 실행되었는지 추적합니다.
  * `less_than: 3`: 실행 횟수가 3회 **미만**일 경우에만 조건을 통과시킵니다. 4번째 신호부터는 이 조건이 `False`를 반환하여 액션 실행을 막습니다.

#### **2.3. 액션 설정 (`AdditionalBuy`)**

  * `component: "AdditionalBuy"`: 기존에 보유한 포지션에 수량을 추가하는 액션 컴포넌트입니다.
  * `amount: 100000`: 조건을 모두 만족했을 때, 10만 원만큼의 수량을 추가로 매수합니다.

-----

### \#\# 3. 실행 엔진에서의 동작 방식

1.  **감시 시작**: 규칙 \#1(진입)에 의해 포지션이 생성되고 상태가 `ACTIVE`가 되면, `ExecutionEngine`은 이 규칙을 활성화합니다.
2.  **트리거 평가**: 엔진은 매 틱마다 포지션의 현재 수익률을 계산하여 `ProfitLossTrigger`의 조건(수익률 \>= 5%)을 검사합니다.
3.  **추가 조건 검사**: 트리거 조건이 충족되면, 엔진은 `ExecutionCountCondition`을 검사합니다. 현재 이 규칙의 실행 횟수가 3회 미만인지 확인합니다.
4.  **액션 실행**: 트리거와 추가 조건이 모두 `True`이면, 엔진은 `AdditionalBuy` 액션을 실행합니다.
5.  **상태 업데이트**: 추가 매수 체결 후, 포지션의 평단가와 보유 수량이 업데이트됩니다. 동시에 이 규칙의 내부 실행 횟수 카운터가 1 증가합니다.
6.  **반복 또는 중지**: 포지션이 계속 유지되는 한, 이 과정은 최대 3번까지 반복될 수 있습니다. 실행 횟수가 3에 도달하면, 더 이상 이 규칙은 발동하지 않습니다.

---

# 문서 #4: 규칙 #3 구현 - 계획된 익절 (EXIT)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙의 목적은 **'수익 시 불타기(규칙 #2)'가 계획된 횟수를 모두 성공적으로 마쳤을 때, 다음 수익 신호에 포지션 전체를 청산하여 이익을 실현**하는 것입니다. 이는 성공적인 트레이딩 사이클을 마무리하는 역할을 합니다.

* **역할 (Role):** `EXIT`
* **활성화 상태 (Activation State):** `ACTIVE` (포지션 보유 중에만 작동)
* **핵심 컴포넌트 (Core Components):** `ProfitLossTrigger`, `ExecutionCountCondition`, `FullPositionSell`

---

### ## 2. 컴포넌트 구성 (Component Configuration)

이 규칙은 '수익 시 불타기' 규칙과 동일한 `트리거`를 공유하지만, `추가 조건`과 `액션`이 다릅니다. 이 차이점이 두 규칙의 역할을 명확히 구분합니다.

```json
{
  "rule_id": "exit_after_pyramiding_complete",
  "description": "3회 추가 매수 완료 후, 다음 5% 수익 신호에 전량 익절",
  "activation_state": "ACTIVE",
  "trigger": {
    "component": "ProfitLossTrigger",
    "config": {
      "profit_percent": 5,
      "direction": "above"
    }
  },
  "conditions": [
    {
      "component": "ExecutionCountCondition",
      "config": {
        "target_rule_id": "scale_in_on_profit",
        "equal_to": 3
      }
    }
  ],
  "action": {
    "component": "FullPositionSell",
    "config": {}
  }
}
````

#### **2.1. 트리거 설정 (`ProfitLossTrigger`)**

  * `component: "ProfitLossTrigger"`: 규칙 \#2와 동일한 수익률 감시 컴포넌트를 사용하여, 같은 신호 주기에 반응하도록 합니다.
  * `profit_percent: 5`: 동일하게 5% 수익률을 기준으로 설정합니다.

#### **2.2. 추가 조건 설정 (`ExecutionCountCondition`)**

  * `component: "ExecutionCountCondition"`: 규칙의 실행 횟수를 검사하는 컴포넌트입니다.
  * `target_rule_id: "scale_in_on_profit"`: **규칙 \#2의 ID**를 참조하여, 불타기 규칙이 몇 번 실행되었는지를 확인합니다.
  * `equal_to: 3`: 불타기 규칙의 실행 횟수가 정확히 3회일 경우에만 조건을 통과시킵니다. 이것이 이 규칙을 활성화하는 핵심 키입니다.

#### **2.3. 액션 설정 (`FullPositionSell`)**

  * `component: "FullPositionSell"`: 포지션 전체를 시장가로 청산하는 액션 컴포넌트입니다.
  * `config: {}`: 전량 매도이므로 별도의 파라미터가 필요 없습니다.

-----

### \#\# 3. 실행 엔진에서의 동작 방식

1.  **전제 조건**: 포지션 상태는 `ACTIVE`이며, '규칙 \#2(불타기)'가 이미 3번 실행되어 내부 실행 카운트가 `3`이 된 상태입니다.
2.  **감시 시작**: `ExecutionEngine`은 규칙 \#2와 규칙 \#3을 포함한 모든 `ACTIVE` 상태의 규칙들을 계속 감시합니다.
3.  **트리거 평가**: 가격이 다시 상승하여 다음 5% 수익 구간에 도달하면, 두 규칙의 `ProfitLossTrigger`가 동시에 `True` 신호를 보냅니다.
4.  **조건 분기**:
      * **규칙 \#2 (불타기)**: `ExecutionCountCondition`을 검사합니다. `실행 횟수 < 3` 조건이 `3 < 3` 이므로 \*\*거짓(False)\*\*이 되어 규칙이 중단됩니다.
      * **규칙 \#3 (계획된 익절)**: `ExecutionCountCondition`을 검사합니다. `실행 횟수 == 3` 조건이 `3 == 3` 이므로 \*\*참(True)\*\*이 되어 규칙이 계속 진행됩니다.
5.  **액션 실행**: 엔진은 조건까지 통과한 규칙 \#3의 `FullPositionSell` 액션을 실행합니다.
6.  **사이클 종료**: 포지션이 전량 매도되고 상태가 `CLOSED`로 변경됩니다. 이로써 하나의 완전한 매매 사이클이 성공적으로 종료됩니다.

---

# 문서 #5: 규칙 #4 구현 - 트레일링 스탑 (EXIT)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙의 목적은 **수익이 발생하기 시작한 포지션의 이익을 동적으로 보호**하는 것입니다. 추세가 계속되는 동안에는 수익을 극대화하도록 내버려 두다가, 추세가 꺾이는 신호가 보일 때 자동으로 포지션을 종료하여 확보된 수익을 지키는 핵심적인 리스크 관리 규칙입니다.

* **역할 (Role):** `EXIT`
* **활성화 상태 (Activation State):** `ACTIVE` (포지션 보유 중에만 작동)
* **핵심 컴포넌트 (Core Components):** `ProfitLossTrigger` (트레일링 기능 포함), `FullPositionSell`

---

### ## 2. 컴포넌트 구성 (Component Configuration)

이 규칙은 `트레일링 스탑` 로직이 내장된 `ProfitLossTrigger` 하나와, `FullPositionSell` 액션 하나로 간단하게 구성됩니다. 트리거 컴포넌트가 내부적으로 복잡한 로직을 처리하는 것이 특징입니다.

```json
{
  "rule_id": "exit_trailing_stop",
  "description": "수익 5% 달성 시점부터, 기록된 최고점 대비 3% 하락하면 전량 익절",
  "activation_state": "ACTIVE",
  "trigger": {
    "component": "ProfitLossTrigger",
    "config": {
      "activation_profit_percent": 5,
      "trail_percent": 3
    }
  },
  "action": {
    "component": "FullPositionSell",
    "config": {}
  }
}
````

#### **2.1. 트리거 설정 (`ProfitLossTrigger`)**

  * `component: "ProfitLossTrigger"`: 이 컴포넌트는 단순 수익률뿐만 아니라 트레일링 로직까지 처리할 수 있도록 설계되었습니다.
  * `activation_profit_percent: 5`: 트레일링 스탑 기능이 **활성화되는 최소 수익률**을 5%로 설정합니다. 이 수익률에 도달하기 전까지는 트레일링 기능이 작동하지 않습니다.
  * `trail_percent: 3`: 트레일링 스탑이 활성화된 이후, **기록된 최고점 대비 가격이 3% 하락**하면 트리거가 최종적으로 발동됩니다.

#### **2.2. 액션 설정 (`FullPositionSell`)**

  * `component: "FullPositionSell"`: 포지션 전체를 시장가로 청산하는 표준 액션 컴포넌트입니다.

-----

### \#\# 3. 실행 엔진에서의 동작 방식

`ProfitLossTrigger`의 트레일링 기능은 내부적으로 '활성화'와 '감시'의 2단계로 동작합니다.

1.  **감시 시작**: 포지션이 `ACTIVE` 상태가 되면, `ExecutionEngine`은 이 규칙을 활성화하여 매 틱마다 포지션의 수익률을 확인합니다.
2.  **활성화 대기**: 수익률이 `activation_profit_percent`(5%)에 도달하지 못하는 동안, 트리거는 계속 `False`를 반환하며 대기합니다.
3.  **트레일링 활성화**: 수익률이 5%를 넘어서는 순간, 트리거는 내부적으로 '활성화' 상태가 됩니다. 이때부터 트리거는 **포지션의 최고가를 실시간으로 기록하고 추적**하기 시작합니다. (이를 '고점(High-Water Mark)' 설정이라고 합니다.)
4.  **고점 추적 및 하락 감시**:
      * **가격이 계속 상승할 경우:** 트리거는 계속해서 자신의 내부 '최고가' 기록을 갱신하며 `False`를 반환합니다.
      * **가격이 하락할 경우:** 트리거는 `(기록된 최고가 - 현재가) / 기록된 최고가` 계산을 통해 하락률을 감시합니다. 이 하락률이 `trail_percent`(3%)에 도달하거나 초과하는 순간, 트리거는 최종적으로 `True`를 반환합니다.
5.  **액션 실행**: 엔진은 트리거로부터 `True` 신호를 받아 `FullPositionSell` 액션을 실행하여 포지션을 전량 청산합니다.
6.  **사이클 종료**: 포지션 상태가 `CLOSED`로 변경되고, 모든 `ACTIVE` 상태 규칙들의 감시가 종료됩니다.

---

# 문서 #6: 규칙 #5 구현 - 하락 시 물타기 (SCALE_IN)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙의 목적은 **포지션 진입 후 가격이 예상과 달리 하락했을 때, 추가 매수를 통해 평균 매입 단가를 낮추는 것**입니다. 이를 통해 손익분기점을 낮추고, 작은 반등에도 수익으로 전환할 기회를 만드는 리스크 관리 기법입니다. (이 기법은 하락 추세에서 손실을 키울 수 있는 위험도 내포합니다.)

* **역할 (Role):** `SCALE_IN`
* **활성화 상태 (Activation State):** `ACTIVE` (포지션 보유 중에만 작동)
* **핵심 컴포넌트 (Core Components):** `PriceChangeTrigger`, `ExecutionCountCondition`, `AdditionalBuy`

---

### ## 2. 컴포넌트 구성 (Component Configuration)

이 규칙은 `트리거`, `추가 조건`, `액션` 컴포넌트의 조합으로 구성됩니다. 이는 `COMPONENT_SYSTEM_ARCHITECTURE.md`에 예시된 '물타기 전략'의 구체적인 구현입니다.

```json
{
  "rule_id": "downward_averaging_on_dip",
  "description": "평단가 대비 5% 하락 시, 2회까지 20만원 추가 매수",
  "activation_state": "ACTIVE",
  "trigger": {
    "component": "PriceChangeTrigger",
    "config": {
      "reference": "average_price",
      "change_percent": -5,
      "direction": "below"
    }
  },
  "conditions": [
    {
      "component": "MaxCountCondition",
      "config": {
        "target_rule_id": "downward_averaging_on_dip",
        "max_count": 2
      }
    }
  ],
  "action": {
    "component": "AdditionalBuy",
    "config": {
      "amount": 200000
    }
  }
}
````

#### **2.1. 트리거 설정 (`PriceChangeTrigger`)**

  * `component: "PriceChangeTrigger"`: 가격 변화를 감지하는 컴포넌트를 사용합니다.
  * `reference: "average_price"`: 가격 변화를 계산할 기준점으로, 고정된 진입가가 아닌 실시간으로 변하는 '평균 매입 단가'를 사용합니다.
  * `change_percent: -5`: 평단가 대비 가격이 -5%가 되었을 때를 발동 조건으로 설정합니다.
  * `direction: "below"`: 현재가가 기준가 대비 설정된 퍼센트만큼 **아래로** 떨어졌을 때 트리거가 발동하도록 합니다.

#### **2.2. 추가 조건 설정 (`MaxCountCondition`)**

  * `component: "MaxCountCondition"`: 규칙의 최대 실행 횟수를 제한하는 조건 컴포넌트입니다.
  * `target_rule_id: "downward_averaging_on_dip"`: 자기 자신의 실행 횟수를 추적합니다.
  * `max_count: 2`: 물타기는 최대 2번까지만 실행되도록 제한하여 무한한 추가 매수로 인한 리스크를 방지합니다.

#### **2.3. 액션 설정 (`AdditionalBuy`)**

  * `component: "AdditionalBuy"`: 기존 포지션에 수량을 더하는 액션 컴포넌트입니다.
  * `amount: 200000`: 조건 충족 시, 20만 원을 추가로 매수하여 평단을 낮춥니다.

-----

### \#\# 3. 실행 엔진에서의 동작 방식

1.  **감시 시작**: 포지션이 `ACTIVE` 상태가 되면 `ExecutionEngine`이 이 규칙을 활성화합니다.
2.  **트리거 평가**: 엔진은 매 틱마다 현재가가 포지션의 실시간 평단가 대비 얼마나 하락했는지 계산하여 `PriceChangeTrigger`의 조건(-5%)을 검사합니다.
3.  **추가 조건 검사**: 트리거 조건이 충족되면, 엔진은 `MaxCountCondition`을 통해 이 규칙의 실행 횟수가 2회 미만인지 확인합니다.
4.  **액션 실행**: 두 조건이 모두 참이면, 엔진은 `AdditionalBuy` 액션을 실행합니다.
5.  **상태 업데이트**: 추가 매수 체결 후, 새로운 수량과 매입가를 반영하여 포지션의 `평균 매입 단가(average_price)`가 더 낮은 값으로 재계산됩니다. 이 규칙의 실행 횟수 카운터도 1 증가합니다.
6.  **반복 또는 중지**: 이후, 다시 낮아진 **새로운 평단가**를 기준으로 -5% 하락이 발생하면 규칙은 다시 발동될 수 있습니다(최대 2회까지).

---

# 문서 #7: 규칙 #6 구현 - 급락 감지 (EXIT / RISK_MGMT)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙은 시스템의 **최상위 비상 탈출 장치** 역할을 합니다. 일반적인 손실 관리 규칙(e.g., 트레일링 스탑)이 반응하기 힘든 갑작스러운 시장 붕괴 상황에서, 다른 모든 논리를 무시하고 즉시 포지션을 청산하여 치명적인 손실을 방지하는 것을 최우선 목표로 합니다.

* **역할 (Role):** `EXIT` / `RISK_MGMT`
* **활성화 상태 (Activation State):** `ACTIVE` (포지션 보유 중에만 작동)
* **핵심 컴포넌트 (Core Components):** `RapidPriceDropTrigger`, `FullPositionSell`
* **핵심 속성 (Key Attribute):** **`priority: 0` (최상위 우선순위)**

---

### ## 2. 컴포넌트 구성 (Component Configuration)

이 규칙의 가장 큰 특징은 다른 규칙들과의 충돌 시 항상 이길 수 있도록 **가장 높은 우선순위(`priority: 0`)**를 명시적으로 부여받는다는 점입니다.

```json
{
  "rule_id": "emergency_exit_on_crash",
  "description": "1분 내에 5% 이상 급락 시, 모든 규칙에 우선하여 즉시 전량 매도",
  "priority": 0,
  "activation_state": "ACTIVE",
  "trigger": {
    "component": "RapidPriceDropTrigger",
    "config": {
      "drop_percent": -5,
      "time_frame_seconds": 60
    }
  },
  "action": {
    "component": "FullPositionSell",
    "config": {}
  }
}
````

#### **2.1. 핵심 속성 (`priority`)**

  * `priority: 0`: 실행 엔진이 처리할 규칙의 우선순위를 정의합니다. 숫자가 낮을수록 우선순위가 높으며, `0`은 최상위 레벨을 의미합니다. 이 규칙이 다른 어떤 규칙과 동시에 발동 조건을 만족하더라도, 항상 이 규칙이 채택되도록 보장합니다.

#### **2.2. 트리거 설정 (`RapidPriceDropTrigger`)**

  * `component: "RapidPriceDropTrigger"`: 단기간 내의 가격 변화율을 감지하는 특수 트리거 컴포넌트입니다.
  * `drop_percent: -5`: 하락률 감지 임계값을 -5%로 설정합니다.
  * `time_frame_seconds: 60`: 60초라는 짧은 시간 프레임 내의 가격 변화를 감시합니다.

#### **2.3. 액션 설정 (`FullPositionSell`)**

  * `component: "FullPositionSell"`: 포지션 전체를 즉시 시장가로 청산하는 표준 액션입니다.

-----

### \#\# 3. 실행 엔진에서의 동작 방식 (우선순위 적용)

이 규칙의 존재로 인해 `ExecutionEngine`의 신호 처리 방식은 더욱 정교해집니다.

1.  **감시 시작**: 포지션이 `ACTIVE` 상태가 되면, 이 규칙은 다른 관리 규칙들과 함께 동시에 시장을 감시합니다.
2.  **충돌 상황 발생**: 시장이 폭락하여 **단일 데이터 틱** 안에서, `-5% 하락` 조건과 `-5% 급락` 조건이 동시에 만족되었다고 가정합니다.
      * \*\*규칙 \#5 (물타기)\*\*의 `PriceChangeTrigger`가 `True`를 반환합니다.
      * \*\*규칙 \#6 (급락 감지)\*\*의 `RapidPriceDropTrigger`도 `True`를 반환합니다.
3.  **발동 규칙 수집 및 정렬**: `ExecutionEngine`은 발동된 `규칙 #5`와 `규칙 #6`을 '실행 후보 리스트'에 담습니다. 그 후, **액션을 실행하기 전에 리스트를 `priority` 순으로 정렬**합니다.
      * 정렬 결과: `[규칙 #6 (priority: 0), 규칙 #5 (priority: 10-기본값)]`
4.  **최우선 규칙 실행**: 엔진은 정렬된 리스트의 가장 첫 번째, 즉 **가장 우선순위가 높은 `규칙 #6`의 `FullPositionSell` 액션만을 최종 실행**합니다.
5.  **나머지 규칙 무시**: 리스트의 나머지 규칙들(이 경우 `규칙 #5`)은 이번 실행 사이클에서 **자동으로 무시**됩니다.
6.  **사이클 종료**: 포지션이 전량 청산되고 상태가 `CLOSED`로 변경됩니다. 결과적으로 시스템은 폭락장에서 물타기를 하는 대신, 가장 안전한 탈출을 감행하게 됩니다.

---

# 문서 #8: 규칙 #7 구현 - 급등 홀드 (MANAGEMENT)

---

### ## 1. 규칙 개요 (Rule Overview)

이 규칙의 목적은 **비이성적인 과열 및 급등 상황에서 위험한 추격 매수(불타기)를 지능적으로 제어**하는 것입니다. 이 규칙은 직접적인 매매를 실행하는 대신, 다른 규칙의 동작을 일시적으로 '정지'시키는 '메타(Meta)' 역할을 수행합니다.

* **역할 (Role):** `MANAGEMENT`
* **활성화 상태 (Activation State):** `ACTIVE` (포지션 보유 중에만 작동)
* **핵심 컴포넌트 (Core Components):** `RapidPriceSpikeTrigger`, `ModifyContextAction`
* **핵심 속성 (Key Attribute):** **`priority: 1`** (급락 감지 다음으로 높은 우선순위)

---

### ## 2. 아키텍처 확장: '실행 컨텍스트'와 '메타 액션'

이 정교한 규칙을 구현하기 위해, 기존 아키텍처에 두 가지 개념을 추가해야 합니다. 이는 `COMPONENT_SYSTEM_ARCHITECTURE.MD`에 명시된 `ExecutionContext`와 `ManagementActionComponent` 개념의 구체적인 확장입니다.

* **실행 컨텍스트 (Execution Context):**
    * 하나의 매매 사이클 동안 모든 규칙이 공유하는 '메모장' 또는 '상태 보드'입니다.
    * 여기에 `is_pyramiding_paused: false` 와 같은 불리언(Boolean) 플래그를 추가하여, 특정 조건의 활성화 여부를 기록합니다.

* **메타 액션 (Meta Action):**
    * 매수/매도 주문을 내는 대신, **'실행 컨텍스트'의 상태를 변경**하는 특별한 종류의 액션입니다. `ModifyContextAction`이 그 예입니다.

---

### ## 3. 컴포넌트 구성 (Component Configuration)

#### **3.1. 신규 '급등 홀드' 규칙 구성**

이 규칙은 `ModifyContextAction`을 통해 '불타기 일시정지' 플래그를 `True`로 설정합니다.

```json
{
  "rule_id": "hold_pyramiding_on_spike",
  "description": "1분 내 5% 급등 시, 불타기 규칙을 일시 정지시킴",
  "priority": 1,
  "activation_state": "ACTIVE",
  "trigger": {
    "component": "RapidPriceSpikeTrigger",
    "config": {
      "spike_percent": 5,
      "time_frame_seconds": 60
    }
  },
  "action": {
    "component": "ModifyContextAction",
    "config": {
      "set_flag": "is_pyramiding_paused",
      "value": true
    }
  }
}
````

#### **3.2. 기존 '불타기' 규칙(규칙 \#2)의 수정**

'규칙 \#7'이 효과를 발휘하려면, '규칙 \#2'는 이제 '실행 컨텍스트'의 상태를 확인해야 합니다. 이를 위해 `ContextCondition`이 추가됩니다.

```json
{
  "rule_id": "scale_in_on_profit",
  "description": "수익률 5% 도달 시, (일시정지 아닐 때만) 3회까지 추가 매수",
  "activation_state": "ACTIVE",
  "trigger": {
      "component": "ProfitLossTrigger",
      "config": { "profit_percent": 5, "direction": "above" }
  },
  "conditions": [
    {
      "component": "ExecutionCountCondition",
      "config": { "target_rule_id": "scale_in_on_profit", "less_than": 3 }
    },
    {
      "component": "ContextCondition",
      "config": { "check_flag": "is_pyramiding_paused", "is_value": false }
    }
  ],
  "action": {
      "component": "AdditionalBuy",
      "config": { "amount": 100000 }
  }
}
```

-----

### \#\# 4. 실행 엔진에서의 동작 방식

1.  **상황 발생**: 포지션 진입 후, 가격이 45초 만에 6% 급등합니다.
2.  **충돌 발생**: `ExecutionEngine`의 단일 실행 사이클 내에서 아래 두 규칙의 트리거가 모두 `True`가 됩니다.
      * **규칙 \#2 (불타기)**: 수익률이 5%를 넘었으므로 발동.
      * **규칙 \#7 (급등 홀드)**: 1분 내 5% 이상 급등했으므로 발동.
3.  **우선순위 해결**: 엔진은 '발동 리스트'에 담긴 `규칙 #2`와 `규칙 #7`을 `priority`로 정렬합니다. `규칙 #7(priority: 1)`이 `규칙 #2(priority: 10-기본값)`보다 우선순위가 높습니다.
4.  **메타 액션 실행**: 엔진은 **규칙 \#7**의 `ModifyContextAction`을 실행합니다. 이로 인해 `실행 컨텍스트`의 `is_pyramiding_paused` 플래그가 `True`로 변경됩니다. 규칙 \#2의 `AdditionalBuy` 액션은 이번 사이클에서 무시됩니다.
5.  **이후 동작 제어**:
      * 다음 데이터 틱부터 가격이 계속 오르더라도, \*\*규칙 \#2 (불타기)\*\*는 자신의 `ContextCondition`을 통과하지 못합니다 (`is_pyramiding_paused`가 `True`이기 때문).
      * 결과적으로 **불타기는 완벽하게 차단**되고, `규칙 #4 (트레일링 스탑)`만이 활성화되어 급등으로 발생한 수익을 안전하게 지키게 됩니다.

---

# 문서 #9: 조합 예시 1 - 기본 진입과 불타기 (규칙 #1 + #2)

---

### ## 1. 조합 구성 (Combination Composition)

가장 기본적인 "진입 후 관리" 조합입니다. 이 조합은 다음 두 가지 규칙으로 구성됩니다.

* **규칙 #1**: `RSI 과매도 진입 (ENTRY)`
    * **역할**: 포지션이 없을 때(`READY` 상태) 새로운 포지션을 시작합니다.
* **규칙 #2**: `수익 시 불타기 (SCALE_IN)`
    * **역할**: 포지션이 있을 때(`ACTIVE` 상태) 수익률 조건을 만족하면 추가 매수합니다.

---

### ## 2. 핵심 상호작용: 상태 전환 (Core Interaction: State Transition)

이 조합의 핵심은 '충돌'이 아니라, **포지션의 상태(`state`) 변화에 따른 역할 교대**입니다.

1.  **초기 상태**: 포지션의 상태는 `READY`입니다. `ExecutionEngine`은 `activation_state`가 `READY`인 **규칙 #1**만 활성화하여 감시합니다. 규칙 #2는 비활성화 상태입니다.

2.  **진입 발생**: 규칙 #1의 `RSITrigger` 조건이 충족되어 `MarketBuyAction`이 실행됩니다.

3.  **상태 전환**: 매수 주문이 체결되면, 포지션 객체의 상태는 `READY`에서 **`ACTIVE`**로 변경됩니다.

4.  **역할 교대**: 다음 데이터 틱부터 `ExecutionEngine`은 포지션의 `ACTIVE` 상태를 인지합니다.
    * 이제 `activation_state`가 `READY`인 규칙 #1은 비활성화됩니다.
    * 반대로 `activation_state`가 `ACTIVE`인 **규칙 #2**가 활성화되어 시장을 감시하기 시작합니다.

이처럼 시스템은 포지션의 상태 변경을 통해, '진입 담당' 규칙에서 '관리 담당' 규칙으로 자연스럽게 제어권을 넘깁니다.

---

### ## 3. 시나리오: 진입 후 가격 상승 시

1.  **대기**: 포지션 상태는 `READY`. 시스템은 RSI가 20 아래로 떨어지기만을 기다립니다. (규칙 #1 활성)

2.  **진입**: RSI가 19가 되어 규칙 #1이 발동, 10만 원어치 코인이 매수됩니다. 포지션 상태가 `ACTIVE`로 변경됩니다.

3.  **관리**: 이제 시스템은 규칙 #1의 감시를 멈추고, 규칙 #2를 활성화하여 포지션의 수익률을 감시합니다.

4.  **불타기**: 가격이 상승하여 평단가 대비 수익률이 5%에 도달합니다. 규칙 #2가 발동하여 10만 원을 추가 매수합니다. 포지션의 평단가와 수량이 재계산됩니다.

5.  **이후 상태**: 이 조합에는 포지션을 자동으로 청산하는 `EXIT` 역할의 규칙이 없습니다. 따라서 '불타기'가 최대 횟수에 도달한 후에는, 더 이상 어떤 규칙도 발동하지 않고 포지션은 계속 유지됩니다. **(불완전한 조합)**

---

# 문서 #10: 조합 예시 2 - 계획된 익절 추가 (규칙 #1 + #2 + #3)

---

### ## 1. 조합 구성 변경 (Combination Composition Change)

이전 `문서 #9`의 "진입+불타기" 조합은 청산 기능이 없어 불완전했습니다. 여기에 **'계획된 익절' 규칙을 추가**하여 완전한 전략으로 만듭니다.

* **기존 규칙**
    * **규칙 #1**: `RSI 과매도 진입 (ENTRY)`
    * **규칙 #2**: `수익 시 불타기 (SCALE_IN)`
* **새로 추가된 규칙**
    * **규칙 #3**: `계획된 익절 (EXIT)`

---

### ## 2. 핵심 상호작용: 조건 분기 (Core Interaction: Conditional Branching)

이 조합의 핵심은 `규칙 #2 (불타기)`와 `규칙 #3 (계획된 익절)`이 **동일한 `ProfitLossTrigger`를 공유**하지만, 서로 **배타적인 `ExecutionCountCondition`을 가지고 있다는 점**입니다. 이로 인해 시스템은 명확한 논리적 분기가 가능해집니다.

1.  **상황**: 포지션이 `ACTIVE` 상태이고, `ProfitLossTrigger`가 `5%` 수익 조건으로 발동했습니다.
2.  **`ExecutionEngine`의 동시 평가**: 엔진은 `규칙 #2`와 `규칙 #3`의 조건을 모두 검사합니다.
3.  **조건 분기**:
    * **만약 `규칙 #2`의 실행 횟수가 3회 미만이면:**
        * `규칙 #2`의 조건 통과 → `AdditionalBuy` 액션 실행.
        * `규칙 #3`의 조건 실패 → 무시.
    * **만약 `규칙 #2`의 실행 횟수가 정확히 3회이면:**
        * `규칙 #2`의 조건 실패 → 무시.
        * `규칙 #3`의 조건 통과 → `FullPositionSell` 액션 실행.

이처럼 `ExecutionCountCondition`은 두 규칙이 같은 신호에 반응하더라도, 상황에 따라 단 하나의 규칙만 실행되도록 보장하는 교통 경찰 역할을 합니다.

---

### ## 3. 시나리오: 불타기 완료 후 자동 청산

1.  **진입 및 불타기**: `규칙 #1`로 진입 후, `규칙 #2`가 3번 실행되어 불타기 과정이 모두 완료되었습니다. (`규칙 #2`의 실행 횟수 = 3)

2.  **다음 수익 신호 감시**: 포지션은 `ACTIVE` 상태로 유지되며, 엔진은 계속해서 모든 `ACTIVE` 규칙들을 감시합니다.

3.  **계획된 익절 발동**: 가격이 다시 한번 5% 수익 구간에 도달하여 `ProfitLossTrigger`가 발동합니다.

4.  **최종 결정**: 엔진은 `규칙 #2`와 `규칙 #3`을 평가합니다. `규칙 #2`의 실행 횟수가 3이므로 조건에 맞지 않아 실패하고, `규칙 #3`의 조건(`실행 횟수 == 3`)은 충족됩니다.

5.  **사이클 종료**: 엔진은 **`규칙 #3`의 `FullPositionSell` 액션을 실행**하여 포지션을 전량 매도합니다. 포지션 상태는 `CLOSED`로 변경됩니다.

> ✅ 이로써 **'진입 → 불타기 → 계획된 청산'**으로 이어지는 하나의 완결된 자동 매매 사이클이 완성되었습니다.

---

# 문서 #11: 조합 예시 3 - 트레일링 스탑 추가 (규칙 #1 ~ #4)

---

### ## 1. 조합 구성 변경 (Combination Composition Change)

`문서 #10`의 '계획된 익절' 방식은 목표 수익률에 도달해야만 청산이 가능하다는 한계가 있습니다. 여기에 **시장 추세의 변화를 감지하여 청산하는 '트레일링 스탑' 규칙을 추가**하여 전략의 안정성을 높입니다.

* **기존 규칙**
    * **규칙 #1**: `RSI 과매도 진입 (ENTRY)`
    * **규칙 #2**: `수익 시 불타기 (SCALE_IN)`
    * **규칙 #3**: `계획된 익절 (EXIT)`
* **새로 추가된 규칙**
    * **규칙 #4**: `트레일링 스탑 (EXIT)`

---

### ## 2. 핵심 상호작용: 출구 전략의 경쟁 (Core Interaction: A Race Between Exit Strategies)

이제 이 조합에는 `규칙 #3`과 `규칙 #4`라는 **두 개의 `EXIT` 역할 규칙**이 존재합니다. 포지션이 `ACTIVE` 상태가 되면, `ExecutionEngine`은 이 두 청산 규칙을 동시에 활성화하고 감시합니다.

시스템의 행동은 두 규칙 간의 **'경쟁'**에 의해 결정됩니다.

> **"어느 규칙의 트리거 조건이 먼저 만족되는가?"**

* **시장이 꾸준히 계단식으로 상승한다면:** `규칙 #3 (계획된 익절)`이 먼저 발동될 가능성이 높습니다.
* **시장이 급등 후 갑자기 추세가 꺾인다면:** `규칙 #4 (트레일링 스탑)`이 `규칙 #3`의 조건이 만족되기 전에 먼저 발동하여 이익을 확보할 가능성이 높습니다.

이러한 경쟁 구조는 전략에 유연성을 부여하여, 다양한 시장 시나리오에 더 효과적으로 대응하게 만듭니다.

---

### ## 3. 시나리오: 추세 반전으로 인한 조기 익절

1.  **진입 및 불타기**: `규칙 #1`로 진입 후, 가격이 상승하여 `규칙 #2`가 두 번 실행되었습니다. 현재 포지션의 수익률은 12%입니다.

2.  **트레일링 스탑 활성화**: 수익률이 5%를 넘었으므로, `규칙 #4`의 트레일링 스탑 기능은 이미 활성화되어 실시간으로 포지션의 최고가를 추적하고 있습니다.

3.  **추세 반전**: 가격이 계속 상승하여 수익률 13%에서 최고점을 기록한 후, 갑자기 하락하여 9.5%가 되었습니다.
    * 이 하락 폭(약 3.5%)은 `규칙 #4`에 설정된 `trail_percent`(3%)를 초과했습니다.

4.  **조기 익절 발동**: `규칙 #4`의 `ProfitLossTrigger`가 **먼저** `True` 신호를 보냅니다.
    * `규칙 #2`와 `규칙 #3`은 다음 목표 수익률(15%)에 도달하지 못했으므로 아직 발동 조건이 충족되지 않은 상태입니다.

5.  **사이클 종료**: 엔진은 가장 먼저 신호를 보낸 **`규칙 #4`의 `FullPositionSell` 액션을 실행**하여 포지션을 전량 청산합니다.

> ✅ 결과적으로, 트레일링 스탑 규칙은 계획된 최종 목표가 오기 전에 추세의 약화를 감지하고 먼저 이익을 실현함으로써, 더 큰 하락으로부터 수익을 안전하게 지키는 역할을 성공적으로 수행했습니다.

---

# 문서 #12: 조합 예시 4 - 하락 시 물타기 추가 (규칙 #1 ~ #5)

---

### ## 1. 조합 구성 변경 (Combination Composition Change)

지금까지의 조합은 진입 후 가격이 상승하는 시나리오에만 집중했습니다. 여기에 **진입 후 하락 시나리오에 대응하는 '물타기' 규칙을 추가**하여 전략의 생존성과 유연성을 높입니다.

* **기존 규칙**
    * **규칙 #1**: `RSI 과매도 진입 (ENTRY)`
    * **규칙 #2**: `수익 시 불타기 (SCALE_IN)`
    * **규칙 #3**: `계획된 익절 (EXIT)`
    * **규칙 #4**: `트레일링 스탑 (EXIT)`
* **새로 추가된 규칙**
    * **규칙 #5**: `하락 시 물타기 (SCALE_IN)`

---

### ## 2. 핵심 상호작용: 양방향 시나리오 대응 (Core Interaction: Responding to Two-Way Scenarios)

이 조합의 핵심은 진입(`ACTIVE` 상태) 이후, **서로 다른 방향성의 트리거를 가진 규칙들이 동시에 대기**한다는 점입니다.

> **"진입 후, 가격이 오르는가? 아니면 내리는가?"**

`ExecutionEngine`은 이 질문에 따라 어떤 규칙을 활성화할지 결정합니다.

* **가격 상승 시**: 수익률 기반의 `규칙 #2, #3, #4`가 작동할 준비를 합니다. `규칙 #5`는 손실 조건이 아니므로 계속 대기합니다.
* **가격 하락 시**: 손실률 기반의 `규칙 #5`가 작동할 준비를 합니다. 수익 기반 규칙들은 모두 대기합니다.

이로써 전략은 상승과 하락이라는 갈림길 모두에 대한 대응 계획을 갖추게 됩니다.

---

### ## 3. 시나리오: 진입 후 하락 및 물타기 후 반등

1.  **진입**: `규칙 #1`로 진입하여 포지션 상태가 `ACTIVE`가 됩니다. 시스템은 이제 규칙 #2, #3, #4, #5를 동시에 감시합니다.

2.  **하락 및 물타기**: 예상과 달리 가격이 하락하여 평단가 대비 **-5%**가 됩니다.
    * `규칙 #5`의 `PriceChangeTrigger`가 `True`를 반환합니다.
    * 수익 기반 규칙들(#2, #3, #4)은 조건이 맞지 않아 모두 `False`를 반환합니다.
    * 엔진은 **`규칙 #5`의 `AdditionalBuy` 액션을 실행**하여 '물타기'를 합니다.

3.  **상태 업데이트**: 포지션의 평균 매입 단가는 낮아지고, 보유 수량은 늘어납니다. 이 과정에서 `규칙 #4(트레일링 스탑)`는 수익 5%라는 활성화 조건 자체가 충족된 적이 없으므로 전혀 개입하지 않았습니다.

4.  **반등 및 역할 교대**: 이후 시장이 반등하여 가격이 상승하기 시작합니다.
    * 물타기로 평단가가 낮아졌기 때문에, 더 작은 가격 상승으로도 수익권에 진입할 수 있습니다.
    * 가격이 계속 올라 **새로운 평단가** 대비 수익률이 5%에 도달하면, 이제는 `규칙 #2(불타기)`와 `규칙 #4(트레일링 스탑)`가 작동할 수 있는 조건이 됩니다.

5.  **이후 흐름**: 시스템은 이제 다시 수익 관리 모드로 전환되어, `문서 #11`에서 설명한 것과 같이 불타기를 하거나 트레일링 스탑으로 이익을 보호하는 로직을 수행하게 됩니다.

> ✅ '물타기' 규칙의 추가로, 초기에 불리하게 시작된 거래에도 회복의 기회를 제공하여 전략의 전반적인 강건함(Robustness)을 크게 향상시켰습니다.

---

# 문서 #13: 조합 예시 5 - 급락 감지 규칙 추가 (규칙 #1 ~ #6)

---

### ## 1. 조합 구성 변경 (Combination Composition Change)

`문서 #12`의 조합은 상승과 하락 양방향에 대응할 수 있지만, '폭락'과 같은 이례적인 시장 상황에 대한 최종 안전장치가 부족합니다. 여기에 **모든 규칙에 우선하는 '급락 감지' 규칙을 추가**합니다.

* **기존 규칙**
    * **규칙 #1**: `RSI 과매도 진입 (ENTRY)`
    * **규칙 #2**: `수익 시 불타기 (SCALE_IN)`
    * **규칙 #3**: `계획된 익절 (EXIT)`
    * **규칙 #4**: `트레일링 스탑 (EXIT)`
    * **규칙 #5**: `하락 시 물타기 (SCALE_IN)`
* **새로 추가된 규칙**
    * **규칙 #6**: `급락 감지 (EXIT / RISK_MGMT)` - **Priority: 0**

---

### ## 2. 핵심 상호작용: 절대적 우선순위 (Core Interaction: Absolute Priority)

이 조합의 핵심은 `규칙 #6`이 가진 **절대적인 우선순위**입니다. `ExecutionEngine`은 신호 충돌이 발생했을 때, 이 우선순위 규칙에 따라 행동합니다.

1.  **규칙 평가 및 수집**: 한 실행 사이클 내에서, 엔진은 활성화된 모든 규칙을 평가하고 발동 조건이 `True`가 된 규칙들을 모두 '실행 후보 리스트'에 담습니다.
2.  **우선순위 정렬**: 액션을 실행하기 직전, 엔진은 이 '실행 후보 리스트'를 각 규칙이 가진 `priority` 값에 따라 내림차순으로 정렬합니다. (`priority: 0`인 규칙 #6이 항상 리스트의 맨 위로 옵니다.)
3.  **최종 선택**: 엔진은 정렬된 리스트에서 **가장 위에 있는 단 하나의 규칙만을 실행**하고, 나머지 후보들은 해당 사이클에서 모두 무시합니다.

이 메커니즘을 통해 `규칙 #6`은 다른 어떤 규칙(심지어 물타기 규칙)보다 항상 먼저 실행될 권한을 갖게 됩니다.

---

### ## 3. 시나리오: '물타기'와 '급락 감지'의 충돌

1.  **진입**: `규칙 #1`로 진입 후 포지션 상태가 `ACTIVE`가 되어, 모든 관리/청산 규칙이 활성화됩니다.
2.  **폭락장 발생**: 가격이 안정적으로 -5% 하락한 것이 아니라, **단 한 번의 데이터 틱**으로 순식간에 -6% 폭락했습니다.
3.  **충돌 발생**: 이 한 번의 틱 동안, `ExecutionEngine`은 다음 두 규칙의 조건이 모두 `True`임을 발견합니다.
    * **규칙 #5 (물타기)**: 평단가 대비 -5% 이상 하락했으므로 발동.
    * **규칙 #6 (급락 감지)**: 단일 주기 내에 -5% 이상 하락했으므로 발동.
4.  **우선순위에 따른 해결**:
    * 엔진은 '실행 후보 리스트'에 `[규칙 #5, 규칙 #6]`을 담습니다.
    * 리스트를 `priority`로 정렬하면 `[규칙 #6, 규칙 #5]` 순서가 됩니다.
    * 엔진은 리스트의 첫 번째인 **`규칙 #6`의 `FullPositionSell` 액션을 최종 실행**합니다.
    * `규칙 #5`의 `AdditionalBuy` 액션은 실행되지 않고 무시됩니다.

> ✅ 최종적으로, 시스템은 폭락하는 시장에서 위험하게 자산을 추가 투입('물타기')하는 대신, 가장 먼저 포지션을 전량 청산하여 손실 확산을 막는 가장 안전한 행동을 수행합니다. 이것이 바로 우선순위 기반 리스크 관리의 핵심입니다.

---

# 문서 #14: 조합 예시 6 - 최종 완성 (규칙 #1 ~ #7)

---

### ## 1. 조합 구성 변경 (Combination Composition Change)

`문서 #13`의 조합에, 비이성적인 과열에 대응하는 마지막 퍼즐 조각, **'급등 홀드' 규칙을 추가하여 7개 규칙으로 이루어진 최종 전략을 완성**합니다.

* **기존 규칙**
    * **규칙 #1 ~ #6**
* **새로 추가된 규칙**
    * **규칙 #7**: `급등 홀드 (MANAGEMENT)` - **Priority: 1**

이제 이 전략은 평범한 상승/하락, 점진적인 추세, 갑작스러운 폭락, 그리고 비정상적인 급등이라는 거의 모든 시장 상황에 대해 구체적인 대응 계획을 갖추게 되었습니다.

---

### ## 2. 핵심 상호작용: 메타 제어 (Core Interaction: Meta Control)

이 조합의 가장 진보된 상호작용은 **한 규칙이 다른 규칙의 작동 조건을 동적으로 제어**하는 '메타 제어'입니다.

1.  **'급등 홀드(규칙 #7)' 발동**: `RapidPriceSpikeTrigger`가 급등을 감지합니다.
2.  **우선순위 실행**: 높은 우선순위(`priority: 1`) 덕분에 다른 관리 규칙보다 먼저 `ModifyContextAction`이 실행됩니다.
3.  **'컨텍스트' 상태 변경**: 이 액션은 `실행 컨텍스트(ExecutionContext)`라는 공유 메모리의 `is_pyramiding_paused` 플래그를 `True`로 설정합니다.
4.  **'불타기' 규칙 제어**: `불타기(규칙 #2)`는 자신의 `조건(Condition)` 중 하나로 `is_pyramiding_paused` 플래그가 `False`인지를 항상 검사합니다.
5.  **결과**: 플래그가 `True`로 바뀌었기 때문에, `불타기` 규칙은 더 이상 발동 조건을 만족할 수 없어 **자동으로 비활성화(홀드)**됩니다.

이처럼 직접적인 신호 충돌 없이도, 우선순위와 공유 컨텍스트를 통해 규칙 간의 정교한 상호작용을 구현할 수 있습니다.

---

### ## 3. 시나리오: '불타기'와 '급등 홀드'의 충돌

1.  **진입**: 포지션이 `ACTIVE` 상태입니다.
2.  **급등 발생**: 30초라는 짧은 시간 안에 가격이 **+5%** 이상 폭등합니다.
3.  **충돌 발생**: 이 한 번의 실행 사이클에서 다음 두 규칙의 트리거가 모두 `True`가 됩니다.
    * **규칙 #2 (불타기)**: 수익률이 5%를 넘었으므로 발동.
    * **규칙 #7 (급등 홀드)**: 1분 내 5% 이상 급등했으므로 발동.
4.  **우선순위 해결**: `ExecutionEngine`은 '실행 후보 리스트' `[규칙 #2, 규칙 #7]`를 `priority`로 정렬하여 `[규칙 #7, 규칙 #2]` 순서로 만듭니다.
5.  **메타 액션 실행**: 엔진은 리스트의 첫 번째인 **`규칙 #7`의 `ModifyContextAction`을 실행**합니다.
    * `실행 컨텍스트`의 `is_pyramiding_paused` 플래그가 `True`가 됩니다.
    * `규칙 #2`의 `AdditionalBuy` 액션은 무시됩니다.

> ✅ 최종적으로, 시스템은 과열된 시장에 대한 추격 매수를 스스로 멈춥니다. 이제 투자자를 보호하는 것은 오직 `규칙 #4 (트레일링 스탑)` 뿐이며, 시스템은 급등으로 얻은 수익을 지키는 데에만 집중하게 됩니다. 이로써 매우 지능적이고 강건한(Robust) 자동 매매 전략이 완성되었습니다.

---

### ## 문서 1: 아키텍처 개요 (The "Why")

> **목적: 이 시스템이 왜, 어떤 철학으로 설계되었는지에 대한 큰 그림을 전달합니다.**

* **시스템 목표 및 설계 철학**: 기존 고정 클래스 방식의 문제점을 해결하고, '전략을 만드는 도구'를 제공하는 새로운 컴포넌트 시스템의 비전을 설명합니다.
* **핵심 아키텍처**: 아토믹 컴포넌트, 컴포넌트 조합, 최종 전략으로 이어지는 계층적 구조를 요약합니다.
* **주요 데이터 흐름**: 사용자의 UI 조작이 어떻게 데이터베이스에 저장되고, 다시 UI에 렌더링되는지의 전체적인 플로우를 설명합니다.
* **포지션 관리 시스템**: '태그'를 기반으로 자동매매와 수동매매의 충돌을 방지하는 핵심적인 포지션 관리 매트릭스를 소개합니다.

---

### ## 문서 2: 기술 참조 매뉴얼 (The "What")

> **목적: 시스템을 구성하는 모든 '부품'과 '규칙'에 대한 상세한 기술 명세를 제공합니다.**

* **컴포넌트 카탈로그**: 시스템에 포함된 모든 `트리거`, `액션`, `조건` 컴포넌트의 전체 목록과 각각의 설정(Config) 파라미터를 상세히 기술합니다.
* **핵심 클래스 구조**: 시스템 구동에 필요한 최소한의 필수 클래스(`BaseTrigger`, `BaseAction`, `StrategyRule`, `Position`, `ExecutionEngine` 등)의 구조와 핵심 메서드를 정의합니다.
* **데이터베이스 스키마**: 전략, 규칙, 조합 등을 저장하기 위해 우리가 논의했던 모든 테이블(`strategies`, `conditions`, `actions`, `portfolios`, `portfolio_rules` 등)의 최종 스키마를 제공합니다.
* **포지션 상태 머신**: 포지션의 생명주기(`READY`, `ACTIVE`, `CLOSED`)와 각 상태에서 활성화되는 규칙의 종류를 명확히 정의합니다.

---

### ## 문서 3: 구현 가이드 및 예제 (The "How")

> **목적: 앞서 정의한 아키텍처와 컴포넌트들이 실제 전략에서 어떻게 조립되고 실행되는지 구체적인 예시를 통해 보여줍니다.**

* **UI 구현 가이드**: 3-Panel 구조의 '전략 메이커'와 드래그앤드롭 인터페이스의 핵심 로직을 요약합니다.
* **완성된 전략 템플릿 (JSON)**: 우리가 함께 만든 '7규칙 최종 전략'의 전체 JSON 데이터 구조를 제공합니다. 이는 에이전트가 참고할 가장 완벽한 실전 예제가 될 것입니다.
* **복합 시나리오 실행 흐름**: '급락' 또는 '급등' 상황에서 `ExecutionEngine`이 여러 규칙의 충돌을 `우선순위`와 `실행 컨텍스트`를 통해 어떻게 해결하는지 단계별로 상세히 설명합니다.

---

# 바이브 코딩 에이전트 전달 문서 1/3: 아키텍처 개요

---

### ## 1. 시스템 목표 및 설계 철학 🎯

이 프로젝트의 핵심은 기존의 고정된 전략 클래스 방식에서 벗어나, 유연하고 확장 가능한 **아토믹 컴포넌트 시스템**으로 전환하는 것입니다.

우리의 설계 철학은 **"전략을 직접 만드는 것이 아니라, 사용자가 전략을 만들 수 있는 강력한 도구를 제공한다"**는 것입니다. 이를 통해 사용자는 드래그 & 드롭 방식의 비주얼 에디터를 사용하여 무한에 가까운 전략을 직접 구성할 수 있습니다.

---

### ## 2. 핵심 아키텍처: 컴포넌트 시스템 🧩

시스템은 최소 기능 단위인 **아토믹 컴포넌트(Atomic Components)**를 기반으로 구축됩니다. 모든 전략은 이 컴포넌트들의 조합으로 이루어집니다.

#### **2.1. 컴포넌트 분류 체계**

* **트리거 (Trigger):** 시장의 특정 조건(가격, 지표 등)을 감지하여 신호를 발생시킵니다.
* **액션 (Action):** 트리거의 신호를 받아 실제 매수/매도/관리 행동을 실행합니다.
* **조건 (Condition):** 트리거와 액션 사이에서 추가적인 검증 로직을 수행합니다.
* **계산 (Calculator):** 적정 포지션 크기나 손익 등 동적인 값을 계산합니다.

#### **2.2. 아키텍처 계층 구조**

시스템은 다음과 같은 명확한 계층 구조를 따릅니다.

1.  **전략 인스턴스 (Strategy Instance):** 사용자가 만든 하나의 완전한 거래 로직.
2.  **컴포넌트 조합 (Component Combination):** 여러 트리거와 액션의 논리적 연결.
3.  **아토믹 컴포넌트 (Atomic Components):** 시스템의 최소 기능 단위.
4.  **시장 데이터 (Market Data):** 모든 판단의 근거가 되는 데이터.

---

### ## 3. 주요 데이터 흐름 🔄

시스템의 데이터는 다음과 같은 명확한 흐름을 가집니다.

* **저장 흐름**: `사용자 UI 조작 → 내부 상태 업데이트 → ComponentStrategyManager → 데이터베이스`
* **로드 흐름**: `데이터베이스 → ComponentStrategyManager → UI 상태 복원 → 화면 렌더링`

여기서 **`ComponentStrategyManager`**는 UI와 데이터베이스 간의 데이터 교환을 총괄하는 핵심 비즈니스 로직입니다.

---

### ## 4. 포지션 관리 시스템 🏷️

전략 간의 충돌을 방지하고 안전한 거래를 보장하기 위해 **태그 기반 포지션 관리 시스템**을 도입합니다.

* **포지션 태그 종류**
    * **AUTO**: 자동 전략 전용 포지션으로, 수동 조작이 금지됩니다.
    * **MANUAL**: 수동 조작 전용 포지션으로, 자동 전략의 접근이 금지됩니다.
    * **HYBRID**: 자동 전략과 수동 조작이 모두 허용되는 혼합 관리 포지션입니다.
    * **LOCKED**: 안전을 위해 모든 자동/수동 조작이 금지된 잠금 포지션입니다.

이러한 접근 제어 매트릭스는 자동 매매 실행 중 사용자의 갑작스러운 개입으로 인해 발생하는 로직 붕괴를 원천적으로 차단하는 핵심적인 안전장치입니다.

---

# 바이브 코딩 에이전트 전달 문서 2/3: 기술 참조 매뉴얼

---

### ## 1. 컴포넌트 카탈로그 (Component Catalog) 🧩

이 시스템에서 사용할 수 있는 모든 아토믹 컴포넌트의 목록입니다. 각 컴포넌트는 독립적인 기능을 수행하는 최소 단위의 부품입니다.

#### **1.1. 트리거 컴포넌트 (Trigger Components)**

> 특정 조건 만족 시 신호를 발생시키는 컴포넌트.

* **Price 카테고리**
    * `PriceChangeTrigger`: 가격 변동율 감지
    * `PriceBreakoutTrigger`: 가격 범위 돌파 감지
    * `PriceCrossoverTrigger`: 가격 기준선 교차 감지
* **Indicator 카테고리**
    * `RSITrigger`: RSI 과매수/과매도 감지
    * `MACDTrigger`: MACD 시그널 감지
    * `BollingerBandTrigger`: 볼린저 밴드 터치 감지
    * `MovingAverageCrossTrigger`: 이동평균 교차 감지
* **Time 카테고리**
    * `PeriodicTrigger`: 주기적 실행
    * `ScheduledTrigger`: 특정 시간 실행
    * `DelayTrigger`: 지연 후 실행
* **Volume 카테고리**
    * `VolumeSurgeTrigger`: 거래량 급증 감지
    * `VolumeDropTrigger`: 거래량 급락 감지
    * `RelativeVolumeTrigger`: 상대적 거래량 감지
    * `VolumeBreakoutTrigger`: 거래량 돌파 감지
* **Position 카테고리**
    * `ProfitLossTrigger`: 수익/손실률 감지 (트레일링 기능 포함)
* **Special 카테고리**
    * `RapidPriceDropTrigger`: 단기 가격 급락 감지
    * `RapidPriceSpikeTrigger`: 단기 가격 급등 감지

#### **1.2. 액션 컴포넌트 (Action Components)**

> 트리거 발생 시 실제 행동을 수행하는 컴포넌트.

* **거래 액션**
    * `MarketBuyAction`: 시장가 매수
    * `MarketSellAction`: 시장가 매도
    * `PositionCloseAction`: 포지션 청산
    * `AdditionalBuy`: 추가 매수 (물타기/불타기)
* **메타 액션 (Meta Actions)**
    * `ModifyContextAction`: 실행 컨텍스트의 상태 플래그를 변경

#### **1.3. 조건 컴포넌트 (Condition Components)**

> 트리거와 액션 사이의 추가 검증 로직.

* **검증 조건**
    * `ExecutionCountCondition`: 특정 규칙의 실행 횟수 검증
    * `ContextCondition`: 실행 컨텍스트의 플래그 상태 검증

---

### ## 2. 핵심 클래스 구조 🏛️

시스템 구동에 필요한 최소한의 필수 클래스 구조입니다.

* **`BaseTrigger` / `BaseAction` / `BaseCondition`**: 모든 컴포넌트가 상속받는 추상 기반 클래스. `evaluate()` 또는 `execute()`와 같은 행동 규약을 정의합니다.
* **`StrategyRule`**: `트리거`, `조건`, `액션` 컴포넌트 객체와 `활성화 상태`, `우선순위`를 하나로 묶는 데이터 컨테이너 클래스입니다.
* **`Position`**: `state`, `average_price`, `quantity` 등 자신의 상태와 데이터를 관리하는 상태 머신(State Machine) 객체입니다.
* **`ExecutionEngine`**: 시장 데이터를 받아, `Position`의 상태에 맞는 `StrategyRule`들을 평가하고 최종 액션을 실행하는 시스템의 심장입니다.

---

### ## 3. 데이터베이스 스키마 💾

컴포넌트 기반 전략의 유연성을 위해, 핵심 데이터는 TEXT 필드에 JSON 형식으로 저장됩니다.

* **`component_strategy`**: 사용자가 '전략 메이커'에서 생성한 전략의 정의를 저장합니다.
    ```sql
    CREATE TABLE component_strategy (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        -- 트리거, 액션, 연결 정보를 JSON 배열 형태로 저장
        triggers TEXT,
        actions TEXT,
        connections TEXT,
        tags TEXT,
        is_active BOOLEAN DEFAULT FALSE,
        created_at DATETIME,
        updated_at DATETIME
    );
    ```
* **`strategy_execution`**: 전략이 실행될 때마다의 기록을 저장합니다.
    ```sql
    CREATE TABLE strategy_execution (
        id TEXT PRIMARY KEY,
        strategy_id TEXT REFERENCES component_strategy(id),
        trigger_type TEXT,
        action_type TEXT,
        result TEXT, -- SUCCESS, FAILED, SKIPPED
        position_tag TEXT,
        executed_at DATETIME
    );
    ```

---

### ## 4. 포지션 상태 머신 (Position State Machine) ⚙️

모든 포지션은 다음 3가지 상태 중 하나를 가지며, 이 상태에 따라 실행 엔진이 활성화하는 규칙이 달라집니다.

* **`READY` (대기 상태)**
    * **설명**: 포지션이 없으며 진입 신호를 기다리는 초기 상태입니다.
    * **활성화 규칙**: `ENTRY` 역할을 가진 규칙만이 작동합니다.

* **`ACTIVE` (보유 상태)**
    * **설명**: 코인을 보유 중이며, 수익 관리, 리스크 관리, 청산 신호를 기다리는 상태입니다.
    * **활성화 규칙**: `SCALE_IN`, `SCALE_OUT`, `EXIT`, `MANAGEMENT` 역할을 가진 모든 규칙이 동시에 작동합니다.

* **`CLOSED` (청산 상태)**
    * **설명**: 포지션이 모두 청산되어 하나의 매매 사이클이 종료된 상태입니다.
    * **활성화 규칙**: 모든 규칙이 비활성화되며, 최종 성과를 기록하고 다음 사이클을 위해 `READY` 상태로 돌아갈 수 있습니다.

---

# 바이브 코딩 에이전트 전달 문서 3/3: 구현 가이드 및 예제

---

### ## 1. UI 구현 가이드: 전략 메이커 🎨

사용자가 컴포넌트를 조합하여 시각적으로 전략을 구축하는 '전략 메이커' UI는 다음 핵심 요소로 구성됩니다.

* **3-Panel 구조**:
    1.  **컴포넌트 팔레트 (좌측)**: 사용 가능한 모든 `트리거`, `액션`, `조건` 컴포넌트들을 카테고리별로 보여주는 목록입니다.
    2.  **전략 캔버스 (중앙)**: 사용자가 팔레트에서 컴포넌트를 드래그 & 드롭하여 배치하고, 컴포넌트 간의 논리적 흐름을 시각적으로 연결하는 작업 공간입니다.
    3.  **설정 패널 (우측)**: 캔버스에서 특정 컴포넌트를 선택했을 때, 해당 컴포넌트의 상세 파라미터(e.g., RSI 기간, 매수 비율 등)를 설정하는 동적 폼입니다.

* **드래그 & 드롭 인터페이스**:
    사용자는 마우스操作만으로 컴포넌트를 캔버스에 추가하고, 각 컴포넌트의 입출력 포트를 연결하여 복잡한 실행 순서와 조건을 구성할 수 있습니다.

---

### ## 2. 완성된 전략 템플릿 (JSON) 📜

지금까지 우리가 함께 설계한 **'7규칙 최종 전략'**의 완전한 데이터 구조입니다. 이는 시스템이 저장하고 실행하는 전략의 가장 완벽한 실전 예제입니다.

```json
{
  "strategy_id": "ADV_RSI_PYRAMID_V1",
  "strategy_name": "RSI 진입 후 지능형 관리 전략",
  "rules": [
    {
      "rule_id": "rule_1_entry_rsi_oversold",
      "priority": 10,
      "activation_state": "READY",
      "trigger": {"component": "RSITrigger", "config": {"period": 14, "threshold": 20, "direction": "below"}},
      "action": {"component": "MarketBuyAction", "config": {"amount_percent": 10, "position_tag": "AUTO"}}
    },
    {
      "rule_id": "rule_2_scale_in_on_profit",
      "priority": 10,
      "activation_state": "ACTIVE",
      "trigger": {"component": "ProfitLossTrigger", "config": {"profit_percent": 5, "direction": "above"}},
      "conditions": [
        {"component": "ExecutionCountCondition", "config": {"target_rule_id": "rule_2_scale_in_on_profit", "less_than": 3}},
        {"component": "ContextCondition", "config": {"check_flag": "is_pyramiding_paused", "is_value": false}}
      ],
      "action": {"component": "AdditionalBuy", "config": {"amount": 100000}}
    },
    {
      "rule_id": "rule_3_exit_after_pyramiding",
      "priority": 9,
      "activation_state": "ACTIVE",
      "trigger": {"component": "ProfitLossTrigger", "config": {"profit_percent": 5, "direction": "above"}},
      "conditions": [
        {"component": "ExecutionCountCondition", "config": {"target_rule_id": "rule_2_scale_in_on_profit", "equal_to": 3}}
      ],
      "action": {"component": "FullPositionSell", "config": {}}
    },
    {
      "rule_id": "rule_4_exit_trailing_stop",
      "priority": 9,
      "activation_state": "ACTIVE",
      "trigger": {"component": "ProfitLossTrigger", "config": {"activation_profit_percent": 5, "trail_percent": 3}},
      "action": {"component": "FullPositionSell", "config": {}}
    },
    {
      "rule_id": "rule_5_downward_averaging",
      "priority": 10,
      "activation_state": "ACTIVE",
      "trigger": {"component": "PriceChangeTrigger", "config": {"reference": "average_price", "change_percent": -5, "direction": "below"}},
      "conditions": [
        {"component": "ExecutionCountCondition", "config": {"target_rule_id": "rule_5_downward_averaging", "less_than": 2}}
      ],
      "action": {"component": "AdditionalBuy", "config": {"amount": 200000}}
    },
    {
      "rule_id": "rule_6_emergency_exit_on_crash",
      "priority": 0,
      "activation_state": "ACTIVE",
      "trigger": {"component": "RapidPriceDropTrigger", "config": {"drop_percent": -5, "time_frame_seconds": 60}},
      "action": {"component": "FullPositionSell", "config": {}}
    },
    {
      "rule_id": "rule_7_hold_pyramiding_on_spike",
      "priority": 1,
      "activation_state": "ACTIVE",
      "trigger": {"component": "RapidPriceSpikeTrigger", "config": {"spike_percent": 5, "time_frame_seconds": 60}},
      "action": {"component": "ModifyContextAction", "config": {"set_flag": "is_pyramiding_paused", "value": true}}
    }
  ]
}
````

-----

### \#\# 3. 복합 시나리오 실행 흐름 ⚙️

'급락' 상황에서 `ExecutionEngine`이 `우선순위`를 기반으로 여러 규칙의 충돌을 해결하는 과정입니다.

1.  **상황 발생**: 포지션이 `ACTIVE` 상태일 때, 시장이 폭락하여 단일 데이터 틱에 -6%의 가격 하락이 발생합니다.

2.  **규칙 동시 발동**: `ExecutionEngine`은 이 한 번의 실행 사이클에서 아래 두 규칙의 트리거가 모두 `True`임을 감지합니다.

      * **규칙 \#5 (물타기)**: 평단가 대비 -5% 이상 하락했으므로 발동.
      * **규칙 \#6 (급락 감지)**: 1분 내 -5% 이상 하락했으므로 발동.

3.  **실행 후보 수집**: 엔진은 발동된 `규칙 #5`와 `규칙 #6`을 '실행 후보 리스트'에 담습니다.

4.  **우선순위 정렬**: 엔진은 액션을 실행하기 전, 리스트를 각 규칙의 `priority` 값으로 정렬합니다. `규칙 #6`(priority: 0)이 `규칙 #5`(priority: 10-기본값)보다 앞에 위치하게 됩니다.

      * **정렬 후 리스트**: `[규칙 #6, 규칙 #5]`

5.  **최종 액션 선택 및 실행**: 엔진은 정렬된 리스트의 가장 첫 번째, 즉 우선순위가 가장 높은 **`규칙 #6`의 `FullPositionSell` 액션을 실행**합니다.

6.  **나머지 액션 무시**: 리스트에 남아있던 `규칙 #5`의 `AdditionalBuy` 액션은 이번 사이클에서 실행되지 않고 폐기됩니다.

이 과정을 통해 시스템은 위험한 상황에서 자산을 추가 투입하는 대신, 가장 안전한 '전량 매도'를 수행하여 리스크를 효과적으로 관리합니다.