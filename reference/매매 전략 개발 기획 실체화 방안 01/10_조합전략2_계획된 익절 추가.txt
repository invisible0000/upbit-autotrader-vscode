네, 문서 시리즈의 다음 장을 생성하겠습니다.

이전 조합(문서 \#9)에 **EXIT 규칙**을 추가하여, 하나의 완결된 매매 사이클을 만드는 예시입니다. **문서 \#10**입니다.

```markdown
# 문서 #10: 조합 예시 2 - 계획된 익절 추가 (규칙 #1 + #2 + #3)

---

### ## 1. 조합 구성 변경 (Combination Composition Change)

이전 `문서 #9`의 "진입+불타기" 조합은 청산 기능이 없어 불완전했습니다. 여기에 **'계획된 익절' 규칙을 추가**하여 완전한 전략으로 만듭니다.

* **기존 규칙**
    * **규칙 #1**: `RSI 과매도 진입 (ENTRY)`
    * **규칙 #2**: `수익 시 불타기 (SCALE_IN)`
* **새로 추가된 규칙**
    * **규칙 #3**: `계획된 익절 (EXIT)`

---

### ## 2. 핵심 상호작용: 조건 분기 (Core Interaction: Conditional Branching)

이 조합의 핵심은 `규칙 #2 (불타기)`와 `규칙 #3 (계획된 익절)`이 **동일한 `ProfitLossTrigger`를 공유**하지만, 서로 **배타적인 `ExecutionCountCondition`을 가지고 있다는 점**입니다. 이로 인해 시스템은 명확한 논리적 분기가 가능해집니다.

1.  **상황**: 포지션이 `ACTIVE` 상태이고, `ProfitLossTrigger`가 `5%` 수익 조건으로 발동했습니다.
2.  **`ExecutionEngine`의 동시 평가**: 엔진은 `규칙 #2`와 `규칙 #3`의 조건을 모두 검사합니다.
3.  **조건 분기**:
    * **만약 `규칙 #2`의 실행 횟수가 3회 미만이면:**
        * `규칙 #2`의 조건 통과 → `AdditionalBuy` 액션 실행.
        * `규칙 #3`의 조건 실패 → 무시.
    * **만약 `규칙 #2`의 실행 횟수가 정확히 3회이면:**
        * `규칙 #2`의 조건 실패 → 무시.
        * `규칙 #3`의 조건 통과 → `FullPositionSell` 액션 실행.

이처럼 `ExecutionCountCondition`은 두 규칙이 같은 신호에 반응하더라도, 상황에 따라 단 하나의 규칙만 실행되도록 보장하는 교통 경찰 역할을 합니다.

---

### ## 3. 시나리오: 불타기 완료 후 자동 청산

1.  **진입 및 불타기**: `규칙 #1`로 진입 후, `규칙 #2`가 3번 실행되어 불타기 과정이 모두 완료되었습니다. (`규칙 #2`의 실행 횟수 = 3)

2.  **다음 수익 신호 감시**: 포지션은 `ACTIVE` 상태로 유지되며, 엔진은 계속해서 모든 `ACTIVE` 규칙들을 감시합니다.

3.  **계획된 익절 발동**: 가격이 다시 한번 5% 수익 구간에 도달하여 `ProfitLossTrigger`가 발동합니다.

4.  **최종 결정**: 엔진은 `규칙 #2`와 `규칙 #3`을 평가합니다. `규칙 #2`의 실행 횟수가 3이므로 조건에 맞지 않아 실패하고, `규칙 #3`의 조건(`실행 횟수 == 3`)은 충족됩니다.

5.  **사이클 종료**: 엔진은 **`규칙 #3`의 `FullPositionSell` 액션을 실행**하여 포지션을 전량 매도합니다. 포지션 상태는 `CLOSED`로 변경됩니다.

> ✅ 이로써 **'진입 → 불타기 → 계획된 청산'**으로 이어지는 하나의 완결된 자동 매매 사이클이 완성되었습니다.
```