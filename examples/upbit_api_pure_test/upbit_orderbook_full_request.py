#!/usr/bin/env python3
"""
ÏóÖÎπÑÌä∏ Ticker Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏ Ïä§ÌÅ¨Î¶ΩÌä∏

Î™©Ï†Å:
- Î™®Îì† ÏóÖÎπÑÌä∏ ÎßàÏºìÏùò Ticker API Ìò∏Ï∂ú Í∞ÄÎä•ÏÑ± ÌÖåÏä§Ìä∏
- ÏÑ±Îä• ÏßÄÌëú Ï∏°Ï†ï (ÏùëÎãµÏãúÍ∞Ñ, Îç∞Ïù¥ÌÑ∞ Ïö©Îüâ, ÏÑ±Í≥µÎ•† Îì±)
- ÌååÏù¥Ïç¨ Í∏∞Î≥∏ ÎùºÏù¥Î∏åÎü¨Î¶¨Îßå ÏÇ¨Ïö©ÌïòÏó¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÎèÖÎ¶ΩÏ†Å Íµ¨ÌòÑ

Ï∞∏Í≥†: Ìò∏Í∞Ä APIÍ∞Ä ÌòÑÏû¨ Ïù∏Ï¶ùÏùÑ ÏöîÍµ¨ÌïòÎØÄÎ°ú Ticker APIÎ°ú ÎåÄÏ≤¥ÌïòÏó¨ ÌÖåÏä§Ìä∏

ÏÇ¨Ïö©Î≤ï:
python upbit_orderbook_full_request.py
"""

import json
import time
from urllib.request import urlopen, Request
from urllib.error import HTTPError, URLError
from datetime import datetime
import gzip
from typing import List, Dict, Any


class UpbitTickerTester:
    """ÏóÖÎπÑÌä∏ Ticker Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏ ÌÅ¥ÎûòÏä§"""

    BASE_URL = "https://api.upbit.com"
    MARKET_ALL_URL = f"{BASE_URL}/v1/market/all"
    TICKER_URL = f"{BASE_URL}/v1/ticker"

    def __init__(self):
        self.results = {
            'start_time': None,
            'end_time': None,
            'total_markets': 0,
            'successful_requests': 0,
            'failed_requests': 0,
            'total_response_time_ms': 0,
            'total_data_size_bytes': 0,
            'markets_data': [],
            'error_details': []
        }

    def get_all_markets(self) -> List[str]:
        """Î™®Îì† ÎßàÏºì Ïã¨Î≥º Ï°∞Ìöå"""
        print("üìä Î™®Îì† ÎßàÏºì Ïã¨Î≥º Ï°∞Ìöå Ï§ë...")

        try:
            request = Request(self.MARKET_ALL_URL)
            request.add_header('Accept', 'application/json')
            request.add_header('User-Agent', 'UpbitOrderbookTester/1.0')

            start_time = time.time()
            with urlopen(request, timeout=10) as response:
                response_time = (time.time() - start_time) * 1000

                # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ (gzip ÏïïÏ∂ï Ìï¥Ï†ú Í≥†Î†§)
                data = response.read()
                if response.info().get('Content-Encoding') == 'gzip':
                    data = gzip.decompress(data)

                markets_data = json.loads(data.decode('utf-8'))

            # ÎßàÏºì ÏΩîÎìúÎßå Ï∂îÏ∂ú
            market_symbols = [market['market'] for market in markets_data]

            print(f"‚úÖ ÎßàÏºì Ï°∞Ìöå ÏôÑÎ£å: {len(market_symbols)}Í∞ú")
            print(f"   ÏùëÎãµÏãúÍ∞Ñ: {response_time:.1f}ms")
            print(f"   Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {len(data):,} bytes")

            return market_symbols

        except Exception as e:
            print(f"‚ùå ÎßàÏºì Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []

    def get_all_tickers_with_gzip(self, markets: List[str]) -> Dict[str, Any]:
        """Î™®Îì† ÎßàÏºìÏùò Ticker Ï†ïÎ≥¥Î•º gzip ÏïïÏ∂ïÏúºÎ°ú Ï°∞Ìöå"""

        # ÏóÖÎπÑÌä∏ APIÎäî Ìïú Î≤àÏóê Ïó¨Îü¨ ÎßàÏºì Ï°∞Ìöå Í∞ÄÎä• (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)
        markets_param = ",".join(markets)
        url = f"{self.TICKER_URL}?markets={markets_param}"

        print(f"üóúÔ∏è gzip ÏïïÏ∂ï ÏöîÏ≤≠ URL: {url[:100]}..." if len(url) > 100 else f"üóúÔ∏è gzip ÏïïÏ∂ï ÏöîÏ≤≠ URL: {url}")
        print(f"üìä ÏöîÏ≤≠ ÎßàÏºì Ïàò: {len(markets)}Í∞ú")
        print(f"üìè URL Í∏∏Ïù¥: {len(url):,} Î¨∏Ïûê")

        try:
            request = Request(url)
            request.add_header('Accept', 'application/json')
            request.add_header('Accept-Encoding', 'gzip, deflate')  # gzip ÏïïÏ∂ï ÏöîÏ≤≠
            request.add_header('User-Agent', 'UpbitOrderbookTester/1.0')

            start_time = time.time()
            with urlopen(request, timeout=30) as response:  # ÌÉÄÏûÑÏïÑÏõÉ Ï¶ùÍ∞Ä
                response_time = (time.time() - start_time) * 1000

                # ÏùëÎãµ Ìó§Îçî ÌôïÏù∏
                content_encoding = response.info().get('Content-Encoding', '')
                content_length = response.info().get('Content-Length')

                # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                compressed_data = response.read()
                compressed_size = len(compressed_data)

                # gzip ÏïïÏ∂ï Ìï¥Ï†ú
                if 'gzip' in content_encoding.lower():
                    data = gzip.decompress(compressed_data)
                    original_size = len(data)
                    compression_ratio = (1 - compressed_size / original_size) * 100 if original_size > 0 else 0
                else:
                    data = compressed_data
                    original_size = compressed_size
                    compression_ratio = 0

                ticker_data = json.loads(data.decode('utf-8'))

                return {
                    'success': True,
                    'data': ticker_data,
                    'response_time_ms': response_time,
                    'compressed_size_bytes': compressed_size,
                    'original_size_bytes': original_size,
                    'compression_ratio': compression_ratio,
                    'content_encoding': content_encoding,
                    'markets_count': len(markets),
                    'received_count': len(ticker_data) if isinstance(ticker_data, list) else 1
                }

        except HTTPError as e:
            error_msg = f"HTTP {e.code}: {e.reason}"
            try:
                # ÏóêÎü¨ ÏùëÎãµ Î≥∏Î¨∏ ÏùΩÍ∏∞
                error_data = e.read().decode('utf-8')
                if error_data:
                    error_msg += f" - {error_data}"
            except Exception:
                pass

            return {
                'success': False,
                'error': error_msg,
                'response_time_ms': 0,
                'compressed_size_bytes': 0,
                'original_size_bytes': 0,
                'compression_ratio': 0,
                'content_encoding': '',
                'markets_count': len(markets),
                'received_count': 0
            }
        except URLError as e:
            return {
                'success': False,
                'error': f"Network error: {e.reason}",
                'response_time_ms': 0,
                'compressed_size_bytes': 0,
                'original_size_bytes': 0,
                'compression_ratio': 0,
                'content_encoding': '',
                'markets_count': len(markets),
                'received_count': 0
            }
        except Exception as e:
            return {
                'success': False,
                'error': f"Unexpected error: {str(e)}",
                'response_time_ms': 0,
                'compressed_size_bytes': 0,
                'original_size_bytes': 0,
                'compression_ratio': 0,
                'content_encoding': '',
                'markets_count': len(markets),
                'received_count': 0
            }

    def get_all_tickers(self, markets: List[str]) -> Dict[str, Any]:
        """Î™®Îì† ÎßàÏºìÏùò Ticker Ï†ïÎ≥¥Î•º ÌïúÎ≤àÏóê Ï°∞Ìöå"""

        # ÏóÖÎπÑÌä∏ APIÎäî Ìïú Î≤àÏóê Ïó¨Îü¨ ÎßàÏºì Ï°∞Ìöå Í∞ÄÎä• (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)
        markets_param = ",".join(markets)
        url = f"{self.TICKER_URL}?markets={markets_param}"

        print(f"üåê ÏöîÏ≤≠ URL: {url[:100]}..." if len(url) > 100 else f"üåê ÏöîÏ≤≠ URL: {url}")
        print(f"üìä ÏöîÏ≤≠ ÎßàÏºì Ïàò: {len(markets)}Í∞ú")
        print(f"üìè URL Í∏∏Ïù¥: {len(url):,} Î¨∏Ïûê")

        try:
            request = Request(url)
            request.add_header('Accept', 'application/json')
            request.add_header('User-Agent', 'UpbitOrderbookTester/1.0')

            start_time = time.time()
            with urlopen(request, timeout=30) as response:  # ÌÉÄÏûÑÏïÑÏõÉ Ï¶ùÍ∞Ä
                response_time = (time.time() - start_time) * 1000

                # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                data = response.read()
                if response.info().get('Content-Encoding') == 'gzip':
                    data = gzip.decompress(data)

                orderbook_data = json.loads(data.decode('utf-8'))

                return {
                    'success': True,
                    'data': orderbook_data,
                    'response_time_ms': response_time,
                    'data_size_bytes': len(data),
                    'markets_count': len(markets),
                    'received_count': len(orderbook_data) if isinstance(orderbook_data, list) else 1
                }

        except HTTPError as e:
            error_msg = f"HTTP {e.code}: {e.reason}"
            try:
                # ÏóêÎü¨ ÏùëÎãµ Î≥∏Î¨∏ ÏùΩÍ∏∞
                error_data = e.read().decode('utf-8')
                if error_data:
                    error_msg += f" - {error_data}"
            except Exception:
                pass

            return {
                'success': False,
                'error': error_msg,
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'markets_count': len(markets),
                'received_count': 0
            }
        except URLError as e:
            return {
                'success': False,
                'error': f"Network error: {e.reason}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'markets_count': len(markets),
                'received_count': 0
            }
        except Exception as e:
            return {
                'success': False,
                'error': f"Unexpected error: {str(e)}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'markets_count': len(markets),
                'received_count': 0
            }

    def analyze_ticker_data(self, ticker_data: List[Dict]) -> Dict[str, Any]:
        """Ticker Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        if not ticker_data:
            return {'total_markets': 0, 'analysis': 'No data'}

        analysis = {
            'markets_analyzed': len(ticker_data),
            'price_ranges': {
                'krw_markets': [],
                'btc_markets': [],
                'usdt_markets': []
            },
            'volume_stats': [],
            'change_rates': []
        }

        for ticker in ticker_data:
            market = ticker.get('market', '')
            trade_price = float(ticker.get('trade_price', 0))
            change_rate = float(ticker.get('change_rate', 0))
            acc_trade_volume_24h = float(ticker.get('acc_trade_volume_24h', 0))

            # ÎßàÏºìÎ≥Ñ Î∂ÑÎ•ò
            if market.startswith('KRW-'):
                analysis['price_ranges']['krw_markets'].append(trade_price)
            elif market.startswith('BTC-'):
                analysis['price_ranges']['btc_markets'].append(trade_price)
            elif market.startswith('USDT-'):
                analysis['price_ranges']['usdt_markets'].append(trade_price)

            analysis['volume_stats'].append(acc_trade_volume_24h)
            analysis['change_rates'].append(change_rate * 100)  # ÌçºÏÑºÌä∏Î°ú Î≥ÄÌôò

        # ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        analysis['avg_change_rate'] = sum(analysis['change_rates']) / len(analysis['change_rates']) if analysis['change_rates'] else 0
        analysis['avg_volume'] = sum(analysis['volume_stats']) / len(analysis['volume_stats']) if analysis['volume_stats'] else 0

        # ÎßàÏºìÎ≥Ñ ÌèâÍ∑† Í∞ÄÍ≤©
        for market_type, prices in analysis['price_ranges'].items():
            if prices:
                analysis[f'avg_price_{market_type}'] = sum(prices) / len(prices)
                analysis[f'count_{market_type}'] = len(prices)
            else:
                analysis[f'avg_price_{market_type}'] = 0
                analysis[f'count_{market_type}'] = 0

        return analysis

    def analyze_orderbook_data(self, orderbook_data: List[Dict]) -> Dict[str, Any]:
        """Ìò∏Í∞Ä Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        if not orderbook_data:
            return {'total_levels': 0, 'avg_spread': 0, 'analysis': 'No data'}

        analysis = {
            'markets_analyzed': len(orderbook_data),
            'total_orderbook_levels': 0,
            'spreads': [],
            'bid_volumes': [],
            'ask_volumes': []
        }

        for orderbook in orderbook_data:
            if 'orderbook_units' in orderbook:
                levels = len(orderbook['orderbook_units'])
                analysis['total_orderbook_levels'] += levels

                # Ï≤´ Î≤àÏß∏ Î†àÎ≤®Ïùò Ïä§ÌîÑÎ†àÎìú Í≥ÑÏÇ∞
                if levels > 0:
                    first_level = orderbook['orderbook_units'][0]
                    bid_price = float(first_level['bid_price'])
                    ask_price = float(first_level['ask_price'])
                    spread = ask_price - bid_price
                    spread_percent = (spread / bid_price) * 100 if bid_price > 0 else 0

                    analysis['spreads'].append(spread_percent)
                    analysis['bid_volumes'].append(float(first_level['bid_size']))
                    analysis['ask_volumes'].append(float(first_level['ask_size']))

        # ÌèâÍ∑†Í∞í Í≥ÑÏÇ∞
        if analysis['spreads']:
            analysis['avg_spread_percent'] = sum(analysis['spreads']) / len(analysis['spreads'])
            analysis['avg_bid_volume'] = sum(analysis['bid_volumes']) / len(analysis['bid_volumes'])
            analysis['avg_ask_volume'] = sum(analysis['ask_volumes']) / len(analysis['ask_volumes'])
        else:
            analysis['avg_spread_percent'] = 0
            analysis['avg_bid_volume'] = 0
            analysis['avg_ask_volume'] = 0

        return analysis

    def run_gzip_comparison_test(self) -> None:
        """gzip ÏïïÏ∂ï ÏÑ±Îä• ÎπÑÍµê ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
        print("üöÄ ÏóÖÎπÑÌä∏ Ticker API gzip ÏïïÏ∂ï ÏÑ±Îä• ÎπÑÍµê ÌÖåÏä§Ìä∏ ÏãúÏûë")
        print("=" * 60)

        self.results['start_time'] = datetime.now()

        # 1. Î™®Îì† ÎßàÏºì Ï°∞Ìöå
        markets = self.get_all_markets()
        if not markets:
            print("‚ùå ÎßàÏºì Ï°∞Ìöå Ïã§Ìå®Î°ú ÌÖåÏä§Ìä∏ Ï§ëÎã®")
            return

        self.results['total_markets'] = len(markets)

        # 2. ÏùºÎ∞ò ÏöîÏ≤≠ ÌÖåÏä§Ìä∏
        print(f"\nüìã 1. ÏùºÎ∞ò ÏöîÏ≤≠ ÌÖåÏä§Ìä∏ (gzip ÏïïÏ∂ï ÏóÜÏùå)")
        print(f"   üìä Ï¥ù ÎßàÏºì Ïàò: {len(markets)}Í∞ú")
        normal_result = self.get_all_tickers(markets)

        # 3. gzip ÏïïÏ∂ï ÏöîÏ≤≠ ÌÖåÏä§Ìä∏
        print(f"\nüìã 2. gzip ÏïïÏ∂ï ÏöîÏ≤≠ ÌÖåÏä§Ìä∏")
        print(f"   üìä Ï¥ù ÎßàÏºì Ïàò: {len(markets)}Í∞ú")
        gzip_result = self.get_all_tickers_with_gzip(markets)

        # 4. ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù
        self.analyze_performance_comparison(normal_result, gzip_result)

        self.results['end_time'] = datetime.now()

        # 5. ÎπÑÍµê Í≤∞Í≥º Ï∂úÎ†•
        self.print_comparison_results(normal_result, gzip_result)

    def analyze_performance_comparison(self, normal_result: Dict[str, Any], gzip_result: Dict[str, Any]) -> None:
        """ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù"""
        comparison = {
            'normal_request': {
                'success': normal_result['success'],
                'response_time_ms': normal_result['response_time_ms'],
                'data_size_bytes': normal_result.get('data_size_bytes', 0),
                'markets_count': normal_result['received_count'] if normal_result['success'] else 0
            },
            'gzip_request': {
                'success': gzip_result['success'],
                'response_time_ms': gzip_result['response_time_ms'],
                'compressed_size_bytes': gzip_result.get('compressed_size_bytes', 0),
                'original_size_bytes': gzip_result.get('original_size_bytes', 0),
                'compression_ratio': gzip_result.get('compression_ratio', 0),
                'content_encoding': gzip_result.get('content_encoding', ''),
                'markets_count': gzip_result['received_count'] if gzip_result['success'] else 0
            }
        }

        # ÏÑ±Îä• Í∞úÏÑ† Í≥ÑÏÇ∞
        if normal_result['success'] and gzip_result['success']:
            # ÏùëÎãµ ÏãúÍ∞Ñ ÎπÑÍµê
            time_improvement = (normal_result['response_time_ms'] - gzip_result['response_time_ms']) / normal_result['response_time_ms'] * 100

            # Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ ÎπÑÍµê (ÏïïÏ∂ï Ìö®Í≥º)
            normal_size = normal_result.get('data_size_bytes', 0)
            gzip_compressed_size = gzip_result.get('compressed_size_bytes', 0)
            if normal_size > 0:
                bandwidth_savings = (normal_size - gzip_compressed_size) / normal_size * 100
            else:
                bandwidth_savings = 0

            comparison['performance_metrics'] = {
                'time_improvement_percent': time_improvement,
                'bandwidth_savings_percent': bandwidth_savings,
                'bytes_saved': normal_size - gzip_compressed_size
            }

        self.results['gzip_comparison'] = comparison

    def print_comparison_results(self, normal_result: Dict[str, Any], gzip_result: Dict[str, Any]) -> None:
        """gzip ÏïïÏ∂ï ÎπÑÍµê Í≤∞Í≥º Ï∂úÎ†•"""
        print("\n" + "=" * 60)
        print("üìä gzip ÏïïÏ∂ï ÏÑ±Îä• ÎπÑÍµê Í≤∞Í≥º")
        print("=" * 60)

        if not (normal_result['success'] and gzip_result['success']):
            print("‚ùå ÏùºÎ∂Ä ÏöîÏ≤≠Ïù¥ Ïã§Ìå®ÌïòÏó¨ ÎπÑÍµêÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
            if not normal_result['success']:
                print(f"   ÏùºÎ∞ò ÏöîÏ≤≠ Ïã§Ìå®: {normal_result.get('error', 'Unknown error')}")
            if not gzip_result['success']:
                print(f"   gzip ÏöîÏ≤≠ Ïã§Ìå®: {gzip_result.get('error', 'Unknown error')}")
            return

        print("üéØ **ÏùëÎãµ ÏãúÍ∞Ñ ÎπÑÍµê**")
        normal_time = normal_result['response_time_ms']
        gzip_time = gzip_result['response_time_ms']
        time_diff = normal_time - gzip_time
        time_improvement = (time_diff / normal_time * 100) if normal_time > 0 else 0

        print(f"   ÏùºÎ∞ò ÏöîÏ≤≠:     {normal_time:.1f}ms")
        print(f"   gzip ÏïïÏ∂ï:     {gzip_time:.1f}ms")
        print(f"   ÏãúÍ∞Ñ Ï∞®Ïù¥:     {time_diff:+.1f}ms")
        print(f"   ÏÑ±Îä• Í∞úÏÑ†:     {time_improvement:+.1f}%")

        print("\nüíæ **Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ ÎπÑÍµê**")
        normal_size = normal_result.get('data_size_bytes', 0)
        compressed_size = gzip_result.get('compressed_size_bytes', 0)
        original_size = gzip_result.get('original_size_bytes', 0)
        compression_ratio = gzip_result.get('compression_ratio', 0)

        print(f"   ÏùºÎ∞ò ÏöîÏ≤≠:     {normal_size:,} bytes ({normal_size/1024:.1f} KB)")
        print(f"   ÏïïÏ∂ïÎêú ÌÅ¨Í∏∞:   {compressed_size:,} bytes ({compressed_size/1024:.1f} KB)")
        print(f"   ÏõêÎ≥∏ ÌÅ¨Í∏∞:     {original_size:,} bytes ({original_size/1024:.1f} KB)")
        print(f"   ÏïïÏ∂ï ÎπÑÏú®:     {compression_ratio:.1f}%")

        if normal_size > 0 and compressed_size > 0:
            bandwidth_savings = (normal_size - compressed_size) / normal_size * 100
            bytes_saved = normal_size - compressed_size
            print(f"   ÎåÄÏó≠Ìè≠ Ï†àÏïΩ:   {bandwidth_savings:.1f}% ({bytes_saved:,} bytes)")

        print("\nüåê **ÏÑúÎ≤Ñ ÏùëÎãµ Ï†ïÎ≥¥**")
        content_encoding = gzip_result.get('content_encoding', '')
        print(f"   Content-Encoding: {content_encoding}")
        print(f"   gzip ÏßÄÏõê:     {'‚úÖ ÏßÄÏõêÎê®' if 'gzip' in content_encoding.lower() else '‚ùå ÏßÄÏõêÎêòÏßÄ ÏïäÏùå'}")

        print("\nüìà **Ï¢ÖÌï© ÌèâÍ∞Ä**")
        if compression_ratio > 70:
            compression_grade = "üü¢ Ïö∞Ïàò"
        elif compression_ratio > 50:
            compression_grade = "üü° ÏñëÌò∏"
        elif compression_ratio > 30:
            compression_grade = "üü† Î≥¥ÌÜµ"
        else:
            compression_grade = "üî¥ ÎÇÆÏùå"

        print(f"   ÏïïÏ∂ï Ìö®Ïú®:     {compression_grade} ({compression_ratio:.1f}%)")

        if time_improvement > 10:
            speed_grade = "üü¢ Îπ†Î¶Ñ"
        elif time_improvement > 0:
            speed_grade = "üü° ÏïΩÍ∞Ñ Îπ†Î¶Ñ"
        elif time_improvement > -10:
            speed_grade = "üü† ÎπÑÏä∑Ìï®"
        else:
            speed_grade = "üî¥ ÎäêÎ¶º"

        print(f"   ÏÜçÎèÑ Í∞úÏÑ†:     {speed_grade} ({time_improvement:+.1f}%)")

        # Í∂åÏû•ÏÇ¨Ìï≠
        if compression_ratio > 50 and time_improvement > -5:
            recommendation = "‚úÖ gzip ÏïïÏ∂ï ÏÇ¨Ïö© Í∂åÏû•"
        elif compression_ratio > 30:
            recommendation = "üü° ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ Ïãú gzip ÏïïÏ∂ï Í≥†Î†§"
        else:
            recommendation = "‚ùå gzip ÏïïÏ∂ï Ìö®Í≥º Ï†úÌïúÏ†Å"

        print(f"   Í∂åÏû•ÏÇ¨Ìï≠:     {recommendation}")

    def run_full_test(self) -> None:
        """Ï†ÑÏ≤¥ ÌÖåÏä§Ìä∏ Ïã§Ìñâ - Î™®Îì† ÎßàÏºìÏùÑ ÌïúÎ≤àÏóê ÏöîÏ≤≠"""
        print("üöÄ ÏóÖÎπÑÌä∏ Ìò∏Í∞Ä Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏ ÏãúÏûë")
        print("=" * 60)

        self.results['start_time'] = datetime.now()

        # 1. Î™®Îì† ÎßàÏºì Ï°∞Ìöå
        markets = self.get_all_markets()
        if not markets:
            print("‚ùå ÎßàÏºì Ï°∞Ìöå Ïã§Ìå®Î°ú ÌÖåÏä§Ìä∏ Ï§ëÎã®")
            return

        self.results['total_markets'] = len(markets)

        # 2. Î™®Îì† ÎßàÏºìÏùò TickerÎ•º ÌïúÎ≤àÏóê Ï°∞Ìöå (Ìò∏Í∞Ä APIÎäî Ïù∏Ï¶ù ÌïÑÏöî)
        print(f"\nüìã Î™®Îì† ÎßàÏºì Ticker Îç∞Ïù¥ÌÑ∞ ÌïúÎ≤àÏóê Ï°∞Ìöå")
        print(f"   üìä Ï¥ù ÎßàÏºì Ïàò: {len(markets)}Í∞ú")
        print(f"   üéØ ÌÖåÏä§Ìä∏ Î™©Ï†Å: API ÌïúÍ≥Ñ Î∞è ÏÑ±Îä• Ï∏°Ï†ï")
        print(f"   ‚ö†Ô∏è  Ï∞∏Í≥†: Ìò∏Í∞Ä APIÎäî Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌïòÎØÄÎ°ú Ticker APIÎ°ú ÎåÄÏ≤¥")

        result = self.get_all_tickers(markets)

        # Í≤∞Í≥º ÎàÑÏ†Å
        if result['success']:
            self.results['successful_requests'] = result['received_count']
            self.results['failed_requests'] = 0
            all_ticker_data = result['data'] if isinstance(result['data'], list) else [result['data']]
            print(f"   ‚úÖ ÏÑ±Í≥µ: {result['received_count']}Í∞ú ÎßàÏºì ÏùëÎãµ Î∞õÏùå")

            # Ticker Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
            print("\nüîç Ticker Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ï§ë...")
            analysis = self.analyze_ticker_data(all_ticker_data)
            self.results['ticker_analysis'] = analysis

        else:
            self.results['successful_requests'] = 0
            self.results['failed_requests'] = result['markets_count']
            self.results['error_details'].append({
                'request_type': 'single_bulk_request',
                'markets_count': result['markets_count'],
                'error': result['error']
            })
            print(f"   ‚ùå Ïã§Ìå®: {result['error']}")

        self.results['total_response_time_ms'] = result['response_time_ms']
        self.results['total_data_size_bytes'] = result['data_size_bytes']

        print(f"   ‚è±Ô∏è  ÏùëÎãµÏãúÍ∞Ñ: {result['response_time_ms']:.1f}ms")
        print(f"   üíæ Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {result['data_size_bytes']:,} bytes")

        self.results['end_time'] = datetime.now()

        # 4. Í≤∞Í≥º Ï∂úÎ†•
        self.print_results()

    def print_results(self) -> None:
        """ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï∂úÎ†•"""
        print("\n" + "=" * 60)
        print("üìä ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ")
        print("=" * 60)

        # Í∏∞Î≥∏ ÌÜµÍ≥Ñ
        total_duration = (self.results['end_time'] - self.results['start_time']).total_seconds()
        success_rate = (
            (self.results['successful_requests'] / self.results['total_markets'] * 100)
            if self.results['total_markets'] > 0 else 0
        )

        print("üéØ **Í∏∞Î≥∏ ÌÜµÍ≥Ñ**")
        print(f"   Ï†ÑÏ≤¥ ÎßàÏºì Ïàò: {self.results['total_markets']:,}Í∞ú")
        print(f"   ÏÑ±Í≥µÌïú ÏöîÏ≤≠: {self.results['successful_requests']:,}Í∞ú")
        print(f"   Ïã§Ìå®Ìïú ÏöîÏ≤≠: {self.results['failed_requests']:,}Í∞ú")
        print(f"   ÏÑ±Í≥µÎ•†: {success_rate:.1f}%")

        print("\n‚è±Ô∏è  **ÏÑ±Îä• ÏßÄÌëú**")
        print(f"   Ï¥ù ÏÜåÏöîÏãúÍ∞Ñ: {total_duration:.1f}Ï¥à")
        print(f"   Ï¥ù ÏùëÎãµÏãúÍ∞Ñ: {self.results['total_response_time_ms']:,.0f}ms")
        print(f"   Îã®Ïùº ÏöîÏ≤≠ ÏùëÎãµÏãúÍ∞Ñ: {self.results['total_response_time_ms']:.1f}ms")
        print(f"   Ï≤òÎ¶¨Ïú®: {self.results['total_markets'] / total_duration:.1f} ÎßàÏºì/Ï¥à")

        print("\nüíæ **Îç∞Ïù¥ÌÑ∞ Ïö©Îüâ**")
        data_size_mb = self.results['total_data_size_bytes'] / (1024 * 1024)
        data_size_kb = self.results['total_data_size_bytes'] / 1024
        avg_size_per_market = (
            self.results['total_data_size_bytes'] / self.results['successful_requests']
            if self.results['successful_requests'] > 0 else 0
        )

        print(f"   Ï¥ù Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {self.results['total_data_size_bytes']:,} bytes")
        print(f"                  {data_size_kb:.1f} KB")
        print(f"                  {data_size_mb:.2f} MB")
        print(f"   ÎßàÏºìÎãπ ÌèâÍ∑† ÌÅ¨Í∏∞: {avg_size_per_market:.0f} bytes")

        # Ticker Î∂ÑÏÑù Í≤∞Í≥º
        if 'ticker_analysis' in self.results:
            analysis = self.results['ticker_analysis']
            print(f"\nüìä **Ticker Î∂ÑÏÑù**")
            print(f"   Î∂ÑÏÑùÎêú ÎßàÏºì: {analysis['markets_analyzed']:,}Í∞ú")
            print(f"   KRW ÎßàÏºì: {analysis['count_krw_markets']}Í∞ú (ÌèâÍ∑†Í∞Ä: {analysis['avg_price_krw_markets']:,.0f}Ïõê)")
            print(f"   BTC ÎßàÏºì: {analysis['count_btc_markets']}Í∞ú (ÌèâÍ∑†Í∞Ä: {analysis['avg_price_btc_markets']:.8f})")
            print(f"   USDT ÎßàÏºì: {analysis['count_usdt_markets']}Í∞ú (ÌèâÍ∑†Í∞Ä: {analysis['avg_price_usdt_markets']:.4f})")
            print(f"   ÌèâÍ∑† Î≥ÄÌôîÏú®: {analysis['avg_change_rate']:.2f}%")
            print(f"   ÌèâÍ∑† Í±∞ÎûòÎüâ: {analysis['avg_volume']:.2f}")

        # Ìò∏Í∞Ä Î∂ÑÏÑù Í≤∞Í≥º (Î†àÍ±∞Ïãú ÏΩîÎìú - Ïã§Ï†úÎ°úÎäî ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå)
        if 'orderbook_analysis' in self.results:
            analysis = self.results['orderbook_analysis']
            print(f"\nüìã **Ìò∏Í∞Ä Î∂ÑÏÑù**")
            print(f"   Î∂ÑÏÑùÎêú ÎßàÏºì: {analysis['markets_analyzed']:,}Í∞ú")
            print(f"   Ï¥ù Ìò∏Í∞Ä Î†àÎ≤®: {analysis['total_orderbook_levels']:,}Í∞ú")
            print(f"   ÌèâÍ∑† Ïä§ÌîÑÎ†àÎìú: {analysis['avg_spread_percent']:.3f}%")
            print(f"   ÌèâÍ∑† Îß§Ïàò Î¨ºÎüâ: {analysis['avg_bid_volume']:.2f}")
            print(f"   ÌèâÍ∑† Îß§ÎèÑ Î¨ºÎüâ: {analysis['avg_ask_volume']:.2f}")

        # Rate Limit Î∂ÑÏÑù
        total_requests = 1 if self.results['total_markets'] > 0 else 0  # Îã®Ïùº ÏöîÏ≤≠
        requests_per_second = total_requests / total_duration if total_duration > 0 else 0
        print("\nüö¶ **Rate Limit Î∂ÑÏÑù**")
        print(f"   Ïã§Ï†ú ÏöîÏ≤≠ ÌöüÏàò: {total_requests}Ìöå (Îã®Ïùº ÎåÄÏö©Îüâ ÏöîÏ≤≠)")
        print(f"   Ï¥àÎãπ ÏöîÏ≤≠ Ïàò: {requests_per_second:.2f}Ìöå/Ï¥à")
        print("   ÏóÖÎπÑÌä∏ Ï†úÌïú: 10Ìöå/Ï¥à")
        print(f"   Ï†úÌïú Ï§ÄÏàò: {'‚úÖ Ï§ÄÏàò' if requests_per_second <= 10 else '‚ùå Ï¥àÍ≥º'}")

        # ÏóêÎü¨ ÏÉÅÏÑ∏
        if self.results['error_details']:
            print("\n‚ùå **ÏóêÎü¨ ÏÉÅÏÑ∏**")
            for error in self.results['error_details']:
                if 'request_type' in error:  # Îã®Ïùº ÏöîÏ≤≠ ÏóêÎü¨
                    print(f"   ÏöîÏ≤≠ ÌÉÄÏûÖ: {error['request_type']}")
                    print(f"   ÎßàÏºì Ïàò: {error['markets_count']}Í∞ú")
                    print(f"   ÏóêÎü¨: {error['error']}")
                else:  # Í∏∞Ï°¥ Ï≤≠ÌÅ¨ ÏóêÎü¨ (ÌïòÏúÑ Ìò∏ÌôòÏÑ±)
                    print(f"   Ï≤≠ÌÅ¨ {error['chunk']}: {error['error']}")
                    markets_list = error['markets'][:3]
                    suffix = '...' if len(error['markets']) > 3 else ''
                    print(f"   Ïã§Ìå®Ìïú ÎßàÏºì: {', '.join(markets_list)}{suffix}")

        print("\n" + "=" * 60)
        print("üéâ ÌÖåÏä§Ìä∏ ÏôÑÎ£å!")


def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("üöÄ ÏóÖÎπÑÌä∏ Ticker API gzip ÏïïÏ∂ï ÏÑ±Îä• ÎπÑÍµê ÌÖåÏä§Ìä∏")
    print("=" * 60)
    print("Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî ÏóÖÎπÑÌä∏Ïùò Î™®Îì† ÎßàÏºìÏóê ÎåÄÌï¥ Ticker API gzip ÏïïÏ∂ï Ìö®Í≥ºÎ•º ÎπÑÍµêÌï©ÎãàÎã§.")
    print("Í∞úÎ∞ú ÏßÄÏπ®Ïö© ÏÑ±Îä• Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌïòÏó¨ ÏµúÏ†ÅÌôî Î∞©Ìñ•ÏùÑ Ï†úÏãúÌï©ÎãàÎã§.")
    print("=" * 60)

    try:
        tester = UpbitTickerTester()
        tester.run_gzip_comparison_test()

    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ ÌÖåÏä§Ìä∏Í∞Ä Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§.")
    except Exception as e:
        print(f"\n\n‚ùå ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò Î∞úÏÉù: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
