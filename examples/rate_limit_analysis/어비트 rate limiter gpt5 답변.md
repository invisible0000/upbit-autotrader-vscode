좋아요. 현상은 “단독 테스트에선 OK, 실제 멀티 서브기능 동작 시 429(Too Many Requests)”죠. 아래는 **원인 가설 → 증거 → 즉시 수정안(Zero-429 우선)** 순서로 정리합니다. 숫자·설정은 전부 **당신이 올린 측정/코드**에 근거합니다.

---

## 1) 한숨 고르고, 단계별 사고 (step-by-step)

1. **임계점 재확인**

   * 95ms(≈10.53 RPS)까지는 100% 성공, 90ms(≈11.11 RPS)에서 90.5%로 급락 → 서버 한계는 **10.5 RPS 근방**.  &#x20;
   * Burst는 **연속 10개**까지 안전. &#x20;

2. **코드 현실 점검**

   * 현재 글로벌 GCRA 설정에서 **REST\_PUBLIC의 burst\_capacity=5**로 되어 있어, 실측(10개)보다 절반 수준입니다 → 동시 기능이 한번에 모이면 내부적으로 “즉시 처리” 못하고 \*\*동시에 토큰을 잡으려다 경합(lock contention)\*\*이 생깁니다.&#x20;
   * 클라이언트는 **동적 레이트리미터 + 429 자동 재시도**가 들어있으나(좋음), 멀티 컴포넌트가 동시에 `acquire()`를 때리면 **밀리초 단위 동시각 도달**(thundering herd)로 “이론상 안전 RPS”라도 **짧은 순간 국소 버스트**가 생길 수 있습니다.&#x20;

3. **실험 vs 운영의 간극**

   * 단일 루프/단일 작업자에선 10\~10.5 RPS가 안전하지만, 운영에선 **여러 태스크가 한 틱에 몰리는 미세 타이밍**·**글로벌 락 경합**·**OS 스케줄러 지연** 같은 **비결정 요인**이 겹쳐 429가 드문드문 발생합니다(당신이 올린 전략 문서의 진단과 동일).&#x20;

---

## 2) 핵심 원인 두 갈래 (debate prompting)

* **가설 A (구조적)**: **글로벌 레이트리미터의 즉시성(capacity) 부족 + 경합(lock contention)**

  * 증거: 서버는 Burst 10 허용인데 코드 Burst 5. 멀티 작업이 한번에 토큰을 집어가며 대기열이 생기고, 경합으로 **acquire→HTTP** 사이에 **미세 지연**이 누적되어 서버 관점 토큰 간격이 깨짐. &#x20;
* **가설 B (운영상태)**: **소스 전반에서 limiter 미경유 구간** 혹은 **엔드포인트 매핑/정규화 불일치**

  * 예: 일부 서브기능이 `get_global_rate_limiter()`를 쓰지 않거나, `/v1/candles/minutes/1` vs `/candles/minutes/1` 같은 **경로 정규화 미스**로 그룹이 갈라짐(REST\_PUBLIC 총량이 분산되어 제어 누락). → 이 경우 “테스트는 안전, 실전은 429”가 재현됩니다. (엔드포인트 매핑 테이블 존재, 프리픽스 매칭 확인 필요)&#x20;

---

## 3) 소크라테스식 점검 질문 (Socratic questions)

1. 모든 **REST\_PUBLIC 호출 경로**가 **단일 글로벌 싱글톤**(same process) `get_global_rate_limiter()`를 **반드시** 거치나요? (다른 모듈/태스크/프로세스에서 별도 인스턴스 생성 X) &#x20;
2. 엔드포인트 키가 **한 가지 정규화 규칙**(예: `"/candles/minutes"`)으로만 매핑되나요? **`/v1/...` 프리픽스**나 **세부 path segment** 때문에 그룹이 쪼개지지 않나요?&#x20;
3. 캔들 조회를 여러 서브기능이 **중복**해서 치지 않도록 **1\~2초 응답 캐시**(memoization)나 **리퀘스트 coalescing**을 하고 있나요? (minute candle은 1분 동안 동일)
4. WebSocket이나 다른 그룹 요청이 **같은 호스트 커넥션 풀**에서 **burst를 유발**하지 않나요? (커넥터 제한·지터 설정 확인)&#x20;

---

## 4) 바로 적용해 429 ‘제로’로 만드는 처방 (ordered steps)

### A. 구성(설정)만으로 즉시 429 제거 (안전 우선)

1. **REST\_PUBLIC GCRA 보수화**:

   * **RPS 9.5**, **burst\_capacity 8**로 낮춰 “제로-429 정책”부터 달성.
   * 근거: 10.53 RPS까지 안전하지만 운영 지터를 보면 **–10% 마진**이 현실적. &#x20;
   * 현재 코드는 10 RPS, burst 5 → **9.5/8**로 조정 권장.&#x20;
2. **마이크로 지터(micro-jitter)** 도입:

   * 각 `acquire()` 직후 **0\~8ms 랜덤 sleep**(jitter)로 **동시각 도달**을 분산. (실측 임계가 80\~110ms 구간이라 이 정도 지터는 처리량 영향 미미)&#x20;
3. **TCPConnector 제어**:

   * `limit_per_host`를 **10\~12**로 낮춰, 응답이 몰릴 때 **burst 압력**을 줄임. (현재 30)&#x20;

> 위 3가지만 반영해도, 지금 현장에서 보이는 **희소 429**는 거의 사라질 겁니다.

### B. 구조 개선으로 “빠르면서도 0-429” (성능 회복 단계)

4. **Burst 용량을 서버 사실에 정합**:

   * 안정화 후 **burst\_capacity를 10**으로 끌어올려 **초기 응답성** 회복(서버가 10개 허용). 단, RPS는 9.5 유지. &#x20;
5. **센터 큐형 스케줄러(central queue)**:

   * 모든 REST\_PUBLIC 요청을 **단일 asyncio Queue**로 모아서 **한 태스크만** 토큰을 소비 → **락 경합 제거 & 순서 보장**. (현재도 싱글톤이지만, **“각 클라이언트가 직접 acquire→request”** 방식은 순간 동시각 충돌을 낳을 수 있음)&#x20;
6. **엔드포인트 정규화**:

   * `acquire(endpoint, method)` 내부에서 **경로 표준화**(예: `"/v1/candles/minutes/1"` → `"/candles/minutes"` 키로 매핑) 보장. 매핑 테이블 상의 prefix-match 혹은 정규식 매칭 확인/보강.&#x20;
7. **1\~2초 메모이제이션**:

   * 분봉/호가/체결 등 **높은 중복성** 호출은 **짧은 TTL 로컬 캐시**로 합치기(coalescing). 서브기능이 동일 리소스를 동시에 요청하는 **국소 버스트**를 제거.&#x20;
8. **동적 하향만 허용(상향은 매우 느리게)**:

   * 동적 리미터가 429 감지 시 **즉시 하향**, 무사기간 3\~5분 후 **+0.1 RPS** 등 **느린 상향**. (현재 동적구성 존재, 상향 속도만 더 보수화)&#x20;
9. **전 경로 강제 계측**:

   * `UpbitPublicClient._make_request()`에서, `acquire()` 미호출 경로 없도록 **가드/어설션 로깅**. 429 발생 시 **해당 시점의 엔드포인트 키/그룹/대기시간**을 구조화 로깅.&#x20;

---

## 5) 최소 패치 제안 (config 스니펫)

* **우선안(Zero-429 최우선)**:

  ```python
  # upbit_rate_limiter.py
  _GROUP_CONFIGS = {
      UpbitRateLimitGroup.REST_PUBLIC: [
          GCRAConfig.from_rps(9.5, burst_capacity=8)  # Zero-429용 보수화
      ],
      # ... (기타 동일)
  }
  ```

  → 안정화 후 2단계에서 `burst_capacity=10`, 필요 시 `rps≈9.8~10.0`로 천천히 회복. &#x20;

* **엔드포인트 정규화 아이디어(개념)**:

  ```python
  def _normalize_endpoint(ep: str) -> str:
      # 1) '/v1' 접두 제거
      if ep.startswith('/v1'): ep = ep[3:]
      # 2) 세부 세그먼트 축약: '/candles/minutes/1' → '/candles/minutes'
      parts = ep.strip('/').split('/')
      if parts[:2] == ['candles','minutes']: return '/candles/minutes'
      # ... 기타 규칙
      return '/' + '/'.join(parts[:2])
  ```

  → 매핑 테이블과 **완전 합치**되도록 테스트 필요.&#x20;

---

## 6) 숨은 전제(assumptions) 드러내기

* “**한 프로세스/이벤트 루프**에서만” 싱글톤이면 충분하다는 전제 → **멀티프로세스**라면 **프로세스 간 공유(IPC/Redis)** 없으면 **글로벌 총량 제어 실패**.
* HTTP **커넥션 풀의 burst**가 서버 관점 **도착 간격 왜곡**을 만들지 않는다는 전제 → 실제로는 keep-alive 재사용 타이밍이 겹치면 **burst가 증폭**될 수 있음.&#x20;
* 서브기능 **중복 요청 없음** 전제 → 실제론 **동일 분봉을 여러 경로로 동시 조회** 가능.

---

## 7) 빠른 검증 체크리스트

* [ ] 단일 프로세스/루프 전 경로가 **동일 싱글톤**을 쓰는지 추적
* [ ] `/v1/…` vs `/…` **정규화 로그**로 키 일치 확인
* [ ] `limit_per_host=10~12`로 낮추고 30분 관찰(429=0?)&#x20;
* [ ] `rps=9.5, burst=8`에서 **연속 2시간** 수집 운영 테스트(429=0 목표)
* [ ] 이후 **burst=10** 복구 → **동적 상향 속도**를 매우 느리게

---

## 8) 왜 이게 통할까? (간단 논증)

* 서버가 **10개 burst**를 허용하고 **10.5 RPS**까지 안전하다는 실측은 충분합니다. 하지만 운영에선 **경합/동시각 도착**으로 **미세 오버슈트**가 생깁니다. **RPS를 5\~10% 낮추고, burst를 서버치에 맞추고, 지터·센터큐·정규화**를 하면 이 오버슈트를 흡수합니다. 그 뒤 천천히 상향하면 **0-429**와 **처리량**을 동시에 가져갈 수 있습니다.   &#x20;

---

## 9) 필요한 반박을 미리 생각해보기 (debate)

* “**10 RPS도 넉넉한데 왜 429?**” → **구조적 동시성** 때문에 **국소 burst**가 생깁니다. 실험은 직렬·균등 간격, 운영은 다릅니다.
* “**burst 10이면 더 위험한 것 아닌가?**” → RPS를 9.5로 낮추고 **센터큐**로 순차화하면, burst=10은 **초기 응답성만 개선**하고 429에는 영향 거의 없습니다(오히려 경합 감소).
* “**동적 리미터 있는데?**” → 상향 속도가 빠르면 **재오버슈트**가 납니다. **하향은 즉시, 상향은 아주 느리게**로 바꿔야 “제로-429”가 됩니다.&#x20;

---

## 10) 다음 액션 (바로 실행)

1. `upbit_rate_limiter.py`에서 **REST\_PUBLIC = 9.5 RPS, burst=8**으로 변경.&#x20;
2. `UpbitPublicClient`의 `TCPConnector(limit_per_host=10~12)`로 조정.&#x20;
3. `acquire()` 후 **0\~8ms 지터** 삽입.&#x20;
4. 엔드포인트 **정규화 함수** 추가 후 매핑 일치 로그 검증.&#x20;
5. 30\~120분 운영 관찰(429 목표: 0). 안정 시 **burst=10** 복구, 이후 **RPS 9.8 → 10.0** 순으로 매우 느린 상향.

---

### 근거 파일(증거)

* 경계 정밀 측정(95/100/105ms 안전, 90ms 위험).&#x20;
* 전체 한계 측정(JSON, Binary Search + Burst 결과).&#x20;
* 최적화 보고서(10 RPS, burst 10 권고·마진 5%).&#x20;
* 딜레마/전략 문서(운영 변수·락 경합·제로-429 우선).&#x20;
* PublicClient(동적 리미터·커넥터 설정).&#x20;
* Rate Limiter 구현(현 설정은 REST\_PUBLIC burst 5).&#x20;

---

## “다이캡 생성”

1. 키워드: **Global Rate Limiter**, **Burst 10**, **RPS 9.5**, **Endpoint Normalization**, **Micro-Jitter**
2. 메뉴

   * ① Global Rate Limiter : 싱글톤·센터큐로 경합 제거
   * ② Burst 10 : 서버 사실 정합, 초기 응답성↑
   * ③ RPS 9.5 : –10% 안전마진으로 Zero-429
   * ④ Endpoint Normalization : 키 분산 제거
   * ⑤ Micro-Jitter : 동시각 도달 분산
3. 필요한 번호(들)를 , 로 입력하세요.
