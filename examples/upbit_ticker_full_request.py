#!/usr/bin/env python3
"""
ÏóÖÎπÑÌä∏ Ìã∞Ïª§ Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏ Ïä§ÌÅ¨Î¶ΩÌä∏

Î™©Ï†Å:
- Î™®Îì† ÏóÖÎπÑÌä∏ ÎßàÏºìÏùò Ìã∞Ïª§ API Ìò∏Ï∂ú Í∞ÄÎä•ÏÑ± ÌÖåÏä§Ìä∏
- ÏÑ±Îä• ÏßÄÌëú Ï∏°Ï†ï (ÏùëÎãµÏãúÍ∞Ñ, Îç∞Ïù¥ÌÑ∞ Ïö©Îüâ, ÏÑ±Í≥µÎ•† Îì±)
- ÌååÏù¥Ïç¨ Í∏∞Î≥∏ ÎùºÏù¥Î∏åÎü¨Î¶¨Îßå ÏÇ¨Ïö©ÌïòÏó¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÎèÖÎ¶ΩÏ†Å Íµ¨ÌòÑ
- Î™®Îì† Ïã¨Î≥ºÏùÑ ÌïúÎ≤àÏóê ÏöîÏ≤≠ÌïòÏó¨ API ÌïúÍ≥Ñ ÌÖåÏä§Ìä∏

ÏÇ¨Ïö©Î≤ï:
python upbit_ticker_full_request.py
"""

import json
import time
from urllib.request import urlopen, Request
from urllib.error import HTTPError, URLError
from datetime import datetime
import gzip
from typing import List, Dict, Any


class UpbitTickerTester:
    """ÏóÖÎπÑÌä∏ Ìã∞Ïª§ Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏ ÌÅ¥ÎûòÏä§"""

    BASE_URL = "https://api.upbit.com"
    MARKET_ALL_URL = f"{BASE_URL}/v1/market/all"
    TICKER_URL = f"{BASE_URL}/v1/ticker"

    def __init__(self):
        self.results = {
            'start_time': None,
            'end_time': None,
            'total_markets': 0,
            'successful_requests': 0,
            'failed_requests': 0,
            'total_response_time_ms': 0,
            'total_data_size_bytes': 0,
            'ticker_analysis': {},
            'error_details': [],
            'gzip_comparison': {
                'no_gzip': {},
                'with_gzip': {},
                'comparison_results': {}
            }
        }

    def get_all_markets(self) -> List[str]:
        """Î™®Îì† ÎßàÏºì Ïã¨Î≥º Ï°∞Ìöå"""
        print("üìä Î™®Îì† ÎßàÏºì Ïã¨Î≥º Ï°∞Ìöå Ï§ë...")

        try:
            request = Request(self.MARKET_ALL_URL)
            request.add_header('Accept', 'application/json')
            request.add_header('User-Agent', 'UpbitTickerTester/1.0')

            start_time = time.time()
            with urlopen(request, timeout=10) as response:
                response_time = (time.time() - start_time) * 1000

                # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ (gzip ÏïïÏ∂ï Ìï¥Ï†ú Í≥†Î†§)
                data = response.read()
                if response.info().get('Content-Encoding') == 'gzip':
                    data = gzip.decompress(data)

                markets_data = json.loads(data.decode('utf-8'))

            # ÎßàÏºì ÏΩîÎìúÎßå Ï∂îÏ∂ú
            market_symbols = [market['market'] for market in markets_data]

            print(f"‚úÖ ÎßàÏºì Ï°∞Ìöå ÏôÑÎ£å: {len(market_symbols)}Í∞ú")
            print(f"   ÏùëÎãµÏãúÍ∞Ñ: {response_time:.1f}ms")
            print(f"   Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {len(data):,} bytes")

            return market_symbols

        except Exception as e:
            print(f"‚ùå ÎßàÏºì Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []

    def get_all_tickers_with_gzip(self, markets: List[str]) -> Dict[str, Any]:
        """Î™®Îì† ÎßàÏºìÏùò Ìã∞Ïª§ Ï†ïÎ≥¥ ÌïúÎ≤àÏóê Ï°∞Ìöå (gzip ÏïïÏ∂ï ÏÇ¨Ïö©)"""

        # ÏóÖÎπÑÌä∏ APIÎäî Ìïú Î≤àÏóê Ïó¨Îü¨ ÎßàÏºì Ï°∞Ìöå Í∞ÄÎä• (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)
        markets_param = ",".join(markets)
        url = f"{self.TICKER_URL}?markets={markets_param}"

        print("üóúÔ∏è  gzip ÏïïÏ∂ï ÏÇ¨Ïö©ÌïòÏó¨ Ìã∞Ïª§ Ï†ïÎ≥¥ Ï°∞Ìöå...")
        print(f"   ÏöîÏ≤≠ URL Í∏∏Ïù¥: {len(url):,} characters")
        print(f"   ÏöîÏ≤≠ ÎßàÏºì Ïàò: {len(markets):,}Í∞ú")

        try:
            request = Request(url)
            request.add_header('Accept', 'application/json')
            request.add_header('Accept-Encoding', 'gzip')  # gzip ÏïïÏ∂ï ÏöîÏ≤≠
            request.add_header('User-Agent', 'UpbitTickerTester/1.0')

            start_time = time.time()
            with urlopen(request, timeout=30) as response:  # Îçî Í∏¥ ÌÉÄÏûÑÏïÑÏõÉ
                response_time = (time.time() - start_time) * 1000

                # ÏùëÎãµ Ìó§Îçî ÌôïÏù∏
                content_encoding = response.info().get('Content-Encoding', '')
                is_compressed = 'gzip' in content_encoding.lower()

                # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                data = response.read()
                compressed_size = len(data)

                # gzip ÏïïÏ∂ï Ìï¥Ï†ú
                if is_compressed:
                    data = gzip.decompress(data)

                ticker_data = json.loads(data.decode('utf-8'))

                return {
                    'success': True,
                    'data': ticker_data,
                    'response_time_ms': response_time,
                    'data_size_bytes': len(data),
                    'compressed_size_bytes': compressed_size,
                    'is_compressed': is_compressed,
                    'compression_ratio': (compressed_size / len(data)) if len(data) > 0 else 1.0,
                    'markets_requested': len(markets),
                    'tickers_received': len(ticker_data) if isinstance(ticker_data, list) else 1
                }

        except HTTPError as e:
            return {
                'success': False,
                'error': f"HTTP {e.code}: {e.reason}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'compressed_size_bytes': 0,
                'is_compressed': False,
                'compression_ratio': 1.0,
                'markets_requested': len(markets),
                'tickers_received': 0
            }
        except URLError as e:
            return {
                'success': False,
                'error': f"Network error: {e.reason}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'compressed_size_bytes': 0,
                'is_compressed': False,
                'compression_ratio': 1.0,
                'markets_requested': len(markets),
                'tickers_received': 0
            }
        except Exception as e:
            return {
                'success': False,
                'error': f"Unexpected error: {str(e)}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'compressed_size_bytes': 0,
                'is_compressed': False,
                'compression_ratio': 1.0,
                'markets_requested': len(markets),
                'tickers_received': 0
            }

    def get_all_tickers(self, markets: List[str]) -> Dict[str, Any]:
        """Î™®Îì† ÎßàÏºìÏùò Ìã∞Ïª§ Ï†ïÎ≥¥ ÌïúÎ≤àÏóê Ï°∞Ìöå"""

        # ÏóÖÎπÑÌä∏ APIÎäî Ìïú Î≤àÏóê Ïó¨Îü¨ ÎßàÏºì Ï°∞Ìöå Í∞ÄÎä• (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)
        markets_param = ",".join(markets)
        url = f"{self.TICKER_URL}?markets={markets_param}"

        print(f"üöÄ Ï†ÑÏ≤¥ ÎßàÏºì Ìã∞Ïª§ Ï†ïÎ≥¥ Ï°∞Ìöå ÏãúÏûë...")
        print(f"   ÏöîÏ≤≠ URL Í∏∏Ïù¥: {len(url):,} characters")
        print(f"   ÏöîÏ≤≠ ÎßàÏºì Ïàò: {len(markets):,}Í∞ú")

        try:
            request = Request(url)
            request.add_header('Accept', 'application/json')
            request.add_header('User-Agent', 'UpbitTickerTester/1.0')

            start_time = time.time()
            with urlopen(request, timeout=30) as response:  # Îçî Í∏¥ ÌÉÄÏûÑÏïÑÏõÉ
                response_time = (time.time() - start_time) * 1000

                # ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                data = response.read()
                if response.info().get('Content-Encoding') == 'gzip':
                    data = gzip.decompress(data)

                ticker_data = json.loads(data.decode('utf-8'))

                return {
                    'success': True,
                    'data': ticker_data,
                    'response_time_ms': response_time,
                    'data_size_bytes': len(data),
                    'markets_requested': len(markets),
                    'tickers_received': len(ticker_data) if isinstance(ticker_data, list) else 1
                }

        except HTTPError as e:
            return {
                'success': False,
                'error': f"HTTP {e.code}: {e.reason}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'markets_requested': len(markets),
                'tickers_received': 0
            }
        except URLError as e:
            return {
                'success': False,
                'error': f"Network error: {e.reason}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'markets_requested': len(markets),
                'tickers_received': 0
            }
        except Exception as e:
            return {
                'success': False,
                'error': f"Unexpected error: {str(e)}",
                'response_time_ms': 0,
                'data_size_bytes': 0,
                'markets_requested': len(markets),
                'tickers_received': 0
            }

    def analyze_ticker_data(self, ticker_data: List[Dict]) -> Dict[str, Any]:
        """Ìã∞Ïª§ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù"""
        if not ticker_data:
            return {'total_markets': 0, 'analysis': 'No data'}

        analysis = {
            'markets_analyzed': len(ticker_data),
            'krw_markets': 0,
            'btc_markets': 0,
            'usdt_markets': 0,
            'price_ranges': {
                'krw': {'min': float('inf'), 'max': 0, 'avg': 0},
                'btc': {'min': float('inf'), 'max': 0, 'avg': 0},
                'usdt': {'min': float('inf'), 'max': 0, 'avg': 0}
            },
            'volume_stats': {
                'total_krw_volume': 0,
                'total_btc_volume': 0,
                'total_usdt_volume': 0
            },
            'change_stats': {
                'positive_changes': 0,
                'negative_changes': 0,
                'no_changes': 0,
                'avg_change_rate': 0
            }
        }

        krw_prices = []
        btc_prices = []
        usdt_prices = []
        change_rates = []

        for ticker in ticker_data:
            market = ticker.get('market', '')
            trade_price = float(ticker.get('trade_price', 0))
            acc_trade_volume_24h = float(ticker.get('acc_trade_volume_24h', 0))
            change_rate = float(ticker.get('change_rate', 0))

            # ÎßàÏºì ÌÉÄÏûÖÎ≥Ñ Î∂ÑÎ•ò
            if market.startswith('KRW-'):
                analysis['krw_markets'] += 1
                krw_prices.append(trade_price)
                analysis['volume_stats']['total_krw_volume'] += acc_trade_volume_24h * trade_price
            elif market.startswith('BTC-'):
                analysis['btc_markets'] += 1
                btc_prices.append(trade_price)
                analysis['volume_stats']['total_btc_volume'] += acc_trade_volume_24h
            elif market.startswith('USDT-'):
                analysis['usdt_markets'] += 1
                usdt_prices.append(trade_price)
                analysis['volume_stats']['total_usdt_volume'] += acc_trade_volume_24h

            # Î≥ÄÌôîÏú® Î∂ÑÏÑù
            change_rates.append(change_rate)
            if change_rate > 0:
                analysis['change_stats']['positive_changes'] += 1
            elif change_rate < 0:
                analysis['change_stats']['negative_changes'] += 1
            else:
                analysis['change_stats']['no_changes'] += 1

        # Í∞ÄÍ≤© Î≤îÏúÑ Í≥ÑÏÇ∞
        if krw_prices:
            analysis['price_ranges']['krw'] = {
                'min': min(krw_prices),
                'max': max(krw_prices),
                'avg': sum(krw_prices) / len(krw_prices)
            }

        if btc_prices:
            analysis['price_ranges']['btc'] = {
                'min': min(btc_prices),
                'max': max(btc_prices),
                'avg': sum(btc_prices) / len(btc_prices)
            }

        if usdt_prices:
            analysis['price_ranges']['usdt'] = {
                'min': min(usdt_prices),
                'max': max(usdt_prices),
                'avg': sum(usdt_prices) / len(usdt_prices)
            }

        # ÌèâÍ∑† Î≥ÄÌôîÏú®
        if change_rates:
            analysis['change_stats']['avg_change_rate'] = sum(change_rates) / len(change_rates)

        return analysis

    def analyze_gzip_performance(self, normal_result: Dict[str, Any], gzip_result: Dict[str, Any]) -> None:
        """gzip ÏïïÏ∂ï ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù"""
        print("\n" + "=" * 60)
        print("üîç gzip ÏïïÏ∂ï ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù")
        print("=" * 60)

        # Îëê ÌÖåÏä§Ìä∏ Î™®Îëê ÏÑ±Í≥µÌïú Í≤ΩÏö∞ÏóêÎßå ÎπÑÍµê
        if normal_result['success'] and gzip_result['success']:
            # ÏùëÎãµÏãúÍ∞Ñ ÎπÑÍµê
            time_diff = gzip_result['response_time_ms'] - normal_result['response_time_ms']
            time_improvement = (time_diff / normal_result['response_time_ms']) * 100

            # Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ ÎπÑÍµê (ÏõêÎ≥∏ ÌÅ¨Í∏∞Îäî ÎèôÏùºÌï¥Ïïº Ìï®)
            original_size = normal_result['data_size_bytes']
            compressed_size = gzip_result.get('compressed_size_bytes', 0)
            data_reduction = ((original_size - compressed_size) / original_size) * 100 if original_size > 0 else 0

            # ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†àÏïΩÎüâ Í≥ÑÏÇ∞
            bytes_saved = original_size - compressed_size

            print("üìä **ÏÑ±Îä• ÎπÑÍµê Í≤∞Í≥º**")
            print(f"   ÏùºÎ∞ò ÏöîÏ≤≠ ÏùëÎãµÏãúÍ∞Ñ: {normal_result['response_time_ms']:.1f}ms")
            print(f"   gzip ÏöîÏ≤≠ ÏùëÎãµÏãúÍ∞Ñ: {gzip_result['response_time_ms']:.1f}ms")
            print(f"   ÏùëÎãµÏãúÍ∞Ñ Ï∞®Ïù¥: {time_diff:+.1f}ms ({time_improvement:+.1f}%)")

            print(f"\nüíæ **Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ ÎπÑÍµê**")
            print(f"   ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {original_size:,} bytes")
            print(f"   ÏïïÏ∂ïÎêú ÌÅ¨Í∏∞: {compressed_size:,} bytes")
            print(f"   Ï†àÏïΩÎêú Ïö©Îüâ: {bytes_saved:,} bytes")
            print(f"   ÏïïÏ∂ïÎ•†: {data_reduction:.1f}%")

            print(f"\n‚ö° **ÏÑ±Îä• ÌèâÍ∞Ä**")
            if time_improvement < -5:  # 5% Ïù¥ÏÉÅ Îπ®ÎùºÏßê
                print("   ‚úÖ gzip ÏïïÏ∂ïÏù¥ ÏùëÎãµÏÜçÎèÑÎ•º Í∞úÏÑ†ÌñàÏäµÎãàÎã§!")
            elif time_improvement > 5:  # 5% Ïù¥ÏÉÅ ÎäêÎ†§Ïßê
                print("   ‚ö†Ô∏è  gzip ÏïïÏ∂ïÏúºÎ°ú Ïù∏Ìï¥ ÏùëÎãµÏÜçÎèÑÍ∞Ä ÎäêÎ†§Ï°åÏäµÎãàÎã§.")
            else:
                print("   ‚û°Ô∏è  ÏùëÎãµÏÜçÎèÑÎäî ÎπÑÏä∑Ìï©ÎãàÎã§.")

            if data_reduction > 20:  # 20% Ïù¥ÏÉÅ ÏïïÏ∂ï
                print("   ‚úÖ ÎÑ§Ìä∏ÏõåÌÅ¨ ÎåÄÏó≠Ìè≠ÏùÑ ÌÅ¨Í≤å Ï†àÏïΩÌï©ÎãàÎã§!")
            elif data_reduction > 10:  # 10% Ïù¥ÏÉÅ ÏïïÏ∂ï
                print("   üëç ÎÑ§Ìä∏ÏõåÌÅ¨ ÎåÄÏó≠Ìè≠ÏùÑ Ï†àÏïΩÌï©ÎãàÎã§.")
            else:
                print("   üìã ÏïïÏ∂ï Ìö®Í≥ºÍ∞Ä Ï†úÌïúÏ†ÅÏûÖÎãàÎã§.")

            # ÏïïÏ∂ï Ïó¨Î∂Ä ÌôïÏù∏
            if gzip_result.get('is_compressed', False):
                print("   üóúÔ∏è  ÏÑúÎ≤ÑÏóêÏÑú gzip ÏïïÏ∂ïÏùÑ ÏßÄÏõêÌï©ÎãàÎã§.")
            else:
                print("   ‚ö†Ô∏è  ÏÑúÎ≤ÑÏóêÏÑú gzip ÏïïÏ∂ïÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.")

            # Í≤∞Í≥ºÎ•º resultsÏóê Ï†ÄÏû•
            self.results['gzip_comparison']['comparison_results'] = {
                'time_diff_ms': time_diff,
                'time_improvement_percent': time_improvement,
                'data_reduction_percent': data_reduction,
                'bytes_saved': bytes_saved,
                'compression_supported': gzip_result.get('is_compressed', False)
            }

        else:
            print("‚ùå **ÎπÑÍµê Î∂àÍ∞Ä**")
            if not normal_result['success']:
                print(f"   ÏùºÎ∞ò ÏöîÏ≤≠ Ïã§Ìå®: {normal_result['error']}")
            if not gzip_result['success']:
                print(f"   gzip ÏöîÏ≤≠ Ïã§Ìå®: {gzip_result['error']}")

    def run_full_test(self) -> None:
        """Ï†ÑÏ≤¥ ÌÖåÏä§Ìä∏ Ïã§Ìñâ (ÏùºÎ∞ò ÏöîÏ≤≠Í≥º gzip ÏïïÏ∂ï ÏöîÏ≤≠ Î™®Îëê ÏàòÌñâ)"""
        print("üöÄ ÏóÖÎπÑÌä∏ Ìã∞Ïª§ Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏ ÏãúÏûë")
        print("=" * 60)

        self.results['start_time'] = datetime.now()

        # 1. Î™®Îì† ÎßàÏºì Ï°∞Ìöå
        markets = self.get_all_markets()
        if not markets:
            print("‚ùå ÎßàÏºì Ï°∞Ìöå Ïã§Ìå®Î°ú ÌÖåÏä§Ìä∏ Ï§ëÎã®")
            return

        self.results['total_markets'] = len(markets)

        # 2. ÏùºÎ∞ò ÏöîÏ≤≠ÏúºÎ°ú Ìã∞Ïª§ Ï°∞Ìöå
        print("\nüìã [ÌÖåÏä§Ìä∏ 1] ÏùºÎ∞ò ÏöîÏ≤≠ÏúºÎ°ú Ìã∞Ïª§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå...")
        print("   ‚ö†Ô∏è  Ïù¥Îäî API ÌïúÍ≥Ñ ÌÖåÏä§Ìä∏ÏûÖÎãàÎã§!")

        result_normal = self.get_all_tickers(markets)
        self.results['gzip_comparison']['no_gzip'] = result_normal

        # Í≤∞Í≥º Ï∂úÎ†•
        if result_normal['success']:
            print(f"   ‚úÖ ÏÑ±Í≥µ: {result_normal['tickers_received']}Í∞ú Ìã∞Ïª§ ÏàòÏã†")
            print(f"   ‚è±Ô∏è  ÏùëÎãµÏãúÍ∞Ñ: {result_normal['response_time_ms']:.1f}ms")
            print(f"   üíæ Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {result_normal['data_size_bytes']:,} bytes")
        else:
            print(f"   ‚ùå Ïã§Ìå®: {result_normal['error']}")

        # Ïû†Ïãú ÎåÄÍ∏∞ (Rate Limit Í≥†Î†§)
        print("\n‚è≥ Rate Limit Í≥†Î†§ÌïòÏó¨ 1Ï¥à ÎåÄÍ∏∞...")
        time.sleep(1)

        # 3. gzip ÏïïÏ∂ï ÏöîÏ≤≠ÏúºÎ°ú Ìã∞Ïª§ Ï°∞Ìöå
        print("\nüìã [ÌÖåÏä§Ìä∏ 2] gzip ÏïïÏ∂ï ÏöîÏ≤≠ÏúºÎ°ú Ìã∞Ïª§ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå...")

        result_gzip = self.get_all_tickers_with_gzip(markets)
        self.results['gzip_comparison']['with_gzip'] = result_gzip

        # Í≤∞Í≥º Ï∂úÎ†•
        if result_gzip['success']:
            print(f"   ‚úÖ ÏÑ±Í≥µ: {result_gzip['tickers_received']}Í∞ú Ìã∞Ïª§ ÏàòÏã†")
            print(f"   ‚è±Ô∏è  ÏùëÎãµÏãúÍ∞Ñ: {result_gzip['response_time_ms']:.1f}ms")
            print(f"   üíæ ÏõêÎ≥∏ ÌÅ¨Í∏∞: {result_gzip['data_size_bytes']:,} bytes")
            print(f"   üóúÔ∏è  ÏïïÏ∂ï ÌÅ¨Í∏∞: {result_gzip['compressed_size_bytes']:,} bytes")
            print(f"   üìä ÏïïÏ∂ïÎ•†: {(1 - result_gzip['compression_ratio']) * 100:.1f}%")
            print(f"   üîç ÏïïÏ∂ï Ïó¨Î∂Ä: {'‚úÖ ÏïïÏ∂ïÎê®' if result_gzip['is_compressed'] else '‚ùå ÏïïÏ∂ï ÏïàÎê®'}")
        else:
            print(f"   ‚ùå Ïã§Ìå®: {result_gzip['error']}")

        # 4. ÏÑ±Îä• ÎπÑÍµê Î∂ÑÏÑù
        self.analyze_gzip_performance(result_normal, result_gzip)

        # 5. Î©îÏù∏ Í≤∞Í≥ºÎäî ÏùºÎ∞ò ÏöîÏ≤≠ Í≤∞Í≥º ÏÇ¨Ïö© (Í∏∞Ï°¥ Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
        result = result_normal
        if result['success']:
            self.results['successful_requests'] = result['tickers_received']
            self.results['failed_requests'] = result['markets_requested'] - result['tickers_received']
        else:
            self.results['failed_requests'] = result['markets_requested']
            self.results['error_details'].append({
                'request_type': 'all_tickers',
                'markets_count': result['markets_requested'],
                'error': result['error']
            })

        self.results['total_response_time_ms'] = result['response_time_ms']
        self.results['total_data_size_bytes'] = result['data_size_bytes']

        # 6. Ìã∞Ïª§ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù (ÏÑ±Í≥µÌïú Í≤∞Í≥º ÏÇ¨Ïö©)
        successful_result = result_normal if result_normal['success'] else result_gzip
        if successful_result['success'] and successful_result['data']:
            print("\nüîç Ìã∞Ïª§ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù Ï§ë...")
            analysis = self.analyze_ticker_data(successful_result['data'])
            self.results['ticker_analysis'] = analysis

        self.results['end_time'] = datetime.now()

        # 7. Í≤∞Í≥º Ï∂úÎ†•
        self.print_results()

    def print_results(self) -> None:
        """ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï∂úÎ†•"""
        print("\n" + "=" * 60)
        print("üìä ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ")
        print("=" * 60)

        # Í∏∞Î≥∏ ÌÜµÍ≥Ñ
        total_duration = (self.results['end_time'] - self.results['start_time']).total_seconds()
        success_rate = (self.results['successful_requests'] / self.results['total_markets'] * 100) if self.results['total_markets'] > 0 else 0

        print("üéØ **Í∏∞Î≥∏ ÌÜµÍ≥Ñ**")
        print(f"   Ï†ÑÏ≤¥ ÎßàÏºì Ïàò: {self.results['total_markets']:,}Í∞ú")
        print(f"   ÏÑ±Í≥µÌïú Ìã∞Ïª§: {self.results['successful_requests']:,}Í∞ú")
        print(f"   Ïã§Ìå®Ìïú Ìã∞Ïª§: {self.results['failed_requests']:,}Í∞ú")
        print(f"   ÏÑ±Í≥µÎ•†: {success_rate:.1f}%")

        print("\n‚è±Ô∏è  **ÏÑ±Îä• ÏßÄÌëú**")
        print(f"   Ï¥ù ÏÜåÏöîÏãúÍ∞Ñ: {total_duration:.1f}Ï¥à")
        print(f"   API ÏùëÎãµÏãúÍ∞Ñ: {self.results['total_response_time_ms']:,.0f}ms")
        print(f"   Ï≤òÎ¶¨Ïú®: {self.results['total_markets'] / total_duration:.1f} ÎßàÏºì/Ï¥à")

        print("\nüíæ **Îç∞Ïù¥ÌÑ∞ Ïö©Îüâ**")
        data_size_mb = self.results['total_data_size_bytes'] / (1024 * 1024)
        data_size_kb = self.results['total_data_size_bytes'] / 1024
        avg_size_per_ticker = self.results['total_data_size_bytes'] / self.results['successful_requests'] if self.results['successful_requests'] > 0 else 0

        print(f"   Ï¥ù Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {self.results['total_data_size_bytes']:,} bytes")
        print(f"                  {data_size_kb:.1f} KB")
        print(f"                  {data_size_mb:.2f} MB")
        print(f"   Ìã∞Ïª§Îãπ ÌèâÍ∑† ÌÅ¨Í∏∞: {avg_size_per_ticker:.0f} bytes")

        # Ìã∞Ïª§ Î∂ÑÏÑù Í≤∞Í≥º
        if 'ticker_analysis' in self.results and self.results['ticker_analysis']:
            analysis = self.results['ticker_analysis']
            print("\nüìã **Ìã∞Ïª§ Î∂ÑÏÑù**")
            print(f"   Î∂ÑÏÑùÎêú ÎßàÏºì: {analysis['markets_analyzed']:,}Í∞ú")
            print(f"   KRW ÎßàÏºì: {analysis['krw_markets']:,}Í∞ú")
            print(f"   BTC ÎßàÏºì: {analysis['btc_markets']:,}Í∞ú")
            print(f"   USDT ÎßàÏºì: {analysis['usdt_markets']:,}Í∞ú")

            print("\nüí∞ **Í∞ÄÍ≤© Î≤îÏúÑ (KRW ÎßàÏºì)**")
            krw_range = analysis['price_ranges']['krw']
            if krw_range['min'] != float('inf'):
                print(f"   ÏµúÏ†ÄÍ∞Ä: {krw_range['min']:,.0f}Ïõê")
                print(f"   ÏµúÍ≥†Í∞Ä: {krw_range['max']:,.0f}Ïõê")
                print(f"   ÌèâÍ∑†Í∞Ä: {krw_range['avg']:,.0f}Ïõê")

            print("\nüìà **Î≥ÄÌôîÏú® ÌÜµÍ≥Ñ**")
            change_stats = analysis['change_stats']
            print(f"   ÏÉÅÏäπ: {change_stats['positive_changes']:,}Í∞ú")
            print(f"   ÌïòÎùΩ: {change_stats['negative_changes']:,}Í∞ú")
            print(f"   Î≥¥Ìï©: {change_stats['no_changes']:,}Í∞ú")
            print(f"   ÌèâÍ∑† Î≥ÄÌôîÏú®: {change_stats['avg_change_rate']:.3f}%")

            print("\nüíπ **Í±∞ÎûòÎüâ ÌÜµÍ≥Ñ (24ÏãúÍ∞Ñ)**")
            volume_stats = analysis['volume_stats']
            print(f"   KRW Ï¥ù Í±∞ÎûòÎåÄÍ∏à: {volume_stats['total_krw_volume']:,.0f}Ïõê")
            print(f"   BTC Ï¥ù Í±∞ÎûòÎüâ: {volume_stats['total_btc_volume']:.4f} BTC")
            print(f"   USDT Ï¥ù Í±∞ÎûòÎüâ: {volume_stats['total_usdt_volume']:.2f} USDT")

        # API ÏÑ±Îä• Î∂ÑÏÑù
        print("\nüö¶ **API ÏÑ±Îä• Î∂ÑÏÑù**")
        print("   Îã®Ïùº ÏöîÏ≤≠ÏúºÎ°ú Ï≤òÎ¶¨: ‚úÖ")
        print(f"   URL Í∏∏Ïù¥ Ï†úÌïú: {'‚ö†Ô∏è  Îß§Ïö∞ Í∏¥ URL' if self.results['total_markets'] > 200 else '‚úÖ Ï†ÅÏ†ï'}")
        print(f"   ÏùëÎãµ ÏãúÍ∞Ñ: {'‚ö†Ô∏è  ÎäêÎ¶º' if self.results['total_response_time_ms'] > 5000 else '‚úÖ Îπ†Î¶Ñ'}")
        print(f"   Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞: {'‚ö†Ô∏è  ÎåÄÏö©Îüâ' if data_size_mb > 10 else '‚úÖ Ï†ÅÏ†ï'}")

        # gzip ÏïïÏ∂ï ÎπÑÍµê Í≤∞Í≥º
        if 'comparison_results' in self.results['gzip_comparison'] and self.results['gzip_comparison']['comparison_results']:
            comp_results = self.results['gzip_comparison']['comparison_results']
            print("\nüóúÔ∏è  **gzip ÏïïÏ∂ï Ìö®Í≥º ÏöîÏïΩ**")
            print(f"   ÏïïÏ∂ï ÏßÄÏõê: {'‚úÖ ÏßÄÏõêÎê®' if comp_results['compression_supported'] else '‚ùå ÎØ∏ÏßÄÏõê'}")
            if comp_results['compression_supported']:
                print(f"   ÏùëÎãµÏãúÍ∞Ñ Í∞úÏÑ†: {comp_results['time_improvement_percent']:+.1f}%")
                print(f"   Îç∞Ïù¥ÌÑ∞ Ï†àÏïΩ: {comp_results['data_reduction_percent']:.1f}% ({comp_results['bytes_saved']:,} bytes)")
                if comp_results['data_reduction_percent'] > 20:
                    print("   Í∂åÏû•ÏÇ¨Ìï≠: gzip ÏïïÏ∂ï ÏÇ¨Ïö© Í∂åÏû• (ÎÜíÏùÄ ÏïïÏ∂ïÎ•†)")
                elif comp_results['data_reduction_percent'] > 10:
                    print("   Í∂åÏû•ÏÇ¨Ìï≠: gzip ÏïïÏ∂ï ÏÇ¨Ïö© Í≥†Î†§ (Ï†ÅÎãπÌïú ÏïïÏ∂ïÎ•†)")
                else:
                    print("   Í∂åÏû•ÏÇ¨Ìï≠: ÏïïÏ∂ï Ìö®Í≥º Ï†úÌïúÏ†Å")

        # ÏóêÎü¨ ÏÉÅÏÑ∏
        if self.results['error_details']:
            print("\n‚ùå **ÏóêÎü¨ ÏÉÅÏÑ∏**")
            for error in self.results['error_details']:
                print(f"   ÏöîÏ≤≠ ÌÉÄÏûÖ: {error['request_type']}")
                print(f"   ÏóêÎü¨: {error['error']}")
                print(f"   ÏòÅÌñ•Î∞õÏùÄ ÎßàÏºì: {error['markets_count']}Í∞ú")

        print("\n" + "=" * 60)
        print("üéâ ÌÖåÏä§Ìä∏ ÏôÑÎ£å!")

        # Í≤∞Î°† Î∞è Í∂åÏû•ÏÇ¨Ìï≠
        self.print_recommendations()

    def print_recommendations(self) -> None:
        """ÌÖåÏä§Ìä∏ Í≤∞Í≥º Í∏∞Î∞ò Í∂åÏû•ÏÇ¨Ìï≠ Ï∂úÎ†•"""
        print("\nüí° **Í∂åÏû•ÏÇ¨Ìï≠**")

        if self.results['successful_requests'] == self.results['total_markets']:
            print("   ‚úÖ Î™®Îì† ÎßàÏºì Ìã∞Ïª§Î•º ÌïúÎ≤àÏóê ÏöîÏ≤≠ Í∞ÄÎä•Ìï©ÎãàÎã§!")
            print("   ‚úÖ Ïã§ÏãúÍ∞Ñ Í∞ÄÍ≤© Î™®ÎãàÌÑ∞ÎßÅÏóê Ï†ÅÌï©Ìï©ÎãàÎã§.")
        else:
            print("   ‚ö†Ô∏è  ÏùºÎ∂Ä ÎßàÏºìÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.")
            print("   üîÑ ÏóêÎü¨ Ï≤òÎ¶¨ Î°úÏßÅÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.")

        if self.results['total_response_time_ms'] < 1000:
            print("   ‚ö° Îß§Ïö∞ Îπ†Î•∏ ÏùëÎãµÏÜçÎèÑÎ°ú Ïã§ÏãúÍ∞Ñ Í±∞ÎûòÏóê Ï†ÅÌï©Ìï©ÎãàÎã§.")
        elif self.results['total_response_time_ms'] < 3000:
            print("   üëç Ï†ÅÎãπÌïú ÏùëÎãµÏÜçÎèÑÏûÖÎãàÎã§.")
        else:
            print("   ‚ö†Ô∏è  ÏùëÎãµÏÜçÎèÑÍ∞Ä ÎäêÎ†§ Ïã§ÏãúÍ∞Ñ Í±∞ÎûòÏóê Î∂ÄÏ†ÅÌï©Ìï† Ïàò ÏûàÏäµÎãàÎã§.")

        data_size_mb = self.results['total_data_size_bytes'] / (1024 * 1024)
        if data_size_mb < 1:
            print("   üíæ Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞Í∞Ä ÏûëÏïÑ ÎπàÎ≤àÌïú Ìò∏Ï∂úÏóê Ï†ÅÌï©Ìï©ÎãàÎã§.")
        elif data_size_mb < 5:
            print("   üíæ Ï†ÅÎãπÌïú Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞ÏûÖÎãàÎã§.")
        else:
            print("   ‚ö†Ô∏è  Îç∞Ïù¥ÌÑ∞ ÌÅ¨Í∏∞Í∞Ä Ïª§ÏÑú ÎÑ§Ìä∏ÏõåÌÅ¨ ÎπÑÏö©ÏùÑ Í≥†Î†§Ìï¥Ïïº Ìï©ÎãàÎã§.")

        print("\nüéØ **CandleDataProvider Í∞úÎ∞ú ÏãúÏÇ¨Ï†ê**")
        print("   üìä Ìã∞Ïª§ APIÎäî ÏïàÏ†ïÏ†ÅÏúºÎ°ú ÏûëÎèôÌïòÎØÄÎ°ú Ïã§ÏãúÍ∞Ñ Í∞ÄÍ≤© Î™®ÎãàÌÑ∞ÎßÅ Í∞ÄÎä•")
        print("   üîÑ Ï∫îÎì§ Îç∞Ïù¥ÌÑ∞Îäî Î≥ÑÎèÑ APIÏù¥ÎØÄÎ°ú ÎèÖÎ¶ΩÏ†Å ÌÖåÏä§Ìä∏ ÌïÑÏöî")
        print("   üíæ ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨Î•º ÏúÑÌïú ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò Í≥†Î†§")
        print("   ‚ö° Rate LimitÏùÑ Í≥†Î†§Ìïú ÏöîÏ≤≠ Ï£ºÍ∏∞ ÏÑ§Í≥Ñ ÌïÑÏöî")

        # gzip ÏïïÏ∂ï Í∂åÏû•ÏÇ¨Ìï≠
        if 'comparison_results' in self.results['gzip_comparison'] and self.results['gzip_comparison']['comparison_results']:
            comp_results = self.results['gzip_comparison']['comparison_results']
            if comp_results['compression_supported']:
                print(f"   üóúÔ∏è  gzip ÏïïÏ∂ïÏúºÎ°ú {comp_results['data_reduction_percent']:.1f}% Îç∞Ïù¥ÌÑ∞ Ï†àÏïΩ Í∞ÄÎä•")
                if comp_results['data_reduction_percent'] > 15:
                    print("   üí° ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° Ïãú gzip ÏïïÏ∂ï ÌôúÏö© Í∂åÏû•")
                if comp_results['time_improvement_percent'] < 0:
                    print("   üöÄ gzip ÏïïÏ∂ïÏù¥ ÏùëÎãµÏÜçÎèÑÎèÑ Í∞úÏÑ†Ìï®")
            else:
                print("   üìã gzip ÏïïÏ∂ï ÎØ∏ÏßÄÏõêÏúºÎ°ú ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°Îßå Í∞ÄÎä•")


def main():
    """Î©îÏù∏ Ìï®Ïàò"""
    print("üöÄ ÏóÖÎπÑÌä∏ Ìã∞Ïª§ Ï†ÑÏ≤¥ ÎßàÏºì ÌÖåÏä§Ìä∏")
    print("=" * 60)
    print("Ïù¥ Ïä§ÌÅ¨Î¶ΩÌä∏Îäî ÏóÖÎπÑÌä∏Ïùò Î™®Îì† ÎßàÏºìÏóê ÎåÄÌï¥ Ìã∞Ïª§ APIÎ•º ÌÖåÏä§Ìä∏Ìï©ÎãàÎã§.")
    print("Î™®Îì† Ïã¨Î≥ºÏùÑ ÌïúÎ≤àÏóê ÏöîÏ≤≠ÌïòÏó¨ APIÏùò ÌïúÍ≥ÑÎ•º ÌôïÏù∏Ìï©ÎãàÎã§.")
    print("=" * 60)

    try:
        tester = UpbitTickerTester()
        tester.run_full_test()

    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ ÌÖåÏä§Ìä∏Í∞Ä Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§.")
    except Exception as e:
        print(f"\n\n‚ùå ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•ò Î∞úÏÉù: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
