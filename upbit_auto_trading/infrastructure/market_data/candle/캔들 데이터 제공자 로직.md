## 캔들 데이터 제공자 로직

### 캔들 제공자 파라미터 (`get_candles()`)
- 시간은 utc 기준
- 시간 형식: 2025-06-24T04:56:53( 내부 계산은 계산 편의상 datetime 형식 이용, db query와 rest api 요청 시 형식 조정)
- 내부적으로는 시간은 timframe에 맞게 정렬하여 모두 기본 datatime 형식으로 사용하다가 마지막 rest api 클라이언트 요청 시만 형식 변환(변환 감소)
- 내부적으로는 데이터의 시작과 끝을 정렬하여 이용하고 마지막 rest api 클라이언트 요청 시 시작 시간만 +dt 하여 이용. (규칙 통일, 변환 지점 고정)
- 항상 처음(청크의 처음만) 입력 시작 시간은 정렬 없이 사용.( 잘못 변환시 요청자의 의도를 왜곡하거나 현재 시간보다 미래로 변환됨)
- 입력시간을 그냥 사용해도 계산된 마지막 시간은 정렬 하므로 그다음 청크 들은 자연스럽게 정렬된 시작 시간을 가지게 되므로 따로 처리가 필요 없음
- 
#### 입력
- `market` : 코인 심벌, KRW-BTC (rest api 기능)
- `timeframe` : (캔들 데이터 제공자 기능)
- `count` : 요청 데이터 갯수, 1~200 (rest api 기능)
- `to` : 시작 시간, 2025-06-24T04:56:53Z, 2025-06-24 04:56:53, 2025-06-24T13:56:53+09:00 (rest api 기능)
- `end` : 끝 시간(캔들 데이터 제공자 기능)
#### 캔들 데이터 제공자 파라미터 케이스
1. 카운트
	1. 200이하 
	2. 200이상
2. 시작,카운트
	1. 200이하
	2. 200이상
3. 시작, 끝
	1. 200이하
	2. 200이상
4. 끝
	1. 200이하
	2. 200이상

#### 대량 요청 청크 처리
- 기본적으로 예상 `expect_api_calls`을 반복 절대 정지 조건으로 가짐 + 시스템 부하 고려 2000회(4000000카운트, 1분봉 기준 약 9개월)
- 처음부터 모든 계획을 세우지 않으며 청크 별로 겹침 분석으로 다음 청크 시작을 재계산 하여 total_remain_count =-< processed_count 정지
- expect_end_time
- total_remain_count
- total_count
- processed_count

### 시간 계산 변수

#### 시작 시간
- request_start_time :  to 요청된 원래 시작 시간
- recent_start_time : 요청된 시작 시간이 없을 때 현재 시간
- align_start_time : 정렬된 시작 시간
- expect_start_time : 예상된 응답 데이터의 시작 시간

#### 끝 시간
- expect_end_time : 예상된 응답 데이터 끝 시간

### 오버랩 분석기
#### 입력
- `timeframe` (query용)
- `symbol` (query용)
- `count` = `target_count` (1~200)
- `start_time` = `target_start`
- `end_time` = `target_end`
#### 출력
- 겹침 상태, chunk_start, chcunk_end
#### 내부 메서드
- `timeframe` --> `dt` (타임프레임으로 계산한 1단위 시간)
- `has_any_data_in_range()`
- `is_range_complete(symbol, timeframe, target_start, target_end, target_count)`
- `has_data_in_start()`
- `is_continue_till_end()
#### 초기 개발시 임시 검증
- `count` > 1
- `count` <=200
- `start_time` > `end_time`
- 카운트 계산(`timeframe`, `start_time`, `end_time`) == `count`
- 임시 검증은 계산 부하를 고려하여 기능 안정화 이후 제거

#### 겹침 상태 로직
- 정보 통일성과 변수 최소화를 위해 최대한 시간을 이용
- 시간 형식 통일 이용하여 변환을 최소화

1. 겹침 없음 : `target_start`, `target_end` 내에 1개의 데이터도 없음, `has_any_data_in_range() =  false`
	- [`target_start`, `target_end`] 캔들 데이터 제공자 rest api 클라이언트 요청, db 저장,  제공
2. 겹침 있음 : `target_start`, `target_end` 내에 1개의 데이터라도 존재, `has_any_data_in_range()  = true`
	1. 완전 겹침 : `target_start`, `target_end` 내의 데이터의 갯수가 `target_count`와 일치, `is_range_complete() = true`
		- 캔들 데이터 제공자 db 에서 제공
	2. 일부 겹침 : `target_start`, `target_end` 내의 데이터의 갯수가 카운트 보다 적음, `is_range_complete() = false`
		1. 시작 겹침 : `target_start` 에 데이터 존재, `has_data_in_start() = true`
			1. 연결된 데이터의 끝을 찾음 `partial_end`(처음에 요청 카운트보다 적었으므로 이어져 있어도 `target_end`보다 작을 수 없음, 모자른 부분이 무조건 존재, 이후 탐색은 발견 되도 2번 gap이므로 찾지 않음)
				-  [`partial_end` - `dt` , `target_end`] 캔들 데이터 제공자가 요천, 저장, 제공
		2. 중간 겹침 : `target_start` 에 데이터 없음, `has_data_in_start() = false`
			1. 데이터 시작 찾음 `partial_start` (범위내 utc max, target_end > partial_start 은 목적 구간 내 겹침이 존재 하므로 발생하지 않음)
			2. `partial_start` 부터 `target_end` 에서 연결된 끝 탐색 `partial_end`(운이 좋으면 계속 이어질 수도 있음.)
				1. `target_end` < `partial_end`, gap을 2번 발견한 상황(시작도 비었고 중간에 또 빈상태, 처음부터 바로 요청), `is_continue_till_end() = false`
					- [`target_start`, `target_end`]로 캔들 데이터 제공자가 요청, 저장, 제공(두번 끊김 이므로 api 요청이 1보다 큰 경우)
				2. target_end >= partial_end , 앞 부분만 비어 있고 목표 끝까지 데이터가 있음으로 빈 앞 부분만 요청,`is_continue_till_end() = true`
					- [`target_start`, `partial_start` + `dt`] 로 캔들 데이터 요청자가 요청, 저장, 제공

### DB상태 케이스
1. 겹침 없음 : |------|
2. 겹침 있음 : |--1---|
	1. 완전 겹침 : |111111|
	2. 일부 겹침 : |11--11|
		1. 시작 겹침 : |11----| or |11-1--|
		2. 중간 겹침 : |--11--| or |--1111| or |--1-11|
			1. 파편 겹침 : |--1-11| or |--1-1-|
			2. 말단 겹침 : |--1111| 