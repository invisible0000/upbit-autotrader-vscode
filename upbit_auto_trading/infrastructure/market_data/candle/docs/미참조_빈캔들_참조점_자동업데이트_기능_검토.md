# 미참조 빈 캔들 참조점 자동 업데이트 기능 검토

**작성일**: 2025년 9월 20일
**버전**: v2.0
**상태**: 개선된 설계 완료

## 📋 기능 개요

### 목적
오버랩 분석 완료 후 `none_`으로 시작하는 미참조 빈 캔들 그룹을 자동으로 탐지하여 적절한 참조점으로 업데이트하는 후처리 기능

### 동작 조건
- 오버랩 분석이 완료된 시점
- `OverlapResult`에 `db_start`와 `db_end`가 존재하는 경우
- 해당 범위 내에 미참조 빈 캔들(`empty_copy_from_utc`가 `none_`으로 시작)이 존재하는 경우

### 핵심 가치
- **데이터 일관성**: 빈 캔들 참조 관계의 자동 정리
- **성능 보존**: 메인 수집 프로세스에 영향 없는 독립적 처리
- **안전성**: 에러 발생 시에도 메인 플로우 보호

## 🎯 수정된 작업 계획 (메서드 최적화)

### 1. SqliteCandleRepository 확장 (3개 메서드)
**개선된 설계**: 범위 기반 처리로 실용성 대폭 향상

#### 1.1 `find_unreferenced_empty_candle_in_range()` - 🆕 범위 내 미참조 빈 캔들 검색
```python
async def find_unreferenced_empty_candle_in_range(
    self,
    symbol: str,
    timeframe: str,
    start_time: datetime,
    end_time: datetime
) -> Optional[Dict[str, str]]:
    """
    범위 내 미참조 빈 캔들 중 가장 미래의 레코드 조회

    Returns:
        {
            'candle_date_time_utc': str,
            'empty_copy_from_utc': str  # 'none_xxxxxxxx' 형태
        } 또는 None
    """
```

**SQL 쿼리**:
```sql
SELECT candle_date_time_utc, empty_copy_from_utc
FROM candles_{symbol}_{timeframe}
WHERE candle_date_time_utc BETWEEN ? AND ?
  AND empty_copy_from_utc IS NOT NULL
  AND empty_copy_from_utc LIKE 'none_%'
ORDER BY candle_date_time_utc DESC
LIMIT 1
```

#### 1.2 `get_record_by_time()` - 범용 시점별 레코드 조회
```python
async def get_record_by_time(
    self,
    symbol: str,
    timeframe: str,
    target_time: datetime
) -> Optional[Dict[str, Any]]:
    """
    특정 시간의 레코드 조회 (현재/미래 시점 모두 활용 가능)

    Returns:
        {
            'candle_date_time_utc': str,
            'empty_copy_from_utc': Optional[str],
            # 기타 필요 필드들...
        }
    """
```

**활용 방법**:
- 현재 시점: `get_record_by_time(symbol, timeframe, db_start)`
- 한 틱 미래: `get_record_by_time(symbol, timeframe, TimeUtils.get_time_by_ticks(db_start, timeframe, 1))`

#### 1.3 `update_empty_copy_reference_by_group()` - 그룹 일괄 업데이트
```python
async def update_empty_copy_reference_by_group(
    self,
    symbol: str,
    timeframe: str,
    old_group_id: str,
    new_reference: str
) -> int:
    """
    특정 그룹의 empty_copy_from_utc 일괄 업데이트 (트랜잭션)

    Args:
        old_group_id: 기존 그룹 ID (예: 'none_d1dea30f')
        new_reference: 새로운 참조 (시간 문자열 또는 참조 ID)

    Returns:
        업데이트된 레코드 수
    """
```

### 2. EmptyCandleReferenceUpdater 클래스 생성
**파일**: `empty_candle_reference_updater.py`

```python
class EmptyCandleReferenceUpdater:
    """미참조 빈 캔들 참조점 자동 업데이트 처리기"""

    async def process_unreferenced_empty_candles(
        self,
        overlap_result: OverlapResult,
        symbol: str,
        timeframe: str
    ) -> bool:
        """6단계 조건 검증 및 참조점 업데이트 실행"""
```

### 3. CandleDataProvider 통합
**수정 위치**: `mark_chunk_completed()` 메서드
**추가 코드량**: 약 5-7줄

```python
# 오버랩 분석 완료 후 추가
try:
    await self.reference_updater.process_unreferenced_empty_candles(
        overlap_result, symbol, timeframe
    )
except Exception as e:
    logger.warning(f"미참조 빈 캔들 업데이트 실패 (무시): {e}")
```

## 🔧 구현 세부사항

### 비즈니스 로직 플로우
```
1. OverlapResult에 db_start, db_end 존재 확인
   ↓
2. find_unreferenced_empty_candle_in_range(db_start, db_end) → 범위 내 미참조 빈 캔들 검색
   ↓
3. 미참조 빈 캔들 발견되면:
   ├─ 그룹 ID 추출 (예: 'none_d1dea30f')
   ├─ 해당 시점의 한 틱 미래 레코드 조회 (get_record_by_time)
   └─ 미래 레코드의 empty_copy_from_utc 확인
   ↓
4. 참조점 결정:
   ├─ 값 존재 → 해당 값으로 그룹 업데이트
   └─ NULL → candle_date_time_utc로 그룹 업데이트
   ↓
5. 발견되지 않으면 처리 건너뛰기
```

### SQL 쿼리 예시

#### 범위 내 미참조 빈 캔들 검색
```sql
SELECT candle_date_time_utc, empty_copy_from_utc
FROM candles_KRW_BTC_1m
WHERE candle_date_time_utc BETWEEN ? AND ?
  AND empty_copy_from_utc IS NOT NULL
  AND empty_copy_from_utc LIKE 'none_%'
ORDER BY candle_date_time_utc DESC
LIMIT 1
```

#### 현재/미래 시점 레코드 조회
```sql
SELECT candle_date_time_utc, empty_copy_from_utc
FROM candles_KRW_BTC_1m
WHERE candle_date_time_utc = ?
```

#### 그룹 일괄 업데이트
```sql
UPDATE candles_KRW_BTC_1m
SET empty_copy_from_utc = ?
WHERE empty_copy_from_utc = ?
```

### 에러 처리 전략
- **DB 오류**: 로깅 후 무시 (메인 플로우 보호)
- **시간 계산 오류**: TimeUtils 예외 처리
- **트랜잭션 실패**: 안전한 롤백

## 📊 기술적 고려사항

### DDD 아키텍처 준수
- **Infrastructure 계층 배치**: 기술적 세부사항 캡슐화
- **Repository 패턴**: DB 접근 로직 분리
- **단일 책임 원칙**: 참조 업데이트만 담당하는 전용 클래스

### 성능 최적화 보존
- **후처리 방식**: 메인 수집 성능 무영향
- **선택적 실행**: 조건 미충족 시 즉시 종료
- **최소 쿼리**: 범위 검색 1회 + 미래 레코드 조회 1회 + 그룹 업데이트 1회 (총 3회)
- **기존 v6.2 최적화 완전 보존**: 90% 메모리 절약, 70% CPU 개선 효과 유지

### Infrastructure 로깅 규칙
```python
logger = create_component_logger("EmptyCandleReferenceUpdater")

# 성공 케이스
logger.info(f"미참조 그룹 참조점 업데이트 완료: {group_id} → {new_reference} ({updated_count}개)")

# 건너뛰기 케이스
logger.debug(f"미참조 빈 캔들 없음, 처리 건너뛰기: {symbol} {timeframe}")

# 에러 케이스
logger.warning(f"참조점 업데이트 실패 (무시): {symbol} {timeframe} - {e}")
```

## 🚀 예상 효과

### 코드 품질 개선
- **범위 기반 처리**: 단일 시점 → 전체 오버랩 범위로 실용성 대폭 향상
- **효율적인 검색**: 전용 범위 검색 메서드로 성능 최적화
- **유지보수성 향상**: 명확한 역할 분담과 직관적인 로직

### 개발 생산성
- **구현 복잡도 낮음**: 독립적이고 직관적인 로직
- **테스트 용이성**: 각 컴포넌트 개별 테스트 가능
- **확장성**: 향후 다른 참조 정리 로직 쉽게 추가 가능

### 시스템 안정성
- **격리된 처리**: 메인 플로우와 완전 분리
- **에러 내성**: 실패해도 전체 시스템에 영향 없음
- **트랜잭션 보장**: 일관성 있는 데이터 업데이트

## 📝 구현 체크리스트

### Phase 1: Repository 확장
- [ ] `find_unreferenced_empty_candle_in_range()` 메서드 구현
- [ ] `get_record_by_time()` 메서드 구현
- [ ] `update_empty_copy_reference_by_group()` 메서드 구현
- [ ] 단위 테스트 작성

### Phase 2: 비즈니스 로직 구현
- [ ] `EmptyCandleReferenceUpdater` 클래스 생성
- [ ] 6단계 검증 로직 구현
- [ ] Infrastructure 로깅 적용

### Phase 3: 통합 및 테스트
- [ ] `CandleDataProvider` 통합
- [ ] 통합 테스트 실행
- [ ] 성능 영향도 검증

## 🎯 결론

이 개선된 설계는:
1. **범위 기반 처리**로 실용성을 대폭 향상시키면서도 구현 복잡도는 합리적 수준 유지
2. **기존 성능 최적화를 완전 보존**하면서 새 기능 추가
3. **DDD 아키텍처 원칙을 완전 준수**하여 시스템 일관성 유지
4. **안전하고 독립적인 처리**로 시스템 안정성 보장
5. **효율적인 SQL 쿼리**로 성능 걱정 없는 범위 검색 지원

총 **180-220줄의 코드 추가**로 미참조 빈 캔들 참조점 자동 업데이트 기능을 구현할 수 있으며, **오버랩 구간 전체의 데이터 품질을 한 번에 향상**시킬 수 있는 포괄적이고 실용적인 솔루션입니다.

### 🚀 주요 개선사항
- **처리 범위 확대**: 단일 시점 → db_start~db_end 전체 범위
- **검색 효율성**: 전용 범위 검색 메서드로 조건에 맞는 레코드 직접 탐지
- **확장성**: 향후 다른 빈 캔들 정리 로직에도 패턴 재활용 가능
