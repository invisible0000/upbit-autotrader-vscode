# 캔들 데이터 시스템 아키텍처 설계 분석서

## 📋 개요

캔들 데이터 시스템의 완성도가 높아지면서 실제 사용 환경에서의 최적 설계 방안에 대한 심층 분석이 필요한 시점입니다. 본 문서는 데이터 접근 패턴, 빈 캔들 처리 전략, 메모리 최적화 방안에 대해 종합적으로 분석하고 권장사항을 제시합니다.

**작성일**: 2025-09-20
**버전**: v1.0
**대상**: 차트 기능 연동 및 실제 사용 환경 설계

---

## 🎯 핵심 설계 질문들

### 1. **데이터 접근 패턴**
- Repository Interface로 먼저 확인 후 CandleDataProvider 사용 vs 직접 CandleDataProvider 사용
- 수집 완료 보고 후 Repository 직접 조회 vs 통합 인터페이스

### 2. **빈 캔들 처리 전략**
- 빈 캔들 레코드를 요청자에게 전달할 필요성
- 클라이언트 보간 vs 서버사이드 완전 데이터 제공

### 3. **메모리 최적화**
- 빈 캔들 전달 vs 클라이언트 복제 표시의 메모리 효율성
- 대용량 데이터 처리 시 최적 전략

### 4. **최신 데이터 완전성**
- 첫 청크 빈 캔들 미처리로 인한 최신 데이터 불완전성 해결 방안

---

## 📊 데이터 접근 패턴 분석

### Pattern A: Repository Interface 우선 확인 방식

```python
# 사용 패턴
async def get_chart_data(symbol: str, timeframe: str, count: int):
    # 1. 데이터 완전성 확인
    existing_count = await repository.count_candles_in_range(
        symbol, timeframe, start_time, end_time
    )

    # 2. 불완전하면 수집 실행
    if existing_count < expected_count:
        await candle_provider.get_candles(symbol, timeframe, count)

    # 3. 완성된 데이터 조회
    return await repository.get_candles_by_range(
        symbol, timeframe, start_time, end_time
    )
```

**장점:**
- ✅ 불필요한 수집 방지 (이미 완료된 데이터는 빠른 조회)
- ✅ 명확한 책임 분리 (수집 vs 조회)
- ✅ Repository 최적화 활용 (인덱스, 쿼리 최적화)
- ✅ 캐시 레이어 추가 용이성

**단점:**
- ❌ 2단계 호출로 복잡성 증가
- ❌ Repository Interface에 대한 의존성 증가
- ❌ 중간 상태 관리 필요

**적합한 사용 사례:**
- 대용량 데이터 처리 (백테스팅, 분석)
- 반복적인 동일 구간 조회
- 정밀한 메모리 관리가 필요한 경우

### Pattern B: CandleDataProvider 직접 사용

```python
# 사용 패턴
async def get_chart_data(symbol: str, timeframe: str, count: int):
    # 단일 호출로 완성된 데이터 반환
    return await candle_provider.get_candles(symbol, timeframe, count)
```

**장점:**
- ✅ 단순하고 직관적인 인터페이스
- ✅ 내부 최적화 자동 적용
- ✅ 사용자 편의성 극대화
- ✅ DDD 아키텍처 준수 (Application → Infrastructure)

**단점:**
- ❌ 항상 CandleDataProvider를 거쳐야 함
- ❌ 내부 복잡성 증가 (수집/조회 판단 로직)
- ❌ 세밀한 제어 어려움

**적합한 사용 사례:**
- 실시간 차트 (최신 데이터 위주)
- 간단한 애플리케이션
- 프로토타입 및 MVP

### 🎯 권장사항: 하이브리드 접근법

```python
class SmartCandleService:
    """지능형 캔들 데이터 서비스 - 사용 패턴에 따른 자동 최적화"""

    async def get_candles(
        self,
        symbol: str,
        timeframe: str,
        count: int = None,
        strategy: DataStrategy = DataStrategy.AUTO
    ) -> CandleResult:

        if strategy == DataStrategy.AUTO:
            # 내부 휴리스틱으로 최적 전략 자동 선택
            if count > 10000:  # 대용량
                strategy = DataStrategy.REPOSITORY_FIRST
            elif self._is_recent_data(timeframe, count):  # 최신 데이터
                strategy = DataStrategy.PROVIDER_DIRECT

        if strategy == DataStrategy.REPOSITORY_FIRST:
            return await self._repository_first_approach(...)
        else:
            return await self._provider_direct_approach(...)
```

---

## 🔍 빈 캔들 처리 전략 분석

### 현재 상황 정리

**빈 캔들의 원래 목적**: 중복 수집 최소화
- 이미 수집한 구간을 다시 수집하지 않도록 Gap 표시
- DB에 빈 캔들 레코드로 Gap 정보 저장
- OverlapAnalyzer와 연동하여 효율적인 수집 계획 수립

**현재 구현 상태**:
- EmptyCandleDetector가 API 수집 시 자동으로 빈 캔들 생성
- 미참조 빈 캔들 참조점 자동 업데이트 기능 완료
- DB에 실제 캔들과 빈 캔들이 함께 저장됨

### Option 1: 빈 캔들 포함 전달

```python
# 완전한 시계열 데이터 반환
candles = await get_candles("KRW-BTC", "1m", 1000)
# 결과: 실제 캔들 + 빈 캔들 레코드 모두 포함
```

**장점:**
- ✅ 완전한 시계열 데이터 제공
- ✅ 데이터 무결성 보장
- ✅ 클라이언트 시간축 처리 단순
- ✅ Gap 정보 명시적 전달

**단점:**
- ❌ 메모리 사용량 증가 (빈 캔들도 객체로 전달)
- ❌ 네트워크 전송량 증가
- ❌ 클라이언트에서 빈 캔들 필터링 필요

**메모리 영향 분석:**
```
1000개 요청 시 실제 700개 + 빈 캔들 300개
→ 300개 불필요한 객체 생성 및 전송
→ 약 30% 메모리 오버헤드
```

### Option 2: 실제 캔들만 전달 + Gap 정보 별도

```python
@dataclass
class CandleResult:
    actual_candles: List[CandleData]    # 실제 캔들만
    gap_info: List[GapInfo]             # Gap 정보 별도
    time_range: TimeRange               # 전체 시간 범위
    is_complete: bool                   # 완전성 여부

# 사용법
result = await get_candles("KRW-BTC", "1m", 1000)
# 클라이언트에서 Gap 보간 처리
display_data = interpolate_gaps(result.actual_candles, result.gap_info)
```

**장점:**
- ✅ 메모리 효율성 극대화
- ✅ 네트워크 효율성 최적화
- ✅ 클라이언트별 표시 방식 선택 가능
- ✅ 원본 데이터와 보간 데이터 구분 명확

**단점:**
- ❌ 클라이언트 복잡성 증가
- ❌ Gap 보간 로직 중복 구현 가능성
- ❌ 시간축 처리 복잡성

**메모리 영향 분석:**
```
1000개 요청 시 실제 700개 + Gap정보 5개
→ 70% 메모리 절약
→ Gap 보간은 클라이언트에서 view-time에만 처리
```

### Option 3: 선택적 처리 방식

```python
class CandleDataProvider:
    async def get_candles(
        self,
        symbol: str,
        timeframe: str,
        count: int = None,
        include_empty_candles: bool = False,  # 빈 캔들 포함 여부
        gap_handling: GapHandling = GapHandling.INFO_ONLY  # Gap 처리 방식
    ) -> CandleResult:

        if gap_handling == GapHandling.FILL_SERVER_SIDE:
            # 서버에서 보간 처리 후 완전한 데이터 반환
            return self._get_interpolated_candles(...)
        elif gap_handling == GapHandling.INFO_ONLY:
            # 실제 캔들 + Gap 정보만 반환
            return self._get_candles_with_gap_info(...)
        else:  # RAW_ONLY
            # 실제 캔들만 반환
            return self._get_raw_candles_only(...)
```

---

## 📈 사용 사례별 최적 전략

### 실시간 차트 (최신 100~500개)

**특성:**
- 높은 빈도의 업데이트
- 시각적 연속성 중요
- 메모리 사용량 상대적으로 적음

**권장 전략:**
```python
# Pattern: CandleDataProvider 직접 + 클라이언트 보간
result = await candle_provider.get_candles(
    symbol="KRW-BTC",
    timeframe="1m",
    count=500,
    gap_handling=GapHandling.INFO_ONLY  # Gap 정보만 전달
)

# 클라이언트에서 실시간 보간
chart_data = real_time_interpolate(result.actual_candles, result.gap_info)
```

**이유:**
- 메모리 효율성 확보
- 빠른 응답성
- 시각적 연속성을 위한 클라이언트 보간

### 기술적 분석 (수천~수만 개)

**특성:**
- 정확한 데이터 필수
- 계산 성능 중요
- Gap의 영향이 분석 결과에 중요

**권장 전략:**
```python
# Pattern: Repository 우선 + 완전한 데이터
# 1. 데이터 완전성 확인
if not await repository.is_range_complete(...):
    await candle_provider.collect_missing_data(...)

# 2. 분석용 완전 데이터 조회
candles = await repository.get_candles_by_range(..., exclude_empty=False)
# 또는 서버사이드 보간
candles = await candle_provider.get_candles(..., gap_handling=GapHandling.FILL_SERVER_SIDE)
```

**이유:**
- 데이터 정확성 최우선
- 분석 알고리즘의 Gap 민감성 고려
- 한 번 로드 후 반복 사용

### 백테스팅 (수개월~수년)

**특성:**
- 대용량 데이터 처리
- 메모리 효율성 극도로 중요
- 정확성보다 처리 성능 우선

**권장 전략:**
```python
# Pattern: Repository 직접 + 스트리밍 + 실제 캔들만
async def backtest_data_stream(symbol: str, start_date: datetime, end_date: datetime):
    async for chunk in repository.stream_candles_by_range(
        symbol, timeframe, start_date, end_date,
        chunk_size=10000,
        exclude_empty=True  # 실제 캔들만
    ):
        yield chunk  # 메모리 사용량 최소화
```

**이유:**
- 메모리 사용량 최소화 필수
- Gap은 거래 불가능 구간으로 처리
- 스트리밍으로 대용량 처리

### 다중 차트 대시보드

**특성:**
- 여러 요청 동시 처리
- 캐시 효율성 중요
- 일관된 사용자 경험

**권장 전략:**
```python
# Pattern: 캐시 + 선택적 처리
class DashboardCandleService:
    async def get_candles_for_chart(self, chart_config: ChartConfig):
        # 캐시 확인
        if cached := await self.cache.get_candles(...):
            return cached

        # 차트 타입에 따른 최적 전략
        if chart_config.type == ChartType.REALTIME:
            return await self._get_realtime_candles(...)
        elif chart_config.type == ChartType.ANALYSIS:
            return await self._get_analysis_candles(...)
```

---

## ⚠️ 최신 데이터 완전성 문제 분석

### 문제 상황

현재 시스템에서 **첫 청크는 안전성을 위해 빈 캔들 처리를 하지 않음**
→ 최신 데이터에는 항상 Gap이 존재할 가능성
→ 실시간 차트나 최신 분석에서 데이터 불완전성 발생

```
예시: 현재 시간 16:30, 1분봉 100개 요청
├─ 청크 1 (16:30~16:11): 빈 캔들 처리 안 함 → Gap 가능성 존재
├─ 청크 2 (16:10~15:51): 빈 캔들 처리 적용 → 완전한 데이터
└─ 청크 3 (15:50~15:31): 빈 캔들 처리 적용 → 완전한 데이터
```

### 해결 방안

#### 방안 1: 클라이언트 보간 방식

```python
class RealtimeChartRenderer:
    def render_candles(self, result: CandleResult):
        # 최신 구간의 Gap 감지
        gaps = detect_recent_gaps(result.actual_candles, result.time_range)

        # 마지막 유효 데이터로 보간
        display_candles = interpolate_from_last_valid(
            result.actual_candles, gaps
        )

        # 보간된 캔들은 시각적으로 구분 표시
        self.draw_candles(display_candles, highlight_interpolated=True)
```

**장점:**
- 서버 복잡성 증가 없음
- 클라이언트별 보간 정책 적용 가능
- 메모리 효율성 유지

**단점:**
- 클라이언트 로직 복잡성 증가
- Gap 감지 로직 중복 구현 위험

#### 방안 2: 최신 청크 특별 처리

```python
class CandleDataProvider:
    async def get_candles(self, ...):
        # 기존 로직으로 수집
        chunks = await self._collect_chunks(...)

        # 첫 청크(최신)에 대해서만 후처리로 빈 캔들 보간
        if chunks and self._is_recent_chunk(chunks[0]):
            chunks[0] = await self._post_process_recent_chunk(chunks[0])

        return self._merge_chunks(chunks)

    async def _post_process_recent_chunk(self, chunk: ChunkInfo):
        # 안전한 범위에서 빈 캔들 후처리 적용
        return await self.empty_candle_detector.fill_recent_gaps(chunk)
```

**장점:**
- 클라이언트 단순성 유지
- 최신 데이터 완전성 보장
- 기존 안전성 로직 유지

**단점:**
- 서버 복잡성 증가
- 성능 오버헤드

#### 방안 3: 실시간 보정 시스템

```python
class RealtimeGapCorrector:
    """실시간 Gap 보정 시스템"""

    async def correct_realtime_gaps(
        self,
        candles: List[CandleData],
        time_range: TimeRange
    ) -> List[CandleData]:

        # 실시간 구간에서만 Gap 보정 적용
        if self._is_realtime_range(time_range):
            return await self._apply_conservative_gap_filling(candles)

        return candles  # 과거 데이터는 보정하지 않음
```

### 🎯 권장사항: 방안 2 (최신 청크 특별 처리)

**이유:**
1. **사용자 경험**: 클라이언트에서 신경 쓸 필요 없음
2. **데이터 품질**: 최신 데이터도 높은 완전성 보장
3. **시스템 일관성**: 모든 데이터 소비자가 동일한 품질 경험
4. **확장성**: 향후 실시간 기능 확장 시 기반 제공

---

## 🚀 권장 구현 로드맵

### Phase 1: 기본 구현 (즉시)

```python
# 1. CandleResult 모델 확장
@dataclass
class CandleResult:
    candles: List[CandleData]
    gap_info: List[GapInfo] = field(default_factory=list)
    is_complete: bool = True
    metadata: CandleMetadata = None

# 2. CandleDataProvider 옵션 추가
async def get_candles(
    self,
    symbol: str,
    timeframe: str,
    count: int = None,
    include_gaps: bool = False  # 단순한 시작
) -> CandleResult:
```

**목표**: 기존 기능 유지하면서 새로운 옵션 추가

### Phase 2: 최신 데이터 보정 (차트 MVP 후)

```python
# 최신 청크 특별 처리 추가
class CandleDataProvider:
    def __init__(self, ..., enable_realtime_gap_correction: bool = True):
        self.enable_realtime_gap_correction = enable_realtime_gap_correction

    async def _post_process_realtime_chunk(self, chunk: ChunkInfo):
        # 안전한 범위에서 빈 캔들 후처리
```

**목표**: 최신 데이터 완전성 문제 해결

### Phase 3: 성능 최적화 (필요시)

```python
# 사용 패턴별 자동 최적화
class SmartCandleService:
    async def get_candles(self, ..., strategy: DataStrategy = DataStrategy.AUTO):
        # 휴리스틱 기반 최적 전략 자동 선택
```

**목표**: 실제 사용 데이터 기반 최적화

### Phase 4: 고급 기능 (안정화 후)

- 캐시 시스템 통합
- 스트리밍 API 지원
- 다중 차트 최적화

---

## 📊 성능 및 메모리 영향 분석

### 메모리 사용량 비교

| 데이터 크기 | 빈 캔들 포함 | 실제 캔들만 | 절약률 |
|------------|-------------|------------|--------|
| 1,000개    | 100MB       | 70MB       | 30%    |
| 10,000개   | 1GB         | 700MB      | 30%    |
| 100,000개  | 10GB        | 7GB        | 30%    |

### 네트워크 전송량 비교

| 시나리오        | 빈 캔들 포함 | 실제+Gap정보 | 절약률 |
|-----------------|-------------|-------------|--------|
| 실시간 차트     | 1MB/요청    | 0.7MB/요청  | 30%    |
| 기술적 분석     | 50MB/요청   | 35MB/요청   | 30%    |
| 백테스팅       | 500MB/요청  | 350MB/요청  | 30%    |

### CPU 처리 시간 비교

| 작업              | 서버사이드 보간 | 클라이언트 보간 | 차이   |
|-------------------|-----------------|-----------------|--------|
| 데이터 준비       | 100ms          | 50ms           | -50%   |
| 클라이언트 렌더링 | 50ms           | 80ms           | +60%   |
| **총 처리 시간**  | **150ms**      | **130ms**      | -13%   |

**결론**: 클라이언트 보간이 약간 더 효율적이나, 사용자 경험 측면에서는 서버사이드 처리가 일관성 있음

---

## ⚖️ 최종 권장사항

### 🎯 단기 전략 (차트 MVP)

1. **CandleDataProvider 기본 사용**
   - `include_gaps=False` 기본값으로 실제 캔들만 반환
   - Gap 정보는 별도 필드로 제공
   - 클라이언트에서 필요시 보간 처리

2. **최신 데이터 보정 추가**
   - 첫 청크에 대해서만 후처리로 Gap 보정
   - 안전성과 완전성의 균형점 확보

### 🚀 장기 전략 (최적화)

1. **사용 패턴별 자동 최적화**
   - 실시간: 클라이언트 보간
   - 분석: 서버사이드 완전 데이터
   - 백테스팅: Repository 직접 + 실제 캔들만

2. **선택적 처리 시스템**
   - API 옵션으로 처리 방식 선택 가능
   - 기본값은 효율성 우선
   - 필요시 완전성 우선 모드 제공

### 💡 핵심 설계 원칙

1. **효율성 우선**: 기본적으로 메모리/네트워크 효율성 최대화
2. **선택적 완전성**: 필요한 경우에만 완전한 데이터 제공
3. **클라이언트 단순성**: 복잡한 로직은 서버에서 처리
4. **확장 가능성**: 향후 요구사항 변화에 유연하게 대응

---

## 📚 구현 가이드라인

### 1. CandleResult 모델 설계

```python
@dataclass
class CandleResult:
    """캔들 조회 결과 - 효율성과 완전성 정보 모두 제공"""

    # 핵심 데이터
    candles: List[CandleData]              # 실제 캔들만 (기본)

    # Gap 처리 정보
    gap_info: List[GapInfo] = field(default_factory=list)
    is_complete: bool = True

    # 메타데이터
    time_range: TimeRange = None
    collection_stats: CollectionStats = None

    # 헬퍼 메서드
    def get_interpolated_candles(self) -> List[CandleData]:
        """클라이언트 보간용 헬퍼"""
        return interpolate_gaps(self.candles, self.gap_info)

    def get_memory_usage_mb(self) -> float:
        """메모리 사용량 측정"""
        return calculate_memory_usage(self.candles, self.gap_info)
```

### 2. API 설계 가이드라인

```python
# 명확하고 확장 가능한 API 설계
async def get_candles(
    self,
    symbol: str,
    timeframe: str,
    count: int = None,
    to: datetime = None,
    end: datetime = None,

    # 처리 옵션
    gap_handling: GapHandling = GapHandling.INFO_ONLY,
    realtime_correction: bool = True,

    # 성능 옵션
    strategy: DataStrategy = DataStrategy.AUTO
) -> CandleResult:
```

### 3. 클라이언트 보간 유틸리티

```python
class CandleGapInterpolator:
    """클라이언트용 Gap 보간 유틸리티"""

    @staticmethod
    def interpolate_linear(candles: List[CandleData], gaps: List[GapInfo]) -> List[CandleData]:
        """선형 보간"""

    @staticmethod
    def interpolate_last_value(candles: List[CandleData], gaps: List[GapInfo]) -> List[CandleData]:
        """마지막 값 유지 보간"""

    @staticmethod
    def detect_gaps(candles: List[CandleData], timeframe: str) -> List[GapInfo]:
        """Gap 자동 감지"""
```

---

## 🔚 결론

캔들 데이터 시스템은 이미 훌륭한 기반을 갖추고 있습니다. 핵심은 **효율성을 기본으로 하되, 필요시 완전성을 선택할 수 있는 유연한 구조**를 만드는 것입니다.

**즉시 적용 권장사항**:
1. 실제 캔들만 반환하는 것을 기본값으로 설정
2. Gap 정보는 별도 필드로 제공
3. 최신 청크에 대해서만 후처리로 Gap 보정
4. 클라이언트 보간 유틸리티 제공

이를 통해 메모리 효율성을 극대화하면서도 데이터 완전성 요구사항을 충족할 수 있는 균형 잡힌 시스템을 구축할 수 있을 것입니다.

**검토 및 피드백을 통해 최종 설계 방향을 결정하시기 바랍니다.** 🚀
