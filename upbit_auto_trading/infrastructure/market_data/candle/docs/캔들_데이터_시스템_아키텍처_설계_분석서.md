# μΊ”λ“¤ λ°μ΄ν„° μ‹μ¤ν… μ•„ν‚¤ν…μ² μ„¤κ³„ λ¶„μ„μ„

## π“‹ κ°μ”

μΊ”λ“¤ λ°μ΄ν„° μ‹μ¤ν…μ μ™„μ„±λ„κ°€ λ†’μ•„μ§€λ©΄μ„ μ‹¤μ  μ‚¬μ© ν™κ²½μ—μ„μ μµμ  μ„¤κ³„ λ°©μ•μ— λ€ν• μ‹¬μΈµ λ¶„μ„μ΄ ν•„μ”ν• μ‹μ μ…λ‹λ‹¤. λ³Έ λ¬Έμ„λ” λ°μ΄ν„° μ ‘κ·Ό ν¨ν„΄, λΉ μΊ”λ“¤ μ²λ¦¬ μ „λµ, λ©”λ¨λ¦¬ μµμ ν™” λ°©μ•μ— λ€ν•΄ μΆ…ν•©μ μΌλ΅ λ¶„μ„ν•κ³  κ¶μ¥μ‚¬ν•­μ„ μ μ‹ν•©λ‹λ‹¤.

**μ‘μ„±μΌ**: 2025-09-20
**λ²„μ „**: v1.0
**λ€μƒ**: μ°¨νΈ κΈ°λ¥ μ—°λ™ λ° μ‹¤μ  μ‚¬μ© ν™κ²½ μ„¤κ³„

---

## π― ν•µμ‹¬ μ„¤κ³„ μ§λ¬Έλ“¤

### 1. **λ°μ΄ν„° μ ‘κ·Ό ν¨ν„΄**
- Repository Interfaceλ΅ λ¨Όμ € ν™•μΈ ν›„ CandleDataProvider μ‚¬μ© vs μ§μ ‘ CandleDataProvider μ‚¬μ©
- μμ§‘ μ™„λ£ λ³΄κ³  ν›„ Repository μ§μ ‘ μ΅°ν vs ν†µν•© μΈν„°νμ΄μ¤

### 2. **λΉ μΊ”λ“¤ μ²λ¦¬ μ „λµ**
- λΉ μΊ”λ“¤ λ μ½”λ“λ¥Ό μ”μ²­μμ—κ² μ „λ‹¬ν•  ν•„μ”μ„±
- ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„ vs μ„λ²„μ‚¬μ΄λ“ μ™„μ „ λ°μ΄ν„° μ κ³µ

### 3. **λ©”λ¨λ¦¬ μµμ ν™”**
- λΉ μΊ”λ“¤ μ „λ‹¬ vs ν΄λΌμ΄μ–ΈνΈ λ³µμ  ν‘μ‹μ λ©”λ¨λ¦¬ ν¨μ¨μ„±
- λ€μ©λ‰ λ°μ΄ν„° μ²λ¦¬ μ‹ μµμ  μ „λµ

### 4. **μµμ‹  λ°μ΄ν„° μ™„μ „μ„±**
- μ²« μ²­ν¬ λΉ μΊ”λ“¤ λ―Έμ²λ¦¬λ΅ μΈν• μµμ‹  λ°μ΄ν„° λ¶μ™„μ „μ„± ν•΄κ²° λ°©μ•

---

## π“ λ°μ΄ν„° μ ‘κ·Ό ν¨ν„΄ λ¶„μ„

### Pattern A: Repository Interface μ°μ„  ν™•μΈ λ°©μ‹

```python
# μ‚¬μ© ν¨ν„΄
async def get_chart_data(symbol: str, timeframe: str, count: int):
    # 1. λ°μ΄ν„° μ™„μ „μ„± ν™•μΈ
    existing_count = await repository.count_candles_in_range(
        symbol, timeframe, start_time, end_time
    )

    # 2. λ¶μ™„μ „ν•λ©΄ μμ§‘ μ‹¤ν–‰
    if existing_count < expected_count:
        await candle_provider.get_candles(symbol, timeframe, count)

    # 3. μ™„μ„±λ λ°μ΄ν„° μ΅°ν
    return await repository.get_candles_by_range(
        symbol, timeframe, start_time, end_time
    )
```

**μ¥μ :**
- β… λ¶ν•„μ”ν• μμ§‘ λ°©μ§€ (μ΄λ―Έ μ™„λ£λ λ°μ΄ν„°λ” λΉ λ¥Έ μ΅°ν)
- β… λ…ν™•ν• μ±…μ„ λ¶„λ¦¬ (μμ§‘ vs μ΅°ν)
- β… Repository μµμ ν™” ν™μ© (μΈλ±μ¤, μΏΌλ¦¬ μµμ ν™”)
- β… μΊμ‹ λ μ΄μ–΄ μ¶”κ°€ μ©μ΄μ„±

**λ‹¨μ :**
- β 2λ‹¨κ³„ νΈμ¶λ΅ λ³µμ΅μ„± μ¦κ°€
- β Repository Interfaceμ— λ€ν• μμ΅΄μ„± μ¦κ°€
- β μ¤‘κ°„ μƒνƒ κ΄€λ¦¬ ν•„μ”

**μ ν•©ν• μ‚¬μ© μ‚¬λ΅€:**
- λ€μ©λ‰ λ°μ΄ν„° μ²λ¦¬ (λ°±ν…μ¤ν…, λ¶„μ„)
- λ°λ³µμ μΈ λ™μΌ κµ¬κ°„ μ΅°ν
- μ •λ°€ν• λ©”λ¨λ¦¬ κ΄€λ¦¬κ°€ ν•„μ”ν• κ²½μ°

### Pattern B: CandleDataProvider μ§μ ‘ μ‚¬μ©

```python
# μ‚¬μ© ν¨ν„΄
async def get_chart_data(symbol: str, timeframe: str, count: int):
    # λ‹¨μΌ νΈμ¶λ΅ μ™„μ„±λ λ°μ΄ν„° λ°ν™
    return await candle_provider.get_candles(symbol, timeframe, count)
```

**μ¥μ :**
- β… λ‹¨μν•κ³  μ§κ΄€μ μΈ μΈν„°νμ΄μ¤
- β… λ‚΄λ¶€ μµμ ν™” μλ™ μ μ©
- β… μ‚¬μ©μ νΈμμ„± κ·Ήλ€ν™”
- β… DDD μ•„ν‚¤ν…μ² μ¤€μ (Application β†’ Infrastructure)

**λ‹¨μ :**
- β ν•­μƒ CandleDataProviderλ¥Ό κ±°μ³μ•Ό ν•¨
- β λ‚΄λ¶€ λ³µμ΅μ„± μ¦κ°€ (μμ§‘/μ΅°ν νλ‹¨ λ΅μ§)
- β μ„Έλ°€ν• μ μ–΄ μ–΄λ ¤μ›€

**μ ν•©ν• μ‚¬μ© μ‚¬λ΅€:**
- μ‹¤μ‹κ°„ μ°¨νΈ (μµμ‹  λ°μ΄ν„° μ„μ£Ό)
- κ°„λ‹¨ν• μ• ν”λ¦¬μΌ€μ΄μ…
- ν”„λ΅ν† νƒ€μ… λ° MVP

### π― κ¶μ¥μ‚¬ν•­: ν•μ΄λΈλ¦¬λ“ μ ‘κ·Όλ²•

```python
class SmartCandleService:
    """μ§€λ¥ν• μΊ”λ“¤ λ°μ΄ν„° μ„λΉ„μ¤ - μ‚¬μ© ν¨ν„΄μ— λ”°λ¥Έ μλ™ μµμ ν™”"""

    async def get_candles(
        self,
        symbol: str,
        timeframe: str,
        count: int = None,
        strategy: DataStrategy = DataStrategy.AUTO
    ) -> CandleResult:

        if strategy == DataStrategy.AUTO:
            # λ‚΄λ¶€ ν΄λ¦¬μ¤ν‹±μΌλ΅ μµμ  μ „λµ μλ™ μ„ νƒ
            if count > 10000:  # λ€μ©λ‰
                strategy = DataStrategy.REPOSITORY_FIRST
            elif self._is_recent_data(timeframe, count):  # μµμ‹  λ°μ΄ν„°
                strategy = DataStrategy.PROVIDER_DIRECT

        if strategy == DataStrategy.REPOSITORY_FIRST:
            return await self._repository_first_approach(...)
        else:
            return await self._provider_direct_approach(...)
```

---

## π” λΉ μΊ”λ“¤ μ²λ¦¬ μ „λµ λ¶„μ„

### ν„μ¬ μƒν™© μ •λ¦¬

**λΉ μΊ”λ“¤μ μ›λ λ©μ **: μ¤‘λ³µ μμ§‘ μµμ†ν™”
- μ΄λ―Έ μμ§‘ν• κµ¬κ°„μ„ λ‹¤μ‹ μμ§‘ν•μ§€ μ•λ„λ΅ Gap ν‘μ‹
- DBμ— λΉ μΊ”λ“¤ λ μ½”λ“λ΅ Gap μ •λ³΄ μ €μ¥
- OverlapAnalyzerμ™€ μ—°λ™ν•μ—¬ ν¨μ¨μ μΈ μμ§‘ κ³„ν μλ¦½

**ν„μ¬ κµ¬ν„ μƒνƒ**:
- EmptyCandleDetectorκ°€ API μμ§‘ μ‹ μλ™μΌλ΅ λΉ μΊ”λ“¤ μƒμ„±
- λ―Έμ°Έμ΅° λΉ μΊ”λ“¤ μ°Έμ΅°μ  μλ™ μ—…λ°μ΄νΈ κΈ°λ¥ μ™„λ£
- DBμ— μ‹¤μ  μΊ”λ“¤κ³Ό λΉ μΊ”λ“¤μ΄ ν•¨κ» μ €μ¥λ¨

### Option 1: λΉ μΊ”λ“¤ ν¬ν•¨ μ „λ‹¬

```python
# μ™„μ „ν• μ‹κ³„μ—΄ λ°μ΄ν„° λ°ν™
candles = await get_candles("KRW-BTC", "1m", 1000)
# κ²°κ³Ό: μ‹¤μ  μΊ”λ“¤ + λΉ μΊ”λ“¤ λ μ½”λ“ λ¨λ‘ ν¬ν•¨
```

**μ¥μ :**
- β… μ™„μ „ν• μ‹κ³„μ—΄ λ°μ΄ν„° μ κ³µ
- β… λ°μ΄ν„° λ¬΄κ²°μ„± λ³΄μ¥
- β… ν΄λΌμ΄μ–ΈνΈ μ‹κ°„μ¶• μ²λ¦¬ λ‹¨μ
- β… Gap μ •λ³΄ λ…μ‹μ  μ „λ‹¬

**λ‹¨μ :**
- β λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μ¦κ°€ (λΉ μΊ”λ“¤λ„ κ°μ²΄λ΅ μ „λ‹¬)
- β λ„¤νΈμ›ν¬ μ „μ†΅λ‰ μ¦κ°€
- β ν΄λΌμ΄μ–ΈνΈμ—μ„ λΉ μΊ”λ“¤ ν•„ν„°λ§ ν•„μ”

**λ©”λ¨λ¦¬ μν–¥ λ¶„μ„:**
```
1000κ° μ”μ²­ μ‹ μ‹¤μ  700κ° + λΉ μΊ”λ“¤ 300κ°
β†’ 300κ° λ¶ν•„μ”ν• κ°μ²΄ μƒμ„± λ° μ „μ†΅
β†’ μ•½ 30% λ©”λ¨λ¦¬ μ¤λ²„ν—¤λ“
```

### Option 2: μ‹¤μ  μΊ”λ“¤λ§ μ „λ‹¬ + Gap μ •λ³΄ λ³„λ„

```python
@dataclass
class CandleResult:
    actual_candles: List[CandleData]    # μ‹¤μ  μΊ”λ“¤λ§
    gap_info: List[GapInfo]             # Gap μ •λ³΄ λ³„λ„
    time_range: TimeRange               # μ „μ²΄ μ‹κ°„ λ²”μ„
    is_complete: bool                   # μ™„μ „μ„± μ—¬λ¶€

# μ‚¬μ©λ²•
result = await get_candles("KRW-BTC", "1m", 1000)
# ν΄λΌμ΄μ–ΈνΈμ—μ„ Gap λ³΄κ°„ μ²λ¦¬
display_data = interpolate_gaps(result.actual_candles, result.gap_info)
```

**μ¥μ :**
- β… λ©”λ¨λ¦¬ ν¨μ¨μ„± κ·Ήλ€ν™”
- β… λ„¤νΈμ›ν¬ ν¨μ¨μ„± μµμ ν™”
- β… ν΄λΌμ΄μ–ΈνΈλ³„ ν‘μ‹ λ°©μ‹ μ„ νƒ κ°€λ¥
- β… μ›λ³Έ λ°μ΄ν„°μ™€ λ³΄κ°„ λ°μ΄ν„° κµ¬λ¶„ λ…ν™•

**λ‹¨μ :**
- β ν΄λΌμ΄μ–ΈνΈ λ³µμ΅μ„± μ¦κ°€
- β Gap λ³΄κ°„ λ΅μ§ μ¤‘λ³µ κµ¬ν„ κ°€λ¥μ„±
- β μ‹κ°„μ¶• μ²λ¦¬ λ³µμ΅μ„±

**λ©”λ¨λ¦¬ μν–¥ λ¶„μ„:**
```
1000κ° μ”μ²­ μ‹ μ‹¤μ  700κ° + Gapμ •λ³΄ 5κ°
β†’ 70% λ©”λ¨λ¦¬ μ μ•½
β†’ Gap λ³΄κ°„μ€ ν΄λΌμ΄μ–ΈνΈμ—μ„ view-timeμ—λ§ μ²λ¦¬
```

### Option 3: μ„ νƒμ  μ²λ¦¬ λ°©μ‹

```python
class CandleDataProvider:
    async def get_candles(
        self,
        symbol: str,
        timeframe: str,
        count: int = None,
        include_empty_candles: bool = False,  # λΉ μΊ”λ“¤ ν¬ν•¨ μ—¬λ¶€
        gap_handling: GapHandling = GapHandling.INFO_ONLY  # Gap μ²λ¦¬ λ°©μ‹
    ) -> CandleResult:

        if gap_handling == GapHandling.FILL_SERVER_SIDE:
            # μ„λ²„μ—μ„ λ³΄κ°„ μ²λ¦¬ ν›„ μ™„μ „ν• λ°μ΄ν„° λ°ν™
            return self._get_interpolated_candles(...)
        elif gap_handling == GapHandling.INFO_ONLY:
            # μ‹¤μ  μΊ”λ“¤ + Gap μ •λ³΄λ§ λ°ν™
            return self._get_candles_with_gap_info(...)
        else:  # RAW_ONLY
            # μ‹¤μ  μΊ”λ“¤λ§ λ°ν™
            return self._get_raw_candles_only(...)
```

---

## π“ μ‚¬μ© μ‚¬λ΅€λ³„ μµμ  μ „λµ

### μ‹¤μ‹κ°„ μ°¨νΈ (μµμ‹  100~500κ°)

**νΉμ„±:**
- λ†’μ€ λΉλ„μ μ—…λ°μ΄νΈ
- μ‹κ°μ  μ—°μ†μ„± μ¤‘μ”
- λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μƒλ€μ μΌλ΅ μ μ

**κ¶μ¥ μ „λµ:**
```python
# Pattern: CandleDataProvider μ§μ ‘ + ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„
result = await candle_provider.get_candles(
    symbol="KRW-BTC",
    timeframe="1m",
    count=500,
    gap_handling=GapHandling.INFO_ONLY  # Gap μ •λ³΄λ§ μ „λ‹¬
)

# ν΄λΌμ΄μ–ΈνΈμ—μ„ μ‹¤μ‹κ°„ λ³΄κ°„
chart_data = real_time_interpolate(result.actual_candles, result.gap_info)
```

**μ΄μ :**
- λ©”λ¨λ¦¬ ν¨μ¨μ„± ν™•λ³΄
- λΉ λ¥Έ μ‘λ‹µμ„±
- μ‹κ°μ  μ—°μ†μ„±μ„ μ„ν• ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„

### κΈ°μ μ  λ¶„μ„ (μμ²~μλ§ κ°)

**νΉμ„±:**
- μ •ν™•ν• λ°μ΄ν„° ν•„μ
- κ³„μ‚° μ„±λ¥ μ¤‘μ”
- Gapμ μν–¥μ΄ λ¶„μ„ κ²°κ³Όμ— μ¤‘μ”

**κ¶μ¥ μ „λµ:**
```python
# Pattern: Repository μ°μ„  + μ™„μ „ν• λ°μ΄ν„°
# 1. λ°μ΄ν„° μ™„μ „μ„± ν™•μΈ
if not await repository.is_range_complete(...):
    await candle_provider.collect_missing_data(...)

# 2. λ¶„μ„μ© μ™„μ „ λ°μ΄ν„° μ΅°ν
candles = await repository.get_candles_by_range(..., exclude_empty=False)
# λλ” μ„λ²„μ‚¬μ΄λ“ λ³΄κ°„
candles = await candle_provider.get_candles(..., gap_handling=GapHandling.FILL_SERVER_SIDE)
```

**μ΄μ :**
- λ°μ΄ν„° μ •ν™•μ„± μµμ°μ„ 
- λ¶„μ„ μ•κ³ λ¦¬μ¦μ Gap λ―Όκ°μ„± κ³ λ ¤
- ν• λ² λ΅λ“ ν›„ λ°λ³µ μ‚¬μ©

### λ°±ν…μ¤ν… (μκ°μ›”~μλ…„)

**νΉμ„±:**
- λ€μ©λ‰ λ°μ΄ν„° μ²λ¦¬
- λ©”λ¨λ¦¬ ν¨μ¨μ„± κ·Ήλ„λ΅ μ¤‘μ”
- μ •ν™•μ„±λ³΄λ‹¤ μ²λ¦¬ μ„±λ¥ μ°μ„ 

**κ¶μ¥ μ „λµ:**
```python
# Pattern: Repository μ§μ ‘ + μ¤νΈλ¦¬λ° + μ‹¤μ  μΊ”λ“¤λ§
async def backtest_data_stream(symbol: str, start_date: datetime, end_date: datetime):
    async for chunk in repository.stream_candles_by_range(
        symbol, timeframe, start_date, end_date,
        chunk_size=10000,
        exclude_empty=True  # μ‹¤μ  μΊ”λ“¤λ§
    ):
        yield chunk  # λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μµμ†ν™”
```

**μ΄μ :**
- λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μµμ†ν™” ν•„μ
- Gapμ€ κ±°λ λ¶κ°€λ¥ κµ¬κ°„μΌλ΅ μ²λ¦¬
- μ¤νΈλ¦¬λ°μΌλ΅ λ€μ©λ‰ μ²λ¦¬

### λ‹¤μ¤‘ μ°¨νΈ λ€μ‹λ³΄λ“

**νΉμ„±:**
- μ—¬λ¬ μ”μ²­ λ™μ‹ μ²λ¦¬
- μΊμ‹ ν¨μ¨μ„± μ¤‘μ”
- μΌκ΄€λ μ‚¬μ©μ κ²½ν—

**κ¶μ¥ μ „λµ:**
```python
# Pattern: μΊμ‹ + μ„ νƒμ  μ²λ¦¬
class DashboardCandleService:
    async def get_candles_for_chart(self, chart_config: ChartConfig):
        # μΊμ‹ ν™•μΈ
        if cached := await self.cache.get_candles(...):
            return cached

        # μ°¨νΈ νƒ€μ…μ— λ”°λ¥Έ μµμ  μ „λµ
        if chart_config.type == ChartType.REALTIME:
            return await self._get_realtime_candles(...)
        elif chart_config.type == ChartType.ANALYSIS:
            return await self._get_analysis_candles(...)
```

---

## β οΈ μµμ‹  λ°μ΄ν„° μ™„μ „μ„± λ¬Έμ  λ¶„μ„

### λ¬Έμ  μƒν™©

ν„μ¬ μ‹μ¤ν…μ—μ„ **μ²« μ²­ν¬λ” μ•μ „μ„±μ„ μ„ν•΄ λΉ μΊ”λ“¤ μ²λ¦¬λ¥Ό ν•μ§€ μ•μ**
β†’ μµμ‹  λ°μ΄ν„°μ—λ” ν•­μƒ Gapμ΄ μ΅΄μ¬ν•  κ°€λ¥μ„±
β†’ μ‹¤μ‹κ°„ μ°¨νΈλ‚ μµμ‹  λ¶„μ„μ—μ„ λ°μ΄ν„° λ¶μ™„μ „μ„± λ°μƒ

```
μμ‹: ν„μ¬ μ‹κ°„ 16:30, 1λ¶„λ΄‰ 100κ° μ”μ²­
β”β”€ μ²­ν¬ 1 (16:30~16:11): λΉ μΊ”λ“¤ μ²λ¦¬ μ• ν•¨ β†’ Gap κ°€λ¥μ„± μ΅΄μ¬
β”β”€ μ²­ν¬ 2 (16:10~15:51): λΉ μΊ”λ“¤ μ²λ¦¬ μ μ© β†’ μ™„μ „ν• λ°μ΄ν„°
β””β”€ μ²­ν¬ 3 (15:50~15:31): λΉ μΊ”λ“¤ μ²λ¦¬ μ μ© β†’ μ™„μ „ν• λ°μ΄ν„°
```

### ν•΄κ²° λ°©μ•

#### λ°©μ• 1: ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„ λ°©μ‹

```python
class RealtimeChartRenderer:
    def render_candles(self, result: CandleResult):
        # μµμ‹  κµ¬κ°„μ Gap κ°μ§€
        gaps = detect_recent_gaps(result.actual_candles, result.time_range)

        # λ§μ§€λ§‰ μ ν¨ λ°μ΄ν„°λ΅ λ³΄κ°„
        display_candles = interpolate_from_last_valid(
            result.actual_candles, gaps
        )

        # λ³΄κ°„λ μΊ”λ“¤μ€ μ‹κ°μ μΌλ΅ κµ¬λ¶„ ν‘μ‹
        self.draw_candles(display_candles, highlight_interpolated=True)
```

**μ¥μ :**
- μ„λ²„ λ³µμ΅μ„± μ¦κ°€ μ—†μ
- ν΄λΌμ΄μ–ΈνΈλ³„ λ³΄κ°„ μ •μ±… μ μ© κ°€λ¥
- λ©”λ¨λ¦¬ ν¨μ¨μ„± μ μ§€

**λ‹¨μ :**
- ν΄λΌμ΄μ–ΈνΈ λ΅μ§ λ³µμ΅μ„± μ¦κ°€
- Gap κ°μ§€ λ΅μ§ μ¤‘λ³µ κµ¬ν„ μ„ν—

#### λ°©μ• 2: μµμ‹  μ²­ν¬ νΉλ³„ μ²λ¦¬

```python
class CandleDataProvider:
    async def get_candles(self, ...):
        # κΈ°μ΅΄ λ΅μ§μΌλ΅ μμ§‘
        chunks = await self._collect_chunks(...)

        # μ²« μ²­ν¬(μµμ‹ )μ— λ€ν•΄μ„λ§ ν›„μ²λ¦¬λ΅ λΉ μΊ”λ“¤ λ³΄κ°„
        if chunks and self._is_recent_chunk(chunks[0]):
            chunks[0] = await self._post_process_recent_chunk(chunks[0])

        return self._merge_chunks(chunks)

    async def _post_process_recent_chunk(self, chunk: ChunkInfo):
        # μ•μ „ν• λ²”μ„μ—μ„ λΉ μΊ”λ“¤ ν›„μ²λ¦¬ μ μ©
        return await self.empty_candle_detector.fill_recent_gaps(chunk)
```

**μ¥μ :**
- ν΄λΌμ΄μ–ΈνΈ λ‹¨μμ„± μ μ§€
- μµμ‹  λ°μ΄ν„° μ™„μ „μ„± λ³΄μ¥
- κΈ°μ΅΄ μ•μ „μ„± λ΅μ§ μ μ§€

**λ‹¨μ :**
- μ„λ²„ λ³µμ΅μ„± μ¦κ°€
- μ„±λ¥ μ¤λ²„ν—¤λ“

#### λ°©μ• 3: μ‹¤μ‹κ°„ λ³΄μ • μ‹μ¤ν…

```python
class RealtimeGapCorrector:
    """μ‹¤μ‹κ°„ Gap λ³΄μ • μ‹μ¤ν…"""

    async def correct_realtime_gaps(
        self,
        candles: List[CandleData],
        time_range: TimeRange
    ) -> List[CandleData]:

        # μ‹¤μ‹κ°„ κµ¬κ°„μ—μ„λ§ Gap λ³΄μ • μ μ©
        if self._is_realtime_range(time_range):
            return await self._apply_conservative_gap_filling(candles)

        return candles  # κ³Όκ±° λ°μ΄ν„°λ” λ³΄μ •ν•μ§€ μ•μ
```

### π― κ¶μ¥μ‚¬ν•­: λ°©μ• 2 (μµμ‹  μ²­ν¬ νΉλ³„ μ²λ¦¬)

**μ΄μ :**
1. **μ‚¬μ©μ κ²½ν—**: ν΄λΌμ΄μ–ΈνΈμ—μ„ μ‹ κ²½ μ“Έ ν•„μ” μ—†μ
2. **λ°μ΄ν„° ν’μ§**: μµμ‹  λ°μ΄ν„°λ„ λ†’μ€ μ™„μ „μ„± λ³΄μ¥
3. **μ‹μ¤ν… μΌκ΄€μ„±**: λ¨λ“  λ°μ΄ν„° μ†λΉ„μκ°€ λ™μΌν• ν’μ§ κ²½ν—
4. **ν™•μ¥μ„±**: ν–¥ν›„ μ‹¤μ‹κ°„ κΈ°λ¥ ν™•μ¥ μ‹ κΈ°λ° μ κ³µ

---

## π€ κ¶μ¥ κµ¬ν„ λ΅λ“λ§µ

### Phase 1: κΈ°λ³Έ κµ¬ν„ (μ¦‰μ‹)

```python
# 1. CandleResult λ¨λΈ ν™•μ¥
@dataclass
class CandleResult:
    candles: List[CandleData]
    gap_info: List[GapInfo] = field(default_factory=list)
    is_complete: bool = True
    metadata: CandleMetadata = None

# 2. CandleDataProvider μµμ… μ¶”κ°€
async def get_candles(
    self,
    symbol: str,
    timeframe: str,
    count: int = None,
    include_gaps: bool = False  # λ‹¨μν• μ‹μ‘
) -> CandleResult:
```

**λ©ν‘**: κΈ°μ΅΄ κΈ°λ¥ μ μ§€ν•λ©΄μ„ μƒλ΅μ΄ μµμ… μ¶”κ°€

### Phase 2: μµμ‹  λ°μ΄ν„° λ³΄μ • (μ°¨νΈ MVP ν›„)

```python
# μµμ‹  μ²­ν¬ νΉλ³„ μ²λ¦¬ μ¶”κ°€
class CandleDataProvider:
    def __init__(self, ..., enable_realtime_gap_correction: bool = True):
        self.enable_realtime_gap_correction = enable_realtime_gap_correction

    async def _post_process_realtime_chunk(self, chunk: ChunkInfo):
        # μ•μ „ν• λ²”μ„μ—μ„ λΉ μΊ”λ“¤ ν›„μ²λ¦¬
```

**λ©ν‘**: μµμ‹  λ°μ΄ν„° μ™„μ „μ„± λ¬Έμ  ν•΄κ²°

### Phase 3: μ„±λ¥ μµμ ν™” (ν•„μ”μ‹)

```python
# μ‚¬μ© ν¨ν„΄λ³„ μλ™ μµμ ν™”
class SmartCandleService:
    async def get_candles(self, ..., strategy: DataStrategy = DataStrategy.AUTO):
        # ν΄λ¦¬μ¤ν‹± κΈ°λ° μµμ  μ „λµ μλ™ μ„ νƒ
```

**λ©ν‘**: μ‹¤μ  μ‚¬μ© λ°μ΄ν„° κΈ°λ° μµμ ν™”

### Phase 4: κ³ κΈ‰ κΈ°λ¥ (μ•μ •ν™” ν›„)

- μΊμ‹ μ‹μ¤ν… ν†µν•©
- μ¤νΈλ¦¬λ° API μ§€μ›
- λ‹¤μ¤‘ μ°¨νΈ μµμ ν™”

---

## π“ μ„±λ¥ λ° λ©”λ¨λ¦¬ μν–¥ λ¶„μ„

### λ©”λ¨λ¦¬ μ‚¬μ©λ‰ λΉ„κµ

| λ°μ΄ν„° ν¬κΈ° | λΉ μΊ”λ“¤ ν¬ν•¨ | μ‹¤μ  μΊ”λ“¤λ§ | μ μ•½λ¥  |
|------------|-------------|------------|--------|
| 1,000κ°    | 100MB       | 70MB       | 30%    |
| 10,000κ°   | 1GB         | 700MB      | 30%    |
| 100,000κ°  | 10GB        | 7GB        | 30%    |

### λ„¤νΈμ›ν¬ μ „μ†΅λ‰ λΉ„κµ

| μ‹λ‚λ¦¬μ¤        | λΉ μΊ”λ“¤ ν¬ν•¨ | μ‹¤μ +Gapμ •λ³΄ | μ μ•½λ¥  |
|-----------------|-------------|-------------|--------|
| μ‹¤μ‹κ°„ μ°¨νΈ     | 1MB/μ”μ²­    | 0.7MB/μ”μ²­  | 30%    |
| κΈ°μ μ  λ¶„μ„     | 50MB/μ”μ²­   | 35MB/μ”μ²­   | 30%    |
| λ°±ν…μ¤ν…       | 500MB/μ”μ²­  | 350MB/μ”μ²­  | 30%    |

### CPU μ²λ¦¬ μ‹κ°„ λΉ„κµ

| μ‘μ—…              | μ„λ²„μ‚¬μ΄λ“ λ³΄κ°„ | ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„ | μ°¨μ΄   |
|-------------------|-----------------|-----------------|--------|
| λ°μ΄ν„° μ¤€λΉ„       | 100ms          | 50ms           | -50%   |
| ν΄λΌμ΄μ–ΈνΈ λ λ”λ§ | 50ms           | 80ms           | +60%   |
| **μ΄ μ²λ¦¬ μ‹κ°„**  | **150ms**      | **130ms**      | -13%   |

**κ²°λ΅ **: ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„μ΄ μ•½κ°„ λ” ν¨μ¨μ μ΄λ‚, μ‚¬μ©μ κ²½ν— μΈ΅λ©΄μ—μ„λ” μ„λ²„μ‚¬μ΄λ“ μ²λ¦¬κ°€ μΌκ΄€μ„± μμ

---

## β–οΈ μµμΆ… κ¶μ¥μ‚¬ν•­

### π― λ‹¨κΈ° μ „λµ (μ°¨νΈ MVP)

1. **CandleDataProvider κΈ°λ³Έ μ‚¬μ©**
   - `include_gaps=False` κΈ°λ³Έκ°’μΌλ΅ μ‹¤μ  μΊ”λ“¤λ§ λ°ν™
   - Gap μ •λ³΄λ” λ³„λ„ ν•„λ“λ΅ μ κ³µ
   - ν΄λΌμ΄μ–ΈνΈμ—μ„ ν•„μ”μ‹ λ³΄κ°„ μ²λ¦¬

2. **μµμ‹  λ°μ΄ν„° λ³΄μ • μ¶”κ°€**
   - μ²« μ²­ν¬μ— λ€ν•΄μ„λ§ ν›„μ²λ¦¬λ΅ Gap λ³΄μ •
   - μ•μ „μ„±κ³Ό μ™„μ „μ„±μ κ· ν•μ  ν™•λ³΄

### π€ μ¥κΈ° μ „λµ (μµμ ν™”)

1. **μ‚¬μ© ν¨ν„΄λ³„ μλ™ μµμ ν™”**
   - μ‹¤μ‹κ°„: ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„
   - λ¶„μ„: μ„λ²„μ‚¬μ΄λ“ μ™„μ „ λ°μ΄ν„°
   - λ°±ν…μ¤ν…: Repository μ§μ ‘ + μ‹¤μ  μΊ”λ“¤λ§

2. **μ„ νƒμ  μ²λ¦¬ μ‹μ¤ν…**
   - API μµμ…μΌλ΅ μ²λ¦¬ λ°©μ‹ μ„ νƒ κ°€λ¥
   - κΈ°λ³Έκ°’μ€ ν¨μ¨μ„± μ°μ„ 
   - ν•„μ”μ‹ μ™„μ „μ„± μ°μ„  λ¨λ“ μ κ³µ

### π’΅ ν•µμ‹¬ μ„¤κ³„ μ›μΉ™

1. **ν¨μ¨μ„± μ°μ„ **: κΈ°λ³Έμ μΌλ΅ λ©”λ¨λ¦¬/λ„¤νΈμ›ν¬ ν¨μ¨μ„± μµλ€ν™”
2. **μ„ νƒμ  μ™„μ „μ„±**: ν•„μ”ν• κ²½μ°μ—λ§ μ™„μ „ν• λ°μ΄ν„° μ κ³µ
3. **ν΄λΌμ΄μ–ΈνΈ λ‹¨μμ„±**: λ³µμ΅ν• λ΅μ§μ€ μ„λ²„μ—μ„ μ²λ¦¬
4. **ν™•μ¥ κ°€λ¥μ„±**: ν–¥ν›„ μ”κµ¬μ‚¬ν•­ λ³€ν™”μ— μ μ—°ν•κ² λ€μ‘

---

## π“ κµ¬ν„ κ°€μ΄λ“λΌμΈ

### 1. CandleResult λ¨λΈ μ„¤κ³„

```python
@dataclass
class CandleResult:
    """μΊ”λ“¤ μ΅°ν κ²°κ³Ό - ν¨μ¨μ„±κ³Ό μ™„μ „μ„± μ •λ³΄ λ¨λ‘ μ κ³µ"""

    # ν•µμ‹¬ λ°μ΄ν„°
    candles: List[CandleData]              # μ‹¤μ  μΊ”λ“¤λ§ (κΈ°λ³Έ)

    # Gap μ²λ¦¬ μ •λ³΄
    gap_info: List[GapInfo] = field(default_factory=list)
    is_complete: bool = True

    # λ©”νƒ€λ°μ΄ν„°
    time_range: TimeRange = None
    collection_stats: CollectionStats = None

    # ν—¬νΌ λ©”μ„λ“
    def get_interpolated_candles(self) -> List[CandleData]:
        """ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„μ© ν—¬νΌ"""
        return interpolate_gaps(self.candles, self.gap_info)

    def get_memory_usage_mb(self) -> float:
        """λ©”λ¨λ¦¬ μ‚¬μ©λ‰ μΈ΅μ •"""
        return calculate_memory_usage(self.candles, self.gap_info)
```

### 2. API μ„¤κ³„ κ°€μ΄λ“λΌμΈ

```python
# λ…ν™•ν•κ³  ν™•μ¥ κ°€λ¥ν• API μ„¤κ³„
async def get_candles(
    self,
    symbol: str,
    timeframe: str,
    count: int = None,
    to: datetime = None,
    end: datetime = None,

    # μ²λ¦¬ μµμ…
    gap_handling: GapHandling = GapHandling.INFO_ONLY,
    realtime_correction: bool = True,

    # μ„±λ¥ μµμ…
    strategy: DataStrategy = DataStrategy.AUTO
) -> CandleResult:
```

### 3. ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„ μ ν‹Έλ¦¬ν‹°

```python
class CandleGapInterpolator:
    """ν΄λΌμ΄μ–ΈνΈμ© Gap λ³΄κ°„ μ ν‹Έλ¦¬ν‹°"""

    @staticmethod
    def interpolate_linear(candles: List[CandleData], gaps: List[GapInfo]) -> List[CandleData]:
        """μ„ ν• λ³΄κ°„"""

    @staticmethod
    def interpolate_last_value(candles: List[CandleData], gaps: List[GapInfo]) -> List[CandleData]:
        """λ§μ§€λ§‰ κ°’ μ μ§€ λ³΄κ°„"""

    @staticmethod
    def detect_gaps(candles: List[CandleData], timeframe: str) -> List[GapInfo]:
        """Gap μλ™ κ°μ§€"""
```

---

## π” κ²°λ΅ 

μΊ”λ“¤ λ°μ΄ν„° μ‹μ¤ν…μ€ μ΄λ―Έ ν›λ¥­ν• κΈ°λ°μ„ κ°–μ¶”κ³  μμµλ‹λ‹¤. ν•µμ‹¬μ€ **ν¨μ¨μ„±μ„ κΈ°λ³ΈμΌλ΅ ν•λ, ν•„μ”μ‹ μ™„μ „μ„±μ„ μ„ νƒν•  μ μλ” μ μ—°ν• κµ¬μ΅°**λ¥Ό λ§λ“λ” κ²ƒμ…λ‹λ‹¤.

**μ¦‰μ‹ μ μ© κ¶μ¥μ‚¬ν•­**:
1. μ‹¤μ  μΊ”λ“¤λ§ λ°ν™ν•λ” κ²ƒμ„ κΈ°λ³Έκ°’μΌλ΅ μ„¤μ •
2. Gap μ •λ³΄λ” λ³„λ„ ν•„λ“λ΅ μ κ³µ
3. μµμ‹  μ²­ν¬μ— λ€ν•΄μ„λ§ ν›„μ²λ¦¬λ΅ Gap λ³΄μ •
4. ν΄λΌμ΄μ–ΈνΈ λ³΄κ°„ μ ν‹Έλ¦¬ν‹° μ κ³µ

μ΄λ¥Ό ν†µν•΄ λ©”λ¨λ¦¬ ν¨μ¨μ„±μ„ κ·Ήλ€ν™”ν•λ©΄μ„λ„ λ°μ΄ν„° μ™„μ „μ„± μ”κµ¬μ‚¬ν•­μ„ μ¶©μ΅±ν•  μ μλ” κ· ν• μ΅ν μ‹μ¤ν…μ„ κµ¬μ¶•ν•  μ μμ„ κ²ƒμ…λ‹λ‹¤.

**κ²€ν†  λ° ν”Όλ“λ°±μ„ ν†µν•΄ μµμΆ… μ„¤κ³„ λ°©ν–¥μ„ κ²°μ •ν•μ‹κΈ° λ°”λλ‹λ‹¤.** π€
