대부분의 파이썬 금융 지표 패키지는 거래가 없는 빈 캔들(zero-volume candle)에 대해 **특별한 처리를 하지 않고, 입력된 데이터 그대로를 사용**합니다. 패키지는 데이터의 행(row) 하나를 하나의 유효한 시간 단위(예: 1분, 1일)로 간주하고 수학적 계산만 수행하기 때문입니다.

따라서 데이터에 빈 캔들을 어떻게 표현하여 전달하는지가 분석 결과에 큰 영향을 미치며, 이는 전적으로 **데이터를 준비하는 사용자의 책임**입니다.

-----

### \#\# 파이썬 금융 지표 패키지의 일반적인 처리 방식 🤔

패키지(e.g., `pandas-ta`, `TA-Lib`, `bt`)에 거래량이 0인 데이터를 전달하면, 각 지표는 다음과 같이 반응합니다.

  * **가격 기반 지표 (이동평균, RSI, MACD, 볼린저 밴드 등):**

      * 거래가 없으면 보통 시가(Open), 고가(High), 저가(Low), 종가(Close)가 모두 이전 캔들의 종가와 동일합니다.
      * 패키지는 이 가격(변동 없음)을 그대로 계산에 포함합니다.
      * **결과:** 이동평균은 이전 값에 수렴하며 횡보하고, RSI는 50에 가까워지며, ATR(평균 변동폭)은 감소합니다. 즉, **모든 변동성과 모멘텀이 죽은 것으로 해석**됩니다.

  * **거래량 기반 지표 (OBV, MFI 등):**

      * 거래량(Volume)이 0으로 입력되었으므로, 이 값을 그대로 사용합니다.
      * **결과:** OBV 값은 변하지 않고, MFI는 가격 변동이 없어 계산이 왜곡될 수 있습니다. **거래 에너지가 완전히 소멸된 것으로 해석**됩니다.

-----

### \#\# 금융 지표 계산 시 데이터 제공 방법 ✅

거래가 없는 기간을 처리하는 방법은 분석의 목적에 따라 달라지며, 주로 아래 세 가지 방법 중 하나를 선택합니다.

#### \#\#\# 1. 그대로 제공 (As-Is)

가장 간단한 방법으로, 거래가 없었던 기간을 명시적으로 표현합니다.

  * **방법:** 해당 기간의 `volume`은 `0`으로 설정하고, `open`, `high`, `low`, `close`는 모두 **직전 캔들의 `close` 가격으로 통일**합니다.
  * **언제 사용하나?:** 특정 자산이 거래 중지되었거나, 유동성이 극도로 낮은 상황 자체를 분석에 반영하고 싶을 때 사용합니다.
  * **주의점:** 위에서 설명한 것처럼 변동성 및 모멘텀 지표가 왜곡될 수 있습니다.

<!-- end list -->

```python
# 예시: 2025-09-25 10:02에 거래가 없었을 경우
#             open    high     low   close  volume
# timestamp
# 2025-09-25 10:01  10000.0 10100.0  9900.0 10050.0   150.0
# 2025-09-25 10:02  10050.0 10050.0 10050.0 10050.0     0.0  # <-- 빈 캔들 데이터
# 2025-09-25 10:03  10050.0 10200.0 10050.0 10150.0   120.0
```

#### \#\#\# 2. 데이터 제거 (Remove)

거래가 없었던 기간은 아예 존재하지 않는 것처럼 취급하는 방식입니다.

  * **방법:** 데이터프레임에서 `volume`이 0인 행 전체를 삭제합니다.
  * **언제 사용하나?:** 주말이나 공휴일처럼 시장이 아예 열리지 않은 기간을 제외하고, 순수하게 거래가 발생한 캔들만으로 지표를 계산하고 싶을 때 유용합니다.
  * **주의점:** 시간 간격이 불규칙해지므로, 시간의 연속성을 가정하는 특정 시계열 분석 모델에는 부적합할 수 있습니다.

<!-- end list -->

```python
import pandas as pd

# 거래량이 0보다 큰 데이터만 남김
df_filtered = df[df['volume'] > 0].copy()

# 이제 df_filtered를 지표 계산 함수에 전달
# 예: df_filtered.ta.sma(length=20, append=True)
```

#### \#\#\# 3. 데이터 채우기 (Forward Fill) - 가장 권장되는 방식

데이터를 제거하는 대신, 이전 상태가 그대로 유지되었다고 가정하여 값을 채워 넣는 방식입니다. 특히 여러 자산을 동시에 다루는 포트폴리오 백테스팅에서 필수적입니다.

  * **방법:** `ffill()` (Forward Fill)을 사용하여 누락된 기간의 가격 데이터를 직전 값으로 채우고, 거래량은 0으로 채웁니다.
  * **언제 사용하나?:** 백테스팅 시 특정 자산은 거래가 없었지만 다른 자산은 거래되었을 경우, 포트폴리오의 시간축을 일관성 있게 유지하고 싶을 때 사용합니다. 데이터 누락으로 인한 미래 데이터 참조(Lookahead Bias)를 방지하는 가장 견고한 방법입니다.

<!-- end list -->

```python
import pandas as pd

# 1. 전체 기간에 대한 완전한 타임 인덱스 생성
full_time_index = pd.date_range(start=df.index.min(), end=df.index.max(), freq='T') # 'T': 1분봉 기준

# 2. 데이터를 완전한 타임 인덱스에 재배열 (빈 곳은 NaN으로 채워짐)
df_reindexed = df.reindex(full_time_index)

# 3. ffill()로 가격 데이터 채우기
price_cols = ['open', 'high', 'low', 'close']
df_reindexed[price_cols] = df_reindexed[price_cols].ffill()

# 4. 거래량은 0으로 채우기
df_reindexed['volume'] = df_reindexed['volume'].fillna(0)

# 이제 df_reindexed를 지표 계산 함수에 전달
```

### \#\# 결론 및 권장 사항

| 방법 | 장점 | 단점 | 추천 상황 |
| :--- | :--- | :--- | :--- |
| **1. 그대로 제공** | 구현이 가장 간단함 | 지표 왜곡 가능성 큼 | 거래 중단 등 특정 이벤트를 반영할 때 |
| **2. 데이터 제거** | 계산이 깔끔하고 지표 왜곡이 적음 | 시간의 연속성이 깨짐 | 단일 자산의 기술적 분석 시 |
| **3. 데이터 채우기 (`ffill`)** | **시간 연속성 유지, 백테스팅에 적합** | 데이터 전처리 과정이 필요함 | **포트폴리오 백테스팅, 엄밀한 시계열 분석** |

**일반적인 금융 분석이나 백테스팅 환경에서는 `방법 3: 데이터 채우기(ffill)`이 가장 표준적이고 신뢰성 높은 접근 방식입니다.**
