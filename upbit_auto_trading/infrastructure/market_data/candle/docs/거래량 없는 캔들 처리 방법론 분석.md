
# **금융 시계열 데이터의 제로 볼륨 캔들 및 데이터 갭 처리에 대한 퀀트 분석가 가이드**

## **서론**

퀀트 트레이딩 시스템 개발에서 금융 시계열 데이터의 '거래량 없는 기간(zero-volume candles)' 또는 데이터 누락(data gaps)을 처리하는 문제는 단순한 데이터 전처리(ETL) 작업을 넘어, 전략의 알파(alpha), 리스크 모델링, 그리고 백테스팅 결과의 통계적 유효성에 지대한 영향을 미치는 핵심적인 도전 과제입니다. 이 문제를 어떻게 다루느냐에 따라 성공적인 전략과 실패한 전략이 갈릴 수 있으며, 부적절한 데이터 처리 방식은 연구 단계에서 라이브 운영으로 전환할 때 발생하는 가장 흔하고 치명적인 실패의 원인 중 하나로 작용합니다.

본 보고서는 파이썬(Pandas) 기반의 트레이딩 시스템을 구축하는 개발자를 위해, 제로 볼륨 캔들 및 데이터 갭 처리 문제에 대한 깊이 있고 실질적인 분석을 제공하는 것을 목표로 합니다. 특히, 정규 거래 시간이 정해진 주식 시장과 24시간 운영되는 암호화폐 시장의 구조적 차이는 단일한 해결책을 적용하는 것이 얼마나 순진하고 위험한 접근인지를 명확히 보여줍니다.1

본 문서는 기술적 분석 라이브러리의 내부 동작 원리부터 업계 표준 방법론, 각 처리 방식의 상세 비교 분석, 그리고 기술 지표에 미치는 구체적인 영향까지 체계적으로 다룰 것입니다. 최종적으로는 백테스팅의 신뢰성과 실거래 환경의 일관성을 모두 확보할 수 있는 최적의 데이터 처리 방법론과 그 구현 청사진을 제시하여, 통계적으로 견고하고 실전에서 신뢰할 수 있는 트레이딩 시스템을 구축하는 데 필요한 핵심 지침을 제공하고자 합니다.

---

## **섹션 1: 기술적 분석 라이브러리의 내부 계산 메커니즘**

서로 다른 기술적 분석 라이브러리들이 불완전한 데이터를 어떻게 처리하는지 이해하는 것은 견고한 시스템을 구축하기 위한 첫걸음입니다. 이 라이브러리들을 '블랙박스'로 취급하지 않고 내부 동작 방식을 명확히 파악해야만, 데이터 처리 방식 선택에 따른 결과를 예측하고 제어할 수 있습니다.

### **1.1. NaN 전파의 원칙: TA-Lib의 표준**

TA-Lib는 C로 작성된 핵심 라이브러리와 이를 감싸는 파이썬 래퍼(wrapper)로 구성되어 있으며, NaN(Not a Number) 값을 명시적으로 '전파(propagate)'하도록 설계되었습니다.4 이는 이동평균(SMA)과 같은 계산의 입력 윈도우 내에 하나의

NaN 값이라도 포함되면, 해당 기간의 출력값 역시 NaN이 된다는 것을 의미합니다. 이 NaN 출력은 최초의 입력 NaN 값이 룩백 기간(lookback period)을 완전히 벗어날 때까지 지속됩니다.

이러한 동작 방식은 결정론적이며 수학적으로 순수합니다. 라이브러리가 데이터에 대해 임의의 가정을 하지 않기 때문에, 퀀트 분석가에게는 매우 바람직한 특성입니다. 시스템은 숨겨진 가정 하에 잘못된 값을 계산하는 대신, 개발자에게 데이터 처리 방식을 명시적으로 결정하도록 강제합니다. 예를 들어, 제로 볼륨 캔들의 OHLCV 데이터를 NaN으로 표현할 경우, 이 값은 해당 캔들이 룩백 기간에 포함되는 동안 기술 지표 계산을 '오염'시켜, 전략이 일시적으로 작동 불능 상태에 빠지게 만들 수 있습니다. 100주기 SMA 계산에 NaN이 하나 포함되면, 최소 100기간 동안 NaN이 출력되는 결과로 이어질 수 있습니다.4

### **1.2. Pandas 네이티브 라이브러리의 암묵적 동작 (pandas-ta, finta)**

pandas-ta나 finta와 같은 라이브러리들은 Pandas와 NumPy 위에 직접 구축되어 있습니다.6 따라서 이들의 제로 볼륨 데이터 처리 방식은 해당 프레임워크의 기본 산술 연산 규칙에 의해 결정됩니다. 예를 들어, 거래량으로 나누는 연산(예: 일부 거래량 가중 평균)이 포함된 지표는 거래량이 0일 경우 NumPy의 표준 동작에 따라

inf(무한대) 또는 NaN을 반환하게 됩니다.

이는 라이브러리가 명시적인 '제로 볼륨 처리 정책'을 갖는 것이 아니라, 수학적 연산의 결과로서 발생하는 *암묵적* 동작입니다. 이로 인해 예기치 않은 오류나 NaN 값이 발생할 수 있으며, TA-Lib의 명시적인 전파 방식에 비해 원인을 추적하기가 더 어려울 수 있습니다. pandas-ta의 경우, TA-Lib를 백엔드로 사용하도록 설정하는 옵션(talib=False 인자)을 제공하므로, 설정에 따라 동작 방식이 근본적으로 달라질 수 있다는 점에 유의해야 합니다.10

### **1.3. 성능 중심의 C 기반 라이브러리 (tulipy)**

tulipy는 고성능 C 라이브러리인 Tulip Indicators의 파이썬 래퍼입니다.11

TA-Lib와 마찬가지로 핵심 로직이 저수준 언어로 구현되어 있습니다. NVI(Negative Volume Index)와 같은 특정 지표의 문서를 살펴보면, 거래량이 나누는 값(divisor)이 아닌 조건문(if volume decreases...)으로 사용됨을 알 수 있습니다.14

OBV, NVI, PVI와 같이 거래량을 조건으로 사용하는 지표의 경우, 거래량 값 0은 유효한 수학적 입력으로 간주되어 지표의 논리에 따라 처리됩니다. 예를 들어, OBV는 거래량이 0일 때 이전 값과 동일하게 유지됩니다(OBVt​=OBVt−1​+0). 이는 정확하고 예상된 동작입니다. 하지만 MFI(Market Facilitation Index)처럼 암묵적으로 거래량으로 나눌 수 있는 지표의 경우 15, C 구현체 내부에 반드시 0으로 나누기 오류를 방지하는 로직(guard)이 포함되어 있어야 합니다. 이 경우 보통 0,

NaN, 또는 이전 값을 반환하도록 처리되지만, 이러한 세부 동작은 C 소스 코드에 따라 다르며 파이썬 래퍼의 문서에는 명확히 기술되지 않을 수 있습니다.

### **1.4. 요약 및 핵심 고려사항: '래퍼 연쇄 명령'**

사용자가 호출하는 라이브러리의 동작은 그 라이브러리 자체의 코드가 아닌, 의존성 체인의 더 깊은 곳에 있는 하위 라이브러리에 의해 결정될 수 있습니다. 예를 들어, pandas-ta는 TA-Lib를 백엔드로 사용할 수 있으며 10, 다른 라이브러리는

tulipy를 래핑할 수 있습니다.16 이는 개발자가 상위 라이브러리의 동작을 예측하기 위해 그 기반이 되는 계산 엔진까지 이해해야 함을 시사합니다. 기본

pandas-ta 설정(순수 pandas/NumPy)에서 잘 작동하던 전략이 talib=True 플래그를 활성화하는 순간, NaN 처리 정책이 암묵적 산술 규칙에서 명시적 전파 방식으로 바뀌면서 예기치 않게 실패하거나 다른 결과를 생성할 수 있습니다. 이는 시스템의 안정성과 재현성을 위해 반드시 고려해야 할 중요한 지점입니다.

| 표 1: 제로 볼륨 데이터에 대한 기술 분석 라이브러리별 동작 방식 |  |  |  |  |
| :---- | :---- | :---- | :---- | :---- |
| **지표** | **라이브러리** | **기반 엔진** | **volume=0을 나누는 경우** | **NaN 입력 처리 방식** |
| **SMA, RSI, ATR** | TA-Lib | C | 해당 없음 | NaN 전파 |
| (가격 기반) | pandas-ta (기본) | pandas/NumPy | 해당 없음 | pandas/NumPy 규칙 따름 (결과 NaN) |
|  | finta | pandas/NumPy | 해당 없음 | pandas/NumPy 규칙 따름 (결과 NaN) |
|  | tulipy | C | 해당 없음 | C 구현에 따라 다름 (일반적으로 NaN 전파) |
| **OBV** | TA-Lib | C | 해당 없음 | NaN 전파 |
| (거래량 기반) | pandas-ta (기본) | pandas/NumPy | 해당 없음 (값 변동 없음) | pandas/NumPy 규칙 따름 (결과 NaN) |
|  | finta | pandas/NumPy | 해당 없음 (값 변동 없음) | pandas/NumPy 규칙 따름 (결과 NaN) |
|  | tulipy | C | 해당 없음 (값 변동 없음) | C 구현에 따라 다름 (일반적으로 NaN 전파) |
| **MFI** | TA-Lib | C | 0으로 나누기 방지 (결과 0 또는 NaN) | NaN 전파 |
| (거래량 가중) | pandas-ta (기본) | pandas/NumPy | inf 또는 NaN 반환 | pandas/NumPy 규칙 따름 (결과 NaN) |

---

## **섹션 2: 데이터 전처리를 위한 업계 표준 방법론**

라이브러리의 기계적인 동작을 넘어, 금융 이론과 업계의 모범 사례에 기반한 데이터 처리 원칙을 정립하는 것이 중요합니다. 이 섹션에서는 데이터 갭을 다루는 지침을 설정하며, 시계열 데이터의 시간적 무결성을 보존하는 것이 타협할 수 없는 최우선 과제임을 강조합니다.

### **2.1. 대원칙: 인과성 보존 및 미래 데이터 참조 편향 방지**

백테스팅에서 가장 중요한 단일 원칙은 시간 $t$에서의 의사결정은 오직 시간 $t$ 또는 그 이전에 알려진 정보만을 사용해야 한다는 것입니다. 미래의 정보를 사용하는 것을 '미래 데이터 참조 편향(lookahead bias)'이라고 하며, 이는 백테스팅의 유효성을 근본적으로 훼손합니다.17 데이터 처리 방법을 선택할 때 항상 "실제 거래 환경에서 이 정보에 기반하여 행동할 수 있었는가?"라는 질문을 던져야 합니다.20

예를 들어, 시간 $t$의 누락된 값을 채우기 위해 $t-1$과 $t+1$ 사이를 선형 보간(linear interpolation)하는 것은 명백한 미래 데이터 참조 편향입니다. 이는 실제 거래에서는 불가능한, 과도하게 낙관적인 백테스트 결과를 낳게 됩니다.20 반면, 전방 채우기(forward-fill)는 오직 과거의 정보(마지막으로 알려진 값)만을 사용하기 때문에 인과성을 해치지 않아 일반적으로 허용됩니다.22

### **2.2. 데이터 갭의 분류: 모든 누락 데이터는 동등하지 않다**

데이터 갭을 효과적으로 처리하기 위해서는 그 발생 원인을 명확히 구분해야 합니다. 원인에 따라 적절한 처리 방법이 달라지기 때문입니다.

* **유형 1: 구조적 갭 (주식 시장):** 주말, 공휴일, 또는 시장 마감과 다음 날 개장 사이의 시간처럼 자산군의 특성상 예측 가능하고 보편적으로 발생하는 갭입니다.3 이는 '누락된 데이터'가 아니라 '거래가 없는 기간'을 의미합니다.
* **유형 2: 유동성 갭 (주식 및 암호화폐):** 정규 거래 시간 내에 발생하지만 거래량이 0인 경우입니다. 비유동성 주식의 장전 시간외 거래, 개별 주식의 거래 정지, 또는 거래량이 적은 알트코인에서 나타날 수 있습니다.22 이는 그 자체로 시장의 관심 부족을 나타내는 중요한 정보입니다.
* **유형 3: 데이터 피드 갭 (주식 및 암호화폐):** 데이터 제공업체의 기술적 문제로 인해 존재해야 할 캔들이 전달되지 않는 경우입니다.27 이것이 진정한 의미의 '누락된 데이터'입니다.

### **2.3. 자산별 처리 프로토콜**

* **주식:** 구조적 갭(유형 1)에 대해서는 데이터를 인위적으로 생성해서는 안 됩니다. 주식 시계열은 본질적으로 불연속적입니다. ATR(Average True Range)의 True Range 계산식은 이러한 갭을 다루기 위해 현재 고가/저가를 *이전 종가*와 비교하도록 특별히 설계되었습니다.15 유동성 갭(유형 2)의 경우, 제로 볼륨 캔들의 존재는 유효한 정보로 간주해야 합니다.
* **암호화폐:** 24시간 거래되는 시장 구조상 모든 갭은 비정상적인 상황(유형 2 또는 3)으로 간주됩니다.27 BTC/USD와 같은 주요 페어의 갭은 데이터 피드 문제(유형 3)일 가능성이 높고, 신규 소형 코인의 갭은 유동성 부족(유형 2)일 가능성이 높습니다. 특히 암호화폐 시장에서는 상장 폐지된 페어로 인해 영구적인 데이터 갭이 발생하는 '생존 편향(survivorship bias)' 문제가 심각하게 고려되어야 합니다.27

### **2.4. 백테스팅과 실거래 환경의 일치 의무**

백테스팅 시뮬레이션과 라이브 트레이딩 환경에서 사용되는 데이터 처리 파이프라인은 반드시 *동일해야* 합니다.32 만약 실거래 시스템이 데이터 패킷 누락 시 마지막으로 수신한 가격을 사용한다면, 백테스터도 정확히 동일한 방식으로 동작해야 합니다. 이 두 환경 간의 불일치는 실거래 성과가 백테스트 결과에 크게 못 미치는 주된 원인 중 하나입니다.

데이터 갭을 단순히 '수정'해야 할 문제로 보는 대신, 정교한 전략은 이를 정보의 원천으로 활용할 수 있습니다. 특히 유동성 갭(유형 2)은 시장의 관심도와 변동성에 대한 강력한 신호입니다.26 제로 볼륨 캔들은 이러한 현상의 극단적인 표현입니다. 따라서 갭을 메우는 데 그치지 않고, 제로 볼륨 기간의

*빈도*나 *지속 시간*을 머신러닝 모델의 피처(feature)로 사용하거나, "최근 5개 봉 동안 거래가 없었다면 진입하지 않는다"와 같은 필터 규칙으로 활용할 수 있습니다. 이는 데이터 정제라는 수동적 관점에서 벗어나, 알파를 추출하는 능동적 피처 엔지니어링의 관점으로 문제를 재정의하는 것입니다.

---

## **섹션 3: 데이터 처리 기법 비교 분석**

이 섹션에서는 사용자의 요청에 따라 세 가지 주요 데이터 처리 방법을 (주식 vs 암호화폐) × (백테스팅 vs 실거래)라는 시나리오 매트릭스에 따라 심층적으로 비교 분석합니다.

### **3.1. 방법 1: 데이터 유지 (Provide As-Is)**

* **설명:** 원본 데이터를 그대로 기술 지표 계산에 사용합니다. 시간 축에는 캔들이 존재하지만, 거래량은 0입니다. 일반적으로 이 경우 시가 \= 고가 \= 저가 \= 종가 \= 이전 종가의 형태를 가집니다.
* **분석:**
  * **주식/암호화폐:** 비유동성 자산이나 특정 거래 시간(예: 장전 시간외)에서 거래가 없었음을 명확히 나타냅니다. 이는 시장 미시구조나 유동성을 모델링하는 전략에 매우 유용한 정보입니다.
  * **백테스팅:** 수학적으로 가장 순수한 접근 방식이지만, 섹션 1에서 논의한 바와 같이 기술 지표와 전략 로직이 제로 볼륨 입력을 견딜 수 있도록 견고하게 설계되어야 합니다. 부주의하게 처리할 경우 0으로 나누기 오류를 유발할 수 있습니다.
  * **실거래:** 이는 '실제의 모습(ground truth)'입니다. 실거래 시스템은 이러한 캔들을 수신하게 되므로, 시스템 로직은 이를 처리할 수 있어야만 합니다.
* **추천 시나리오:** 거래량의 부재 자체를 신호로 사용하거나 시장 유동성을 명시적으로 모델링하는 전략에 가장 적합합니다. 또한, 인과성을 해치지 않는 변환을 적용하기 전의 기본 입력 데이터 형태로 권장됩니다.

### **3.2. 방법 2: 데이터 제거 (Remove)**

* **설명:** 거래량이 0인 캔들(행)을 데이터프레임에서 완전히 삭제합니다. 이로 인해 datetime 인덱스는 더 이상 고정된 시간 간격을 갖지 않는 불규칙한 시계열이 됩니다.
* **분석:**
  * **주식/암호화폐:** 이 방식은 시간 축의 무결성을 파괴합니다. 1시간 봉 시계열에서 캔들 하나를 제거하면, 연속된 두 데이터 포인트 사이에 2시간의 간격이 생깁니다.
  * **백테스팅:** 고정된 시간 간격을 가정하는 대부분의 표준 기술 지표에 심각한 문제를 일으킵니다. 20주기 이동평균은 이제 시간적으로 비연속적인 기간에 대해 계산되어 그 의미가 왜곡됩니다. 틱 데이터나 시간 기반이 아닌 봉(예: 거래량 봉, 금액 봉)을 사용하는 전략에는 적용 가능할 수 있으나, 일반적인 캔들 기반 분석과는 양립하기 어렵습니다.
  * **실거래:** 실거래 환경에서는 시간의 흐름을 '제거'할 수 없습니다. 시간은 거래 활동과 무관하게 계속 흐릅니다. 따라서 이 방법은 백테스트 데이터 구조와 실제 현실 사이에 심각한 괴리를 만듭니다.
* **추천 시나리오:** 시간 기반 전략에서는 강력히 비권장됩니다. 사건 발생 사이의 시간이 중요하지 않은 이벤트 기반 모델에만 제한적으로 적용할 수 있습니다.

### **3.3. 방법 3: 전방 채우기 (Forward Fill)**

* **설명:** 누락되었거나 거래량이 0인 캔들을 이전 캔들의 값으로 채웁니다. OHLC 가격 데이터는 이전 종가로 채워(시가=고가=저가=종가=이전\_종가), 시간의 연속성을 유지합니다. 여기서 결정적으로 중요한 점은, **거래량(Volume)은 이전 값으로 채우는 것이 아니라 반드시 0으로 채워야 한다는 것**입니다.
* **분석:**
  * **주식/암호화폐:** 이 방법은 대부분의 기술 지표가 요구하는 시계열 인덱스의 규칙성을 보존합니다. 가격 변동이 없고 거래가 발생하지 않은 비활성 기간을 정확하게 모델링합니다.
  * **백테스팅:** 섹션 5에서 자세히 다룰 인과적(causal) 방식으로 적용된다는 전제 하에, 깨끗하고 연속적인 시계열을 생성하기 위한 가장 일반적이고 널리 인정받는 방법입니다. 미래 데이터 참조 편향을 피하면서 22,
    NaN이나 0으로 나누기 오류와 관련된 수학적 문제를 방지합니다.
  * **실거래:** 견고한 실거래 시스템의 동작 방식을 완벽하게 모방합니다. 데이터 피드가 잠시 중단될 경우, 시스템은 새로운 업데이트가 도착할 때까지 마지막으로 알려진 상태(가격 등)를 기반으로 작동해야 합니다.
* **추천 시나리오:** 대부분의 시간 기반 퀀트 전략을 위한 기본적이고 가장 신뢰할 수 있는 방법입니다. 시계열 규칙성, 수학적 안정성, 인과적 무결성 사이에서 최상의 균형을 제공합니다.

| 표 2: 제로 볼륨 캔들 처리 방법론 결정 매트릭스 |  |  |  |  |  |  |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| **방법** | **미래 데이터 참조 편향 위험** | **수학적 안정성** | **시계열 규칙성** | **시장 현실성 (주식)** | **시장 현실성 (암호화폐)** | **실거래 환경 일치도** |
| **1\. 데이터 유지 (As-Is)** | 낮음 | 낮음 (0으로 나누기 위험) | 높음 | 높음 | 높음 | 높음 |
| **2\. 데이터 제거 (Remove)** | 낮음 | 중간 | 매우 낮음 (시간 축 파괴) | 매우 낮음 | 매우 낮음 | 매우 낮음 |
| **3\. 전방 채우기 (Forward Fill)** | 낮음 (인과적 적용 시) | 높음 | 높음 | 높음 | 높음 | 높음 |

---

## **섹션 4: 주요 기술 지표에 미치는 영향**

이 섹션에서는 섹션 3에서 분석한 데이터 처리 방식들이 실제 기술 지표 값에 어떻게 전파되어 전략 신호에 영향을 미치는지 구체적인 사례를 통해 설명합니다. 이를 통해 추상적인 데이터 처리 개념이 실제 트레이딩 결과에 미치는 영향을 가시적으로 이해할 수 있습니다.

### **4.1. 가격 기반 지표 (이동평균, RSI)**

* **데이터 유지 / 전방 채우기:** 이 두 방법은 가격이 이전 종가로 고정된다는 점에서 동일한 영향을 미칩니다. 가격이 정체되어 있으므로, 이동평균은 이 정적인 가격 쪽으로 점차 '끌려오게' 됩니다. 상승분과 하락분의 상대적 크기를 측정하는 RSI는 가격 변화가 없으므로 중립값인 50을 향해 수렴하게 됩니다. 이는 시장이 '교착 상태'에 빠졌음을 정확하게 반영하는 결과입니다.
* **데이터 제거:** 지표는 갭을 건너뛰고 계산됩니다. 이는 실질적으로 룩백 기간을 시간적으로 단축시키고, 시간상 멀리 떨어진 두 가격 지점을 마치 인접한 것처럼 연결하는 효과를 낳습니다. 결과적으로 지표는 훨씬 더 민감하고 노이즈가 많은 값을 출력하게 됩니다.

### **4.2. 변동성 지표 (ATR) 와 숨겨진 위험**

데이터 처리 방식이 변동성 지표에 미치는 영향은 특히 치명적일 수 있습니다. ATR은 True Range(TR)의 평균으로 계산되며, TR은 max(고가 \- 저가, abs(고가 \- 이전\_종가), abs(저가 \- 이전\_종가))로 정의됩니다.15

만약 전방 채우기(Forward Fill)를 사용하면, 제로 볼륨 캔들의 값은 고가 \= 저가 \= 이전\_종가가 됩니다. 이 값을 TR 공식에 대입하면, 고가 \- 저가 \= 0, abs(고가 \- 이전\_종가) \= 0, abs(저가 \- 이전\_종가) \= 0이 되어 해당 기간의 True Range는 0이 됩니다.

이는 제로 볼륨 기간이 ATR 계산에 0이라는 값을 주입하여, **계산된 변동성을 인위적으로 그리고 부정확하게 억제하는 결과**를 낳습니다. ATR을 손절매 설정이나 포지션 크기 결정에 사용하는 전략은 이 왜곡된 값 때문에 위험할 정도로 타이트한 손절매를 설정하거나 과도한 규모의 포지션에 진입하게 될 수 있습니다. 이는 시장이 실제보다 덜 변동적인 것처럼 착각하게 만들어, 잠재적으로 큰 손실로 이어질 수 있는 매우 중요하고 발견하기 어려운 실패 지점입니다.

### **4.3. 거래량 기반 지표 (OBV)**

* **데이터 유지 / 전방 채우기:** 거래량을 0으로 처리하면 OBV는 수평선을 그리게 됩니다(OBVt​=OBVt−1​). 이는 수학적으로나 개념적으로 완벽하게 올바른 동작입니다. 거래 활동이 없었으므로 누적 거래량 압력에 변화가 없음을 정확히 보여줍니다.
* **데이터 제거:** OBV 계산은 해당 시간 단계를 완전히 건너뛰게 됩니다. 다음 계산은 $OBV\_{t+1} \= OBV\_{t-1} \+...$ 형태로 이루어져, 비활성 기간이 존재했다는 사실 자체를 지워버리는 개념적 오류를 범하게 됩니다.

### **4.4. 자산별 특성 구분**

* **주식:** 시장 마감 후 다음 날 개장까지의 갭(overnight gap)을 처리하는 방식은 ATR에 가장 큰 영향을 미칩니다. ATR은 본래 이러한 갭을 측정하도록 설계되었기 때문입니다. 이 갭을 잘못 처리하면(예: 자정에 가짜 캔들을 삽입) 지표의 본래 목적이 훼손됩니다.
* **암호화폐:** 24시간 시장에서 발생하는 유동성 갭을 전방 채우기 방식으로 처리할 때 발생하는 인위적인 ATR 억제는 더욱 위험할 수 있습니다. 암호화폐의 변동성은 폭발적으로 재개될 수 있기 때문에, 전략이 주요 움직임 직전에 시장을 과소평가하는 '안정의 착각'에 빠질 수 있습니다.

---

## **섹션 5: 견고한 트레이딩 시스템을 위한 최적의 선택**

이 마지막 섹션에서는 앞선 모든 분석을 종합하여, 명확하고 실행 가능하며 견고하게 방어될 수 있는 최적의 방법론을 제시합니다.

### **5.1. 최종 결론: 인과성 우선의 하이브리드 접근법**

최적의 방법은 단일 명령어가 아닌, 다음과 같은 2단계 프로세스로 구성됩니다:

1. **리샘플링 및 데이터 유지 (Resample and Provide As-Is):** 먼저 데이터셋이 고정된 빈도의 완전한 datetime 인덱스를 갖도록 보장합니다. 누락된 타임스탬프가 있다면 해당 위치에 빈 캔들(모든 값이 NaN인 행)을 삽입합니다.
2. **인과적 전방 채우기 (Causal Forward Fill):** 이렇게 생성된 빈 캔들(또는 기존의 제로 볼륨 캔들)에 대해, 가격 관련 컬럼들(Open, High, Low, Close)은 마지막으로 유효했던 관측값으로 전방 채우기(forward-fill)를 수행합니다. **Volume 컬럼은 반드시 0으로 채웁니다.**

### **5.2. 핵심 논리: 견고성의 세 가지 원칙**

이 접근법은 견고한 시스템이 갖춰야 할 세 가지 핵심 원칙을 모두 만족시킵니다.

* **시간적 무결성 (Temporal Integrity):** 규칙적인 시계열을 유지하여 대부분의 기술 지표가 요구하는 기본 가정을 충족시킵니다.
* **인과적 순수성 (Causal Purity):** 오직 과거의 정보(전방 채우기)만을 사용하므로 미래 데이터 참조 편향으로부터 자유롭습니다.
* **실거래 환경 일치성 (Live Trading Parity):** 데이터 틱을 놓쳤을 때 새로운 정보가 들어올 때까지 마지막으로 알려진 상태를 기반으로 작동해야 하는 실거래 엔진의 현실을 완벽하게 시뮬레이션합니다.

### **5.3. 구현 청사진: 미래 참조 편향을 회피하는 백테스팅**

많은 개발자들이 pandas.DataFrame.ffill() 함수를 백테스트 루프를 시작하기 전에 전체 데이터셋에 한 번에 적용하는 실수를 저지릅니다. 이는 효율적으로 보이지만, 미묘한 형태의 미래 데이터 참조 편향을 유발합니다. 예를 들어, 백테스트 시뮬레이션이 1월 2일을 처리하고 있는 시점임에도 불구하고, 1월 5일의 갭이 1월 4일의 데이터로 미리 채워져 있다면, 백테스터는 미래에 발생할 갭의 상태를 '알고' 있는 셈이 됩니다.

이를 방지하는 유일하고 견고한 방법은 **백테스팅 루프 내부에서** 또는 롤링 윈도우(rolling window) 접근법을 사용하여 데이터 채우기를 수행하는 것입니다. 백테스트의 각 시간 단계 $t$에서 시스템은 오직 시간 $t$까지의 데이터에만 접근할 수 있어야 합니다. 데이터 채우기 로직은 실시간으로 정보가 들어오는 것처럼 순차적으로, 단계별로 적용되어야 합니다.

다음은 이 개념을 설명하는 의사 코드(pseudo-code)입니다.

Python

\# 미래 참조 편향을 회피하는 백테스트 루프의 개념적 의사 코드

\# 1\. 데이터를 로드하고 완전한 시간 인덱스로 리샘플링 (갭은 NaN 행으로 존재)
full\_data \= load\_and\_resample\_to\_full\_index()

\# 2\. 백테스트 루프 실행
for t in range(lookback\_period, len(full\_data)):
    \# 3\. 현재 시점(t)까지 알려진 데이터만 슬라이싱
    current\_data\_slice \= full\_data.iloc\[0:t+1\] \# t+1 to include current timestamp

    \# 4\. 오직 과거와 현재 데이터에 대해서만 인과적 전방 채우기 적용
    filled\_slice \= current\_data\_slice.ffill()

    \# 5\. 인과적으로 올바르게 채워진 데이터를 기반으로 기술 지표 계산
    indicators \= calculate\_indicators(filled\_slice)

    \# 6\. 가장 최근의 지표 값을 사용하여 거래 결정
    latest\_indicators \= indicators.iloc\[-1\]
    generate\_signal(latest\_indicators)

    \#... 거래 실행, 포트폴리오 관리 등...

이 구현 청사진은 개발자에게 가장 흔하면서도 비용이 큰 백테스팅 오류 중 하나를 피할 수 있는, 실행 가능하고 개념적으로 올바른 패턴을 제공합니다.

### **5.4. 최종 고려사항 및 전략 의존성**

본 보고서에서 제안한 '인과적 전방 채우기' 방법이 대부분의 상황에서 최상의 범용 솔루션이지만, 최종 선택은 개발 중인 전략의 특성에 따라 달라질 수 있음을 인지하는 것이 중요합니다. 예를 들어, 비유동성 자체를 거래 기회로 삼는 전략은 '데이터 유지(As-Is)' 방법을 사용하고 제로 볼륨 기간을 해석하는 별도의 커스텀 로직을 구현하는 것이 더 적합할 수 있습니다. 핵심은 본 보고서에서 제시된 원칙에 기반하여, 의식적이고 합리적인 근거를 바탕으로 데이터 처리 방식을 선택하는 것입니다.

#### **참고 자료**

1. Bitsgap: Your All-in-One Crypto Trading Platform, 9월 25, 2025에 액세스, [https://bitsgap.com/](https://bitsgap.com/)
2. Quantitative Trading Strategies: How to Create & Backtest | FTO \- Forex Tester Online, 9월 25, 2025에 액세스, [https://forextester.com/blog/quant-trading-strategies/](https://forextester.com/blog/quant-trading-strategies/)
3. Gap Fill Trading Strategies | TrendSpider Learning Center, 9월 25, 2025에 액세스, [https://trendspider.com/learning-center/gap-fill-trading-strategies/](https://trendspider.com/learning-center/gap-fill-trading-strategies/)
4. GitHub \- TA-Lib/ta-lib-python: Python wrapper for TA-Lib (<http://ta-lib> ..., 9월 25, 2025에 액세스, [https://github.com/TA-Lib/ta-lib-python](https://github.com/TA-Lib/ta-lib-python)
5. Examples \- TA-Lib : Technical Analysis Library, 9월 25, 2025에 액세스, [https://ta-lib.github.io/ta-lib-python/](https://ta-lib.github.io/ta-lib-python/)
6. pandas-ta \- PyPI, 9월 25, 2025에 액세스, [https://pypi.org/project/pandas-ta/](https://pypi.org/project/pandas-ta/)
7. Technical Analysis Indicators \- Pandas TA is an easy to use Python 3 Pandas Extension with 130+ Indicators \- GitHub, 9월 25, 2025에 액세스, [https://github.com/Data-Analisis/Technical-Analysis-Indicators---Pandas](https://github.com/Data-Analisis/Technical-Analysis-Indicators---Pandas)
8. finta: Common financial technical indicators implemented in Pandas. \- Gitee, 9월 25, 2025에 액세스, [https://gitee.com/guqii/finta?skip\_mobile=true](https://gitee.com/guqii/finta?skip_mobile=true)
9. An Ensembling Architecture Incorporating Machine Learning Models and Genetic Algorithm Optimization for Forex Trading \- MDPI, 9월 25, 2025에 액세스, [https://www.mdpi.com/2674-1032/1/2/8](https://www.mdpi.com/2674-1032/1/2/8)
10. pandas-ta-remake 1.0.4 on PyPI \- Libraries.io, 9월 25, 2025에 액세스, [https://libraries.io/pypi/pandas-ta-remake](https://libraries.io/pypi/pandas-ta-remake)
11. TulipCharts/tulipindicators: Technical Analysis Indicator Function Library in C \- GitHub, 9월 25, 2025에 액세스, [https://github.com/TulipCharts/tulipindicators](https://github.com/TulipCharts/tulipindicators)
12. tulipy \- PyPI, 9월 25, 2025에 액세스, [https://pypi.org/project/tulipy/](https://pypi.org/project/tulipy/)
13. 通达信/Tulip Indicators \- Gitee, 9월 25, 2025에 액세스, [https://gitee.com/accessible-letter-TongDaXin/tulipindicators\_1?skip\_mobile=true](https://gitee.com/accessible-letter-TongDaXin/tulipindicators_1?skip_mobile=true)
14. Negative Volume Index Technical Analysis Indicator: nvi, 9월 25, 2025에 액세스, [https://tulipindicators.org/nvi](https://tulipindicators.org/nvi)
15. Tulip indicators \- Gekko, 9월 25, 2025에 액세스, [https://gekko.wizb.it/docs/strategies/tulip\_indicators.html](https://gekko.wizb.it/docs/strategies/tulip_indicators.html)
16. Pandas-Quant-Finance/pandas-ta: Pandas Extensions for Technical Analysis \- GitHub, 9월 25, 2025에 액세스, [https://github.com/Pandas-Quant-Finance/pandas-ta](https://github.com/Pandas-Quant-Finance/pandas-ta)
17. NoLBERT: A No Lookahead(back) Foundational Language Model for Empirical Research, 9월 25, 2025에 액세스, [https://arxiv.org/html/2509.01110v1](https://arxiv.org/html/2509.01110v1)
18. Seems too good to be true. I should check my backtesting code again\! : r/algotrading \- Reddit, 9월 25, 2025에 액세스, [https://www.reddit.com/r/algotrading/comments/pc7edx/seems\_too\_good\_to\_be\_true\_i\_should\_check\_my/](https://www.reddit.com/r/algotrading/comments/pc7edx/seems_too_good_to_be_true_i_should_check_my/)
19. Causal AI modeling for Time Series Data \- causaLens, 9월 25, 2025에 액세스, [https://causalai.causalens.com/time-series/](https://causalai.causalens.com/time-series/)
20. Backtesting, how missing data points should be handled ..., 9월 25, 2025에 액세스, [https://quant.stackexchange.com/questions/37529/backtesting-how-missing-data-points-should-be-handled](https://quant.stackexchange.com/questions/37529/backtesting-how-missing-data-points-should-be-handled)
21. Model is not as important as features. : r/quant \- Reddit, 9월 25, 2025에 액세스, [https://www.reddit.com/r/quant/comments/1kderwe/model\_is\_not\_as\_important\_as\_features/](https://www.reddit.com/r/quant/comments/1kderwe/model_is_not_as_important_as_features/)
22. How to deal with missing zero volume candles : r/algotrading \- Reddit, 9월 25, 2025에 액세스, [https://www.reddit.com/r/algotrading/comments/tg06nu/how\_to\_deal\_with\_missing\_zero\_volume\_candles/](https://www.reddit.com/r/algotrading/comments/tg06nu/how_to_deal_with_missing_zero_volume_candles/)
23. Reinforcement Learning for Stock Option Trading \- CCT ARC \- CCT College Dublin, 9월 25, 2025에 액세스, [https://arc.cct.ie/cgi/viewcontent.cgi?article=1044\&context=ict](https://arc.cct.ie/cgi/viewcontent.cgi?article=1044&context=ict)
24. KASPER: Kolmogorov Arnold Networks for Stock Prediction and Explainable Regimes, 9월 25, 2025에 액세스, [https://arxiv.org/html/2507.18983v1](https://arxiv.org/html/2507.18983v1)
25. candles with zero volume are skipped, leading to problems \- NinjaTrader Support Forum, 9월 25, 2025에 액세스, [https://forum.ninjatrader.com/forum/ninjatrader-7/platform-technical-support/38946-candles-with-zero-volume-are-skipped-leading-to-problems](https://forum.ninjatrader.com/forum/ninjatrader-7/platform-technical-support/38946-candles-with-zero-volume-are-skipped-leading-to-problems)
26. Effective Volume Candlestick Trading Techniques: A Comprehensive Guide \- TradingSim, 9월 25, 2025에 액세스, [https://www.tradingsim.com/blog/effective-volume-candlestick-trading-techniques-a-comprehensive-guide](https://www.tradingsim.com/blog/effective-volume-candlestick-trading-techniques-a-comprehensive-guide)
27. Backtest Crypto Strategies with Real Market Data ... \- CoinAPI.io Blog, 9월 25, 2025에 액세스, [https://www.coinapi.io/blog/backtest-crypto-strategies-with-real-market-data](https://www.coinapi.io/blog/backtest-crypto-strategies-with-real-market-data)
28. Is it Possible to Backtest Strategies with Crypto APIs? \- Token Metrics, 9월 25, 2025에 액세스, [https://www.tokenmetrics.com/blog/crypto-apis-backtesting-trading-strategies?0fad35da\_page=2&74e29fd5\_page=49](https://www.tokenmetrics.com/blog/crypto-apis-backtesting-trading-strategies?0fad35da_page=2&74e29fd5_page=49)
29. What Is TA-Lib ? How to Implement Technical Indicators In Python? \- Hanane D., 9월 25, 2025에 액세스, [https://machinelearning-basics.com/what-is-ta-lib-and-how-to-implement-technical-indicators-in-python/](https://machinelearning-basics.com/what-is-ta-lib-and-how-to-implement-technical-indicators-in-python/)
30. Backtesting Your Crypto Trading Strategy \- Cryptohopper, 9월 25, 2025에 액세스, [https://www.cryptohopper.com/blog/backtesting-your-crypto-trading-strategy-11790](https://www.cryptohopper.com/blog/backtesting-your-crypto-trading-strategy-11790)
31. Neural Network-Based Algorithmic Trading Systems: Multi-Timeframe Analysis and High-Frequency Execution in Cryptocurrency Markets \- arXiv, 9월 25, 2025에 액세스, [https://arxiv.org/html/2508.02356](https://arxiv.org/html/2508.02356)
32. Backtesting vs Real-Time Trading: Why There's A Discrepancy and How To Fix It \- Wakett, 9월 25, 2025에 액세스, [https://wakett.com/the-wakett-blog/backtesting-vs-real-time-trading-why-theres-a-discrepancy-and-how-to-fix-it](https://wakett.com/the-wakett-blog/backtesting-vs-real-time-trading-why-theres-a-discrepancy-and-how-to-fix-it)
33. Mastering Market Data Analysis for Algo Trading \- NURP, 9월 25, 2025에 액세스, [https://nurp.com/wisdom/mastering-market-data-analysis-for-algo-trading/](https://nurp.com/wisdom/mastering-market-data-analysis-for-algo-trading/)
34. Volume Candlesticks \- How They Work and Why Traders Use Them \- Warrior Trading, 9월 25, 2025에 액세스, [https://www.warriortrading.com/volume-candlesticks-how-they-work-and-why-traders-use-them/](https://www.warriortrading.com/volume-candlesticks-how-they-work-and-why-traders-use-them/)
