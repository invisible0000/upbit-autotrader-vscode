# 첫 청크 처리 리팩터링 계획

## 배경 및 목표
- `chunk_processor.process_collection`(chunk_processor.py:184)부터 시작되는 첫 청크 구성 로직이 여러 계층(ChunkProcessor, CollectionPlan, RequestInfo 보조 함수)으로 분산되어 있어 흐름을 따라가기가 어렵습니다.
- `_create_chunk` 내부의 첫 번째 분기(chunk_processor.py:373)가 계획 객체의 `first_chunk_params`를 의존하고, 해당 파라미터는 `candle_business_models.create_collection_plan`(candle_business_models.py:693)에서만 산출됩니다.
- 첫 청크의 API 파라미터 계산과 OverlapAnalyzer 스킵 여부를 명시적으로 드러내어 가독성을 높이고, 잔여 청크 로직은 동일한 패턴으로 단순화하는 것이 목표입니다.

## 현행 구조 요약
- `CollectionPlan` 데이터 모델(candle_business_models.py:234)과 `candle_collection_models.CollectionPlan`(candle_collection_models.py:131)이 `first_chunk_params` 필드를 보유하여 첫 청크용 파라미터를 전달합니다.
- `_create_first_chunk_params_by_type`(candle_business_models.py:703)에서 요청 타입에 따라 첫 청크의 `count/to` 조합을 결정합니다.
- `_create_chunk`(chunk_processor.py:360)에서 `chunk_index == 0`일 때만 `plan.first_chunk_params`를 사용하고, 이후 청크는 직전 청크의 `get_effective_end_time()`을 기반으로 계산합니다.
- `_get_request_type_from_chunk`(chunk_processor.py:401) 등 일부 보조 메서드는 첫 청크 여부를 `chunk_index`와 `to` 값으로 추론합니다.

## 문제점 정리
- 첫 청크 로직이 CollectionPlan → ChunkProcessor → RequestInfo로 흩어져 있어 읽기 어려운 흐름을 만듭니다.
- `CollectionPlan`이 첫 청크 전용 필드를 보유하면서 계획 객체가 처리 책임을 과도하게 갖고 있습니다.
- 첫 청크용 파라미터 계산을 위해 매번 `Dict` 복사 및 datetime 변환(chunk_processor.py:375-381)이 수행되어 불필요한 연산이 발생합니다.
- `_get_request_type_from_chunk`처럼 chunk 상태를 역으로 해석하는 도우미가 남아 있어 요청 타입 판단이 간접적입니다.

## 개선 방향
- `process_collection`에서 첫 청크 생성과 처리를 명시적으로 수행하고, 이후 반복은 동일한 `_create_followup_chunk`(가칭)를 통해 처리합니다.
- ChunkProcessor 내부에 `_build_first_chunk` / `_process_first_chunk`를 도입하여 첫 청크 파라미터 계산, OverlapAnalyzer 스킵 여부, 빈 캔들 처리 등을 한 눈에 보이도록 구성합니다.
- `CollectionPlan` 및 관련 모델에서 `first_chunk_params` 필드와 `_create_first_chunk_params_by_type` 함수를 제거하고, 첫 청크 계산 로직은 ChunkProcessor 혹은 RequestInfo 유틸로 이동합니다.
- `_get_request_type_from_chunk` 등 첫 청크 판별용 보조 로직은 `RequestInfo`의 사전 계산 값(`get_request_type`, `should_skip_overlap_analysis_for_first_chunk`)을 직접 활용하도록 정리합니다.
- `_fetch_api_data`는 `ChunkInfo` 전체를 넘기지 않고 필요한 파라미터(시장, 타임프레임, count, to)를 명시적으로 전달하는 방향을 고려하여 함수 시그니처를 단순화합니다.

## 상세 작업 항목
1. `CollectionPlan`(candle_business_models.py, candle_collection_models.py)에서 `first_chunk_params` 필드 제거 및 초기화/검증 로직 수정.
2. `create_collection_plan`에서 첫 청크 계산을 제거하고, 필요한 경우 ChunkProcessor 전용 첫 청크 계산 헬퍼를 신설.
3. ChunkProcessor에 다음 메서드들을 추가/수정:
   - `_build_first_chunk(request_info: RequestInfo) -> ChunkInfo`
   - `_process_first_chunk(chunk: ChunkInfo, request_info: RequestInfo)`
   - 기존 `_create_chunk`를 후속 청크 전용으로 축소(`_build_followup_chunk` 등 네이밍 재조정).
4. `process_collection` 흐름 재구성:
   - 첫 청크 생성 및 처리 → 조기 완료 조건 확인 → 남은 청크 반복 처리.
   - 진행률 콜백과 `should_complete_collection` 호출 시 인덱스 관리가 어긋나지 않도록 검토.
5. `_get_request_type_from_chunk`, `_should_skip_overlap_analysis` 재정비:
   - `RequestInfo`의 도우미를 전달하거나, `_process_first_chunk` 내부에서 직접 판별하도록 변경.
6. `_fetch_api_data`의 파라미터 전달 방식을 재검토하여 첫 청크/후속 청크 모두 동일한 시그니처를 사용하도록 통일.
7. 관련 테스트 및 문서 업데이트:
   - 기존 `docs/debug_01_chunk_processor.md` 등 참고 문서 갱신 여부 확인.
   - 신규 로직에 맞춰 회귀 테스트/통합 테스트 시나리오 작성.

## 영향도 및 주의사항
- `candle_data_provider_original.py` 및 `backups` 디렉터리 내 레거시 코드가 `CollectionPlan.first_chunk_params`에 의존하고 있으므로, 필요 시 동시에 정리하거나 분기 처리를 유지해야 합니다.
- `ChunkInfo`의 `count/to/end` 필드를 설정하는 책임이 ChunkProcessor 쪽으로 이동하므로, 중복 계산이나 누락이 없도록 타임라인 계산을 재검증해야 합니다.
- 첫 청크와 후속 청크가 공통으로 사용하는 OverlapAnalyzer/EmptyCandleDetector 흐름이 동일하게 유지되는지 확인이 필요합니다.

## 검증 계획
- 단위 테스트: 첫 청크만 존재하는 요청, 다중 청크 요청, `COUNT_ONLY`와 `TO_END` 등 요청 타입별 시나리오 커버.
- 통합 시나리오: 실제 업비트 API 모의 호출 또는 저장소 mock을 사용해 `process_collection`의 end-to-end 흐름을 점검.
- 로깅 확인: 새 구조에서도 첫 청크 처리 단계가 명시적으로 로깅되는지 확인하고 필요 시 로그 메시지 정비.
