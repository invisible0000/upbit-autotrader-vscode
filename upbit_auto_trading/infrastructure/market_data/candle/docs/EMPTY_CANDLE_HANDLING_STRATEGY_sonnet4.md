# 빈 캔들(Empty Candle) 데이터 처리 전략 분석(Sonnet 4)
)

## 1. 문제 정의

업비트 캔들 데이터 수집 시, 특정 시간 단위(예: 1분)에 거래가 전혀 없는 경우 '빈 캔들'이 발생합니다. 현재 시스템은 API 요청 횟수를 줄이기 위해, 이러한 빈 캔들을 DB에 `NULL` 값과 참조 시간(`empty_copy_from_utc`)을 포함한 레코드로 저장하고 있습니다.

본 문서는 자동매매 프로그램의 핵심 기능인 **금융 지표 연산** 및 **차트 표기**에 캔들 데이터를 제공할 때, 이 빈 캔들 레코드를 어떻게 처리하는 것이 가장 이상적인지에 대한 분석과 권장 사항을 다룹니다.

## 2. 현재 구현 방식 검토

- **목적**: 이미 데이터가 없다고 확인된 시간대에 대해 중복 API 요청을 방지하여 효율성을 높임.
- **구현**: `chunk_processor.py`가 빈 시간대를 감지하고, `candle_data_models.py`에 정의된 모델에 따라 `open`, `high`, `low`, `close`, `volume` 등 대부분의 필드를 `NULL`로 채우고 `empty_copy_from_utc`에 마지막 유효 캔들의 UTC 시간을 기록하여 DB에 저장.
- **역할**: `candle_data_provider.py`는 이렇게 저장된 데이터를 애플리케이션의 다른 모듈에 제공하는 관문 역할을 함.

## 3. 처리 방안 심층 분석

두 가지 주요 접근 방식을 비교 분석합니다.

### 방안 1: 정제된 캔들 데이터만 제공 (빈 캔들 제외)

`candle_data_provider.py`가 DB에서 빈 캔들 레코드를 필터링하고, 실제 거래가 있었던 캔들 데이터만 반환하는 방식입니다.

#### 장점

- **소비자(Consumer)의 단순성**: 지표 계산 라이브러리(TA-Lib 등)나 차트 라이브러리는 대부분 연속적인 숫자 데이터를 가정하고 설계되었습니다. `NULL`이나 0이 아닌 유효한 데이터만 전달하면, 각 기능 모듈에서 별도의 예외 처리 로직을 구현할 필요가 없어집니다.
- **수학적 정확성**: 이동평균, RSI 등 대부분의 금융 지표는 데이터의 연속성을 가정합니다. 빈 캔들을 이전 값으로 채우거나 0으로 처리하면 지표가 왜곡될 수 있습니다. (예: 거래량 없는 기간의 이동평균이 비정상적으로 낮아짐). 아예 데이터를 제외하면 통계적 왜곡을 피할 수 있습니다.
- **구현의 명확성**: 데이터를 사용하는 쪽에서는 "데이터가 존재한다면 항상 유효하다"고 가정할 수 있어 로직이 간결해집니다.

#### 단점

- **시간적 연속성 상실**: 차트 표기 시 데이터가 없는 구간은 시간 축에서 그냥 건너뛰게 되어, 사용자가 거래가 없었던 기간을 인지하기 어렵습니다. 이는 시장 유동성을 판단하는 데 중요한 정보 손실로 이어질 수 있습니다.
- **데이터 제공자의 복잡성 증가**: `candle_data_provider.py`에 빈 캔들을 필터링하는 로직이 추가되어야 합니다.
- **분석의 잠재적 오류**: "최근 100개 캔들"을 요청했을 때 95개만 받는다면, 5개가 왜 없는지에 대한 추가적인 맥락 없이는 분석이 어려울 수 있습니다.

### 방안 2: 빈 캔들을 포함한 모든 데이터 제공

DB에 저장된 그대로, 빈 캔들 레코드(`NULL` 값 포함)를 그대로 전달하고 소비자가 알아서 처리하도록 하는 방식입니다.

#### 장점

- **완전한 정보 제공**: 시간적 공백 없이 모든 기간에 대한 데이터를 제공하므로, 차트에서 거래가 없는 기간을 명확히 시각화할 수 있습니다. 이는 유동성 부족과 같은 중요한 시장 상황을 직관적으로 파악하게 해줍니다.
- **데이터 제공자의 단순성**: `candle_data_provider.py`는 DB 데이터를 그대로 전달하기만 하면 되므로 로직이 매우 간단해집니다.
- **소비자의 유연성**: 데이터를 받는 쪽에서 빈 캔들을 어떻게 처리할지(이전 값으로 채우기, 0으로 채우기, 무시하기 등) 자율적으로 결정할 수 있습니다.

#### 단점

- **소비자의 복잡성 증가**: 모든 데이터 소비 모듈(지표 계산, 차트, 백테스팅 등)이 빈 캔들(즉, `NULL` 값)을 처리하는 로직을 개별적으로 구현해야 합니다. 이는 코드 중복과 잠재적 버그 발생 가능성을 높입니다.
- **오류 발생 위험**: 새로운 기능을 추가하는 개발자가 빈 캔들 처리 로직을 누락하면, 시스템은 `NoneType` 관련 오류를 일으키며 중단될 수 있습니다.
- **일관성 없는 처리**: 각 모듈이 빈 캔들을 제각기 다른 방식으로 처리할 경우, 전체 시스템의 데이터 일관성이 깨질 수 있습니다. (예: A 지표는 이전 종가로, B 지표는 0으로 처리)

## 4. 권장 전략: 계층적 접근 및 중앙화된 처리

두 방안의 장점을 취하고 단점을 보완하기 위해, **`CandleDataProvider`를 스마트한 중앙 처리 허브로 만드는 계층적 접근**을 권장합니다.

1.  **DB 계층 (현재 상태 유지)**
    - 현재와 같이 빈 캔들을 포함한 모든 시간의 레코드를 저장하는 방식은 데이터의 무결성과 API 효율성 측면에서 매우 훌륭합니다. 이 방식은 그대로 유지합니다.

2.  **데이터 제공 계층 (`CandleDataProvider`의 역할 강화)**
    - `candle_data_provider.py`가 데이터 처리의 핵심 책임을 맡습니다. 즉, 데이터 소비자가 필요로 하는 형태로 데이터를 가공하여 제공하는 '스마트 게이트웨이' 역할을 수행해야 합니다.

3.  **구체적인 구현 방안**
    - `get_candles`와 같은 데이터 제공 함수에 **처리 방식을 결정하는 파라미터**를 추가합니다.

    ```python
    from enum import Enum

    class FillMethod(Enum):
        NONE = "none"          # 빈 캔들 필터링 (방안 1)
        RAW = "raw"            # NULL 값 그대로 전달 (방안 2)
        FORWARD_FILL = "ffill" # 이전 데이터로 채우기 (권장 기본값)

    def get_candles(market: str, unit: int, count: int, fill_method: FillMethod = FillMethod.FORWARD_FILL):
        # ... DB에서 데이터 로드 (빈 캔들 포함) ...

        if fill_method == FillMethod.NONE:
            # 빈 캔들 레코드 제거 후 반환
            return [candle for candle in candles if candle.volume is not None]

        elif fill_method == FillMethod.RAW:
            # 그대로 반환
            return candles

        elif fill_method == FillMethod.FORWARD_FILL:
            # 빈 캔들을 이전 캔들 정보로 채우기
            # (open, high, low, close는 이전 close 값, volume은 0)
            filled_candles = []
            last_close = None
            for candle in candles:
                if candle.volume is not None:
                    filled_candles.append(candle)
                    last_close = candle.close
                elif last_close is not None:
                    # 빈 캔들을 채워서 새 객체 생성
                    filled_candle = create_filled_candle(candle, last_close)
                    filled_candles.append(filled_candle)
            return filled_candles
    ```

### 권장 기본 전략: `Forward Fill` (앞 방향으로 채우기)

- **금융 지표 연산**: 대부분의 지표는 가격의 연속성을 가정합니다. 빈 캔들의 `open`, `high`, `low`, `close`를 **이전 캔들의 `close` 값으로 채우고**, `volume`은 **0**으로 설정하는 것이 가장 합리적입니다. 이는 가격 변동이 없었음을 의미하며, 거래량 기반 지표에도 왜곡을 최소화합니다.
- **차트 표기**: 이 방식을 사용하면 시간 축의 공백 없이 차트가 그려지며, 거래량 차트를 통해 거래가 없었던 구간을 명확히 인지할 수 있습니다.

## 5. 결론

- **최선책**: `candle_data_provider.py`가 데이터 처리의 중심이 되어, **기본적으로는 빈 캔들을 이전 종가와 0 거래량으로 채운 데이터를 제공(`Forward Fill`)**하는 것입니다.
- **유연성**: 동시에 `fill_method`와 같은 파라미터를 통해, 필요에 따라 필터링된 순수 데이터나 `NULL`이 포함된 원본 데이터를 요청할 수 있는 옵션을 제공하여 시스템의 유연성을 확보해야 합니다.

이러한 중앙화된 접근 방식은 각 모듈의 복잡성을 낮추고, 데이터 처리의 일관성을 보장하며, 시스템 전체의 안정성과 유지보수성을 크게 향상시킬 것입니다.
