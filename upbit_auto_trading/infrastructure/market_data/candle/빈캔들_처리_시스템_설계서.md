# 📊 빈 캔들 처리 시스템 설계서

> **작성일**: 2025년 9월 20일
> **버전**: v1.0
> **담당**: 업비트 자동매매 시스템 개발팀

---

## 🎯 개요

본 문서는 업비트 자동매매 시스템에서 발생하는 빈 캔들(Empty Candle) 처리를 위한 종합적인 설계 방안을 다룹니다. 특히 참조점(Reference Point) 관리와 향후 처리 전략에 중점을 둡니다.

### 핵심 문제 정의
- **빈 캔들**: 실제 거래가 없어 OHLCV 데이터가 없는 시간 구간
- **참조점 부재**: 빈 캔들이 어떤 이전 캔들의 데이터를 참조해야 하는지 불명확한 상태
- **그룹 관리**: 연속된 빈 캔들들의 일괄 처리 필요성

---

## 🏗️ 현재 시스템 구조

### 데이터베이스 스키마
```sql
-- 캔들 테이블의 핵심 컬럼들
CREATE TABLE candles (
    id INTEGER PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,           -- 심볼 (예: KRW-BTC)
    timeframe VARCHAR(10) NOT NULL,        -- 타임프레임 (1m, 5m, 15m 등)
    candle_date_time_utc TIMESTAMP NOT NULL, -- 캔들 시각 (UTC)

    -- 빈 캔들 관련 핵심 컬럼
    empty_copy_from_utc VARCHAR(50),       -- 참조점 또는 상태 마커 (문자열 형식)

    -- OHLCV 데이터
    opening_price DECIMAL(20,8),
    high_price DECIMAL(20,8),
    low_price DECIMAL(20,8),
    trade_price DECIMAL(20,8),
    candle_acc_trade_volume DECIMAL(20,8),

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 현재 빈 캔들 검출 로직
```python
class EmptyCandleDetector:
    """빈 캔들 검출 및 처리 클래스"""

    def detect_empty_candles(self, symbol: str, timeframe: str,
                           start_time: datetime, end_time: datetime):
        """특정 구간의 빈 캔들 검출"""

    def fill_empty_candle_with_reference(self, empty_candle: dict,
                                       reference_time: str):
        """참조점 기반 빈 캔들 데이터 채우기"""
```

---

## 🔄 참조점 처리 전략

### 1. 참조점 상태 관리

#### A. 확정된 참조점 (문자열 기반 처리)
```python
# 명확한 참조점이 있는 경우 - 문자열 그대로 저장
empty_copy_from_utc = "2024-01-15T09:30:00"  # UTC 시간 문자열 (DB 원본 형식)
```

#### B. 참조점 미확정 상태 (UUID 그룹 마커)
```python
# 참조점을 찾지 못한 경우 - UUID 기반 그룹 마커
import uuid

def generate_gap_group_marker() -> str:
    """연속된 빈 캔들 그룹을 위한 고유 마커 생성"""
    return f"none_{uuid.uuid4().hex[:8]}"

# 예시: "none_a1b2c3d4" - 같은 Gap의 모든 빈 캔들이 동일한 마커 공유
```

### 2. 상태별 처리 로직

```python
class ReferencePointManager:
    """참조점 관리 클래스 - 문자열 기반 참조 상태 관리"""

    def determine_reference_state(self, candle_data: dict) -> str:
        """캔들의 참조점 상태 결정 (문자열 기반)"""

        empty_copy_value = candle_data.get('empty_copy_from_utc')

        if empty_copy_value and not empty_copy_value.startswith('none_'):
            return "RESOLVED"  # UTC 시간 문자열 참조
        elif empty_copy_value and empty_copy_value.startswith('none_'):
            return "PENDING_GROUP"  # UUID 그룹 마커
        else:
            return "NEEDS_RESOLUTION"  # NULL 상태

    def create_gap_group(self, consecutive_empty_candles: List[dict]) -> str:
        """연속된 빈 캔들들을 위한 그룹 생성 (문자열 마커)"""

        gap_group_id = f"none_{uuid.uuid4().hex[:8]}"

        # 모든 연속 빈 캔들에 동일한 그룹 ID 할당
        for candle in consecutive_empty_candles:
            candle['empty_copy_from_utc'] = gap_group_id

        return gap_group_id
```

---

## 🎯 향후 처리 전략

### 1. 참조점 해결 시나리오

#### 시나리오 A: 신규 데이터 수집 시 실시간 해결
```python
def on_new_candle_received(new_candle: dict):
    """새 캔들 수신 시 참조점 해결 가능성 검사"""

    # 1. 해당 시간 주변의 미해결 그룹 검색
    pending_groups = find_pending_groups_around_time(
        symbol=new_candle['symbol'],
        timeframe=new_candle['timeframe'],
        target_time=new_candle['candle_date_time_utc'],
        window_minutes=60
    )

    # 2. 각 그룹별 해결 가능성 판단 및 처리
    for group_id in pending_groups:
        if can_resolve_with_new_candle(group_id, new_candle):
            resolve_gap_group(group_id, new_candle['candle_date_time_utc'])
```

#### 시나리오 B: 주기적 배치 처리
```python
def periodic_gap_resolution():
    """주기적 미해결 그룹 처리 (예: 매시간)"""

    # 1. 24시간 이상된 미해결 그룹 우선 처리
    old_groups = find_groups_older_than(hours=24)

    # 2. 다양한 해결 전략 적용
    for group_id in old_groups:
        resolution_strategies = [
            resolve_from_adjacent_candles,
            resolve_from_higher_timeframe,
            resolve_from_market_patterns,
        ]

        for strategy in resolution_strategies:
            if strategy(group_id):
                break
```

#### 시나리오 C: 과거 데이터 백필 시
```python
def backfill_gap_resolution(symbol: str, timeframe: str,
                          start_date: datetime, end_date: datetime):
    """과거 구간 데이터 보완 시 그룹 해결"""

    # 1. 해당 기간의 모든 미해결 그룹 조회
    groups_in_range = find_groups_in_timerange(
        symbol, timeframe, start_date, end_date
    )

    # 2. 새로 수집된 데이터와 매칭하여 해결
    for group_id in groups_in_range:
        if new_data_can_resolve(group_id):
            resolve_gap_group_with_verification(group_id)
```

### 2. 해결 우선순위 및 신뢰도

```python
class ResolutionStrategy:
    """참조점 해결 전략 및 우선순위"""

    STRATEGIES = {
        # 우선순위 1: 확실한 참조점 (신뢰도 100%)
        'EXACT_MATCH': {
            'description': '동일 심볼/타임프레임의 실제 캔들 데이터',
            'confidence': 1.0,
            'auto_resolve': True
        },

        # 우선순위 2: 추론 가능한 참조점 (신뢰도 80-99%)
        'TIMEFRAME_INFERENCE': {
            'description': '상위 타임프레임 데이터 기반 계산',
            'confidence': 0.85,
            'auto_resolve': True
        },

        # 우선순위 3: 패턴 기반 참조점 (신뢰도 60-79%)
        'PATTERN_BASED': {
            'description': '시장 패턴 및 인접 데이터 기반 추론',
            'confidence': 0.70,
            'auto_resolve': False,  # 검토 필요
        },

        # 우선순위 4: 수동 처리 (신뢰도 < 60%)
        'MANUAL_REVIEW': {
            'description': '수동 검토 및 처리 필요',
            'confidence': 0.0,
            'auto_resolve': False
        }
    }
```

---

## 🔍 검출 및 처리 로직

### 1. 미해결 그룹 검출
```sql
-- 미해결 그룹 조회 쿼리 (문자열 기반)
SELECT
    SUBSTRING(empty_copy_from_utc, 6) as gap_group_uuid,
    symbol,
    timeframe,
    COUNT(*) as gap_count,
    MIN(candle_date_time_utc) as gap_start,
    MAX(candle_date_time_utc) as gap_end,
    MAX(created_at) as last_updated
FROM candles
WHERE empty_copy_from_utc LIKE 'none_%'
GROUP BY SUBSTRING(empty_copy_from_utc, 6), symbol, timeframe
ORDER BY last_updated DESC;
```

### 2. 참조점 후보 탐지
```python
def find_reference_candidates(gap_group_id: str) -> List[dict]:
    """특정 그룹의 참조점 후보 탐지"""

    group_info = get_gap_group_info(gap_group_id)
    candidates = []

    # 전략 1: 시간적 인접 캔들
    adjacent_candles = find_adjacent_real_candles(
        symbol=group_info['symbol'],
        timeframe=group_info['timeframe'],
        gap_start=group_info['gap_start'],
        gap_end=group_info['gap_end']
    )

    # 전략 2: 상위 타임프레임 데이터
    if group_info['timeframe'] in ['1m', '3m', '5m']:
        higher_tf_data = find_higher_timeframe_data(
            symbol=group_info['symbol'],
            target_timeframes=['15m', '1h', '4h'],
            time_range=(group_info['gap_start'], group_info['gap_end'])
        )
        candidates.extend(higher_tf_data)

    # 전략 3: 시장 패턴 기반 추론
    market_patterns = infer_from_market_schedule(
        symbol=group_info['symbol'],
        gap_period=(group_info['gap_start'], group_info['gap_end'])
    )

    return candidates
```

### 3. 일괄 업데이트 처리
```python
def resolve_gap_group(gap_group_id: str, reference_state: str,
                     confidence: float = 1.0) -> bool:
    """그룹 단위 일괄 참조점 해결 (문자열 기반)"""

    try:
        # 1. 트랜잭션 시작
        with database_transaction():

            # 2. 백업 생성 (신뢰도 < 1.0인 경우)
            if confidence < 1.0:
                backup_gap_group_state(gap_group_id)

            # 3. 일괄 업데이트 실행 (문자열 직접 처리)
            update_query = """
                UPDATE candles
                SET empty_copy_from_utc = %s,
                    updated_at = CURRENT_TIMESTAMP
                WHERE empty_copy_from_utc = %s
            """
            execute_query(update_query, (reference_state, f"none_{gap_group_id}"))

            # 4. 데이터 무결성 검증
            if not verify_group_integrity(gap_group_id, reference_time):
                raise IntegrityError("참조점 해결 후 데이터 무결성 검증 실패")

            # 5. 성공 로깅
            log_resolution_success(gap_group_id, reference_time, confidence)

        return True

    except Exception as e:
        log_resolution_failure(gap_group_id, str(e))
        return False
```

---

## 📊 모니터링 및 메트릭

### 1. 핵심 지표
```python
class GapResolutionMetrics:
    """빈 캔들 처리 관련 메트릭"""

    def __init__(self):
        self.metrics = {
            'total_gap_groups': 0,           # 전체 미해결 그룹 수
            'resolved_today': 0,             # 금일 해결된 그룹 수
            'avg_resolution_time': 0.0,      # 평균 해결 시간 (시간)
            'resolution_success_rate': 0.0,  # 해결 성공률
            'auto_resolution_rate': 0.0,     # 자동 해결률
        }

    def generate_daily_report(self) -> dict:
        """일일 처리 현황 리포트"""

        return {
            'date': datetime.now().date(),
            'summary': {
                'new_gaps_detected': self.get_new_gaps_count(),
                'gaps_resolved': self.get_resolved_gaps_count(),
                'gaps_pending': self.get_pending_gaps_count(),
                'oldest_pending_age': self.get_oldest_pending_age(),
            },
            'resolution_methods': {
                'exact_match': self.get_method_count('EXACT_MATCH'),
                'timeframe_inference': self.get_method_count('TIMEFRAME_INFERENCE'),
                'pattern_based': self.get_method_count('PATTERN_BASED'),
                'manual_review': self.get_method_count('MANUAL_REVIEW'),
            },
            'performance': {
                'avg_resolution_time_ms': self.get_avg_resolution_time(),
                'success_rate_percent': self.get_success_rate(),
            }
        }
```

### 2. 알림 및 경고 시스템
```python
class GapAlertSystem:
    """빈 캔들 처리 알림 시스템"""

    ALERT_CONDITIONS = {
        'CRITICAL': {
            'pending_groups_over_100': 100,
            'oldest_pending_over_days': 7,
            'resolution_failure_rate_over': 0.1,
        },
        'WARNING': {
            'pending_groups_over_50': 50,
            'oldest_pending_over_hours': 24,
            'resolution_failure_rate_over': 0.05,
        }
    }

    def check_and_alert(self):
        """조건 확인 및 알림 발송"""

        current_status = self.get_current_status()

        for level, conditions in self.ALERT_CONDITIONS.items():
            if self.meets_alert_conditions(current_status, conditions):
                self.send_alert(level, current_status)
```

---

## 🛠️ 구현 가이드라인

### 1. 코드 구조
```
upbit_auto_trading/infrastructure/market_data/candle/
├── empty_candle_detector.py           # 기존 빈 캔들 검출기
├── reference_point_manager.py         # 새로운 참조점 관리자
├── gap_resolution_service.py          # 그룹 해결 서비스
├── resolution_strategies/             # 해결 전략들
│   ├── exact_match_strategy.py
│   ├── timeframe_inference_strategy.py
│   └── pattern_based_strategy.py
└── monitoring/                        # 모니터링
    ├── gap_metrics.py
    └── gap_alerts.py
```

### 2. 설정 관리
```python
# config/gap_resolution_config.py
GAP_RESOLUTION_CONFIG = {
    'auto_resolve_threshold': 0.8,      # 자동 해결 신뢰도 임계치
    'batch_process_interval': 3600,     # 배치 처리 간격 (초)
    'max_gap_age_for_auto': 86400,      # 자동 처리 최대 나이 (초)
    'backup_low_confidence': True,      # 낮은 신뢰도 시 백업 생성
    'alert_thresholds': {
        'critical_pending_count': 100,
        'warning_pending_age_hours': 24,
    }
}
```

### 3. 테스트 시나리오
```python
class TestGapResolution:
    """빈 캔들 처리 테스트 케이스"""

    def test_gap_group_creation(self):
        """연속 빈 캔들 그룹 생성 테스트"""
        pass

    def test_exact_match_resolution(self):
        """정확한 참조점 해결 테스트"""
        pass

    def test_batch_resolution(self):
        """배치 처리 테스트"""
        pass

    def test_rollback_on_failure(self):
        """실패 시 롤백 테스트"""
        pass

    def test_performance_under_load(self):
        """대용량 처리 성능 테스트"""
        pass
```

---

## 🔮 향후 개선 계획

### Phase 1: 기본 구현 (1-2주)
- [x] 현재 상황 분석 및 설계 완료
- [ ] `none_` + UUID 패턴 구현
- [ ] 기본 그룹 해결 로직 구현
- [ ] 단위 테스트 작성

### Phase 2: 고도화 (3-4주)
- [ ] 다양한 해결 전략 구현
- [ ] 배치 처리 시스템 구축
- [ ] 모니터링 및 알림 시스템
- [ ] 성능 최적화

### Phase 3: 지능화 (5-6주)
- [ ] 머신러닝 기반 패턴 인식
- [ ] 시장 데이터 기반 자동 추론
- [ ] 예측 기반 선제적 처리
- [ ] 고급 분석 도구

---

## 📚 참고 자료

### 업계 모범 사례
- **Apache Kafka**: 오프셋 기반 복구와 tombstone 패턴
- **InfluxDB**: 시계열 데이터 Gap Detection 전략
- **TimescaleDB**: 연속성 기반 백필 처리
- **금융 데이터 처리**: Sentinel Values와 참조 무결성

### 관련 문서
- `docs/DB_SCHEMA.md` - 데이터베이스 스키마 상세
- `docs/ARCHITECTURE_GUIDE.md` - 전체 아키텍처 가이드
- `docs/COMPLEX_SYSTEM_TESTING_GUIDE.md` - 시스템 테스트 가이드

---

## 📞 연락처

**담당자**: 개발팀
**문의**: GitHub Issues 또는 내부 채널
**최종 수정**: 2025년 9월 20일

---

> **주의사항**: 본 설계서는 지속적으로 업데이트되며, 실제 구현 시 세부사항은 변경될 수 있습니다.
