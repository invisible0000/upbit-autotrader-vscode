# ğŸ“Š ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ì‹œìŠ¤í…œ ì„¤ê³„ì„œ

> **ì‘ì„±ì¼**: 2025ë…„ 9ì›” 20ì¼
> **ë²„ì „**: v1.0
> **ë‹´ë‹¹**: ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ê°œë°œíŒ€

---

## ğŸ¯ ê°œìš”

ë³¸ ë¬¸ì„œëŠ” ì—…ë¹„íŠ¸ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì—ì„œ ë°œìƒí•˜ëŠ” ë¹ˆ ìº”ë“¤(Empty Candle) ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¢…í•©ì ì¸ ì„¤ê³„ ë°©ì•ˆì„ ë‹¤ë£¹ë‹ˆë‹¤. íŠ¹íˆ ì°¸ì¡°ì (Reference Point) ê´€ë¦¬ì™€ í–¥í›„ ì²˜ë¦¬ ì „ëµì— ì¤‘ì ì„ ë‘¡ë‹ˆë‹¤.

### í•µì‹¬ ë¬¸ì œ ì •ì˜
- **ë¹ˆ ìº”ë“¤**: ì‹¤ì œ ê±°ë˜ê°€ ì—†ì–´ OHLCV ë°ì´í„°ê°€ ì—†ëŠ” ì‹œê°„ êµ¬ê°„
- **ì°¸ì¡°ì  ë¶€ì¬**: ë¹ˆ ìº”ë“¤ì´ ì–´ë–¤ ì´ì „ ìº”ë“¤ì˜ ë°ì´í„°ë¥¼ ì°¸ì¡°í•´ì•¼ í•˜ëŠ”ì§€ ë¶ˆëª…í™•í•œ ìƒíƒœ
- **ê·¸ë£¹ ê´€ë¦¬**: ì—°ì†ëœ ë¹ˆ ìº”ë“¤ë“¤ì˜ ì¼ê´„ ì²˜ë¦¬ í•„ìš”ì„±

---

## ğŸ—ï¸ í˜„ì¬ ì‹œìŠ¤í…œ êµ¬ì¡°

### ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ
```sql
-- ìº”ë“¤ í…Œì´ë¸”ì˜ í•µì‹¬ ì»¬ëŸ¼ë“¤
CREATE TABLE candles (
    id INTEGER PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,           -- ì‹¬ë³¼ (ì˜ˆ: KRW-BTC)
    timeframe VARCHAR(10) NOT NULL,        -- íƒ€ì„í”„ë ˆì„ (1m, 5m, 15m ë“±)
    candle_date_time_utc TIMESTAMP NOT NULL, -- ìº”ë“¤ ì‹œê° (UTC)

    -- ë¹ˆ ìº”ë“¤ ê´€ë ¨ í•µì‹¬ ì»¬ëŸ¼
    empty_copy_from_utc VARCHAR(50),       -- ì°¸ì¡°ì  ë˜ëŠ” ìƒíƒœ ë§ˆì»¤ (ë¬¸ìì—´ í˜•ì‹)

    -- OHLCV ë°ì´í„°
    opening_price DECIMAL(20,8),
    high_price DECIMAL(20,8),
    low_price DECIMAL(20,8),
    trade_price DECIMAL(20,8),
    candle_acc_trade_volume DECIMAL(20,8),

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### í˜„ì¬ ë¹ˆ ìº”ë“¤ ê²€ì¶œ ë¡œì§
```python
class EmptyCandleDetector:
    """ë¹ˆ ìº”ë“¤ ê²€ì¶œ ë° ì²˜ë¦¬ í´ë˜ìŠ¤"""

    def detect_empty_candles(self, symbol: str, timeframe: str,
                           start_time: datetime, end_time: datetime):
        """íŠ¹ì • êµ¬ê°„ì˜ ë¹ˆ ìº”ë“¤ ê²€ì¶œ"""

    def fill_empty_candle_with_reference(self, empty_candle: dict,
                                       reference_time: str):
        """ì°¸ì¡°ì  ê¸°ë°˜ ë¹ˆ ìº”ë“¤ ë°ì´í„° ì±„ìš°ê¸°"""
```

---

## ğŸ”„ ì°¸ì¡°ì  ì²˜ë¦¬ ì „ëµ

### 1. ì°¸ì¡°ì  ìƒíƒœ ê´€ë¦¬

#### A. í™•ì •ëœ ì°¸ì¡°ì  (ë¬¸ìì—´ ê¸°ë°˜ ì²˜ë¦¬)
```python
# ëª…í™•í•œ ì°¸ì¡°ì ì´ ìˆëŠ” ê²½ìš° - ë¬¸ìì—´ ê·¸ëŒ€ë¡œ ì €ì¥
empty_copy_from_utc = "2024-01-15T09:30:00"  # UTC ì‹œê°„ ë¬¸ìì—´ (DB ì›ë³¸ í˜•ì‹)
```

#### B. ì°¸ì¡°ì  ë¯¸í™•ì • ìƒíƒœ (UUID ê·¸ë£¹ ë§ˆì»¤)
```python
# ì°¸ì¡°ì ì„ ì°¾ì§€ ëª»í•œ ê²½ìš° - UUID ê¸°ë°˜ ê·¸ë£¹ ë§ˆì»¤
import uuid

def generate_gap_group_marker() -> str:
    """ì—°ì†ëœ ë¹ˆ ìº”ë“¤ ê·¸ë£¹ì„ ìœ„í•œ ê³ ìœ  ë§ˆì»¤ ìƒì„±"""
    return f"none_{uuid.uuid4().hex[:8]}"

# ì˜ˆì‹œ: "none_a1b2c3d4" - ê°™ì€ Gapì˜ ëª¨ë“  ë¹ˆ ìº”ë“¤ì´ ë™ì¼í•œ ë§ˆì»¤ ê³µìœ 
```

### 2. ìƒíƒœë³„ ì²˜ë¦¬ ë¡œì§

```python
class ReferencePointManager:
    """ì°¸ì¡°ì  ê´€ë¦¬ í´ë˜ìŠ¤ - ë¬¸ìì—´ ê¸°ë°˜ ì°¸ì¡° ìƒíƒœ ê´€ë¦¬"""

    def determine_reference_state(self, candle_data: dict) -> str:
        """ìº”ë“¤ì˜ ì°¸ì¡°ì  ìƒíƒœ ê²°ì • (ë¬¸ìì—´ ê¸°ë°˜)"""

        empty_copy_value = candle_data.get('empty_copy_from_utc')

        if empty_copy_value and not empty_copy_value.startswith('none_'):
            return "RESOLVED"  # UTC ì‹œê°„ ë¬¸ìì—´ ì°¸ì¡°
        elif empty_copy_value and empty_copy_value.startswith('none_'):
            return "PENDING_GROUP"  # UUID ê·¸ë£¹ ë§ˆì»¤
        else:
            return "NEEDS_RESOLUTION"  # NULL ìƒíƒœ

    def create_gap_group(self, consecutive_empty_candles: List[dict]) -> str:
        """ì—°ì†ëœ ë¹ˆ ìº”ë“¤ë“¤ì„ ìœ„í•œ ê·¸ë£¹ ìƒì„± (ë¬¸ìì—´ ë§ˆì»¤)"""

        gap_group_id = f"none_{uuid.uuid4().hex[:8]}"

        # ëª¨ë“  ì—°ì† ë¹ˆ ìº”ë“¤ì— ë™ì¼í•œ ê·¸ë£¹ ID í• ë‹¹
        for candle in consecutive_empty_candles:
            candle['empty_copy_from_utc'] = gap_group_id

        return gap_group_id
```

---

## ğŸ¯ í–¥í›„ ì²˜ë¦¬ ì „ëµ

### 1. ì°¸ì¡°ì  í•´ê²° ì‹œë‚˜ë¦¬ì˜¤

#### ì‹œë‚˜ë¦¬ì˜¤ A: ì‹ ê·œ ë°ì´í„° ìˆ˜ì§‘ ì‹œ ì‹¤ì‹œê°„ í•´ê²°
```python
def on_new_candle_received(new_candle: dict):
    """ìƒˆ ìº”ë“¤ ìˆ˜ì‹  ì‹œ ì°¸ì¡°ì  í•´ê²° ê°€ëŠ¥ì„± ê²€ì‚¬"""

    # 1. í•´ë‹¹ ì‹œê°„ ì£¼ë³€ì˜ ë¯¸í•´ê²° ê·¸ë£¹ ê²€ìƒ‰
    pending_groups = find_pending_groups_around_time(
        symbol=new_candle['symbol'],
        timeframe=new_candle['timeframe'],
        target_time=new_candle['candle_date_time_utc'],
        window_minutes=60
    )

    # 2. ê° ê·¸ë£¹ë³„ í•´ê²° ê°€ëŠ¥ì„± íŒë‹¨ ë° ì²˜ë¦¬
    for group_id in pending_groups:
        if can_resolve_with_new_candle(group_id, new_candle):
            resolve_gap_group(group_id, new_candle['candle_date_time_utc'])
```

#### ì‹œë‚˜ë¦¬ì˜¤ B: ì£¼ê¸°ì  ë°°ì¹˜ ì²˜ë¦¬
```python
def periodic_gap_resolution():
    """ì£¼ê¸°ì  ë¯¸í•´ê²° ê·¸ë£¹ ì²˜ë¦¬ (ì˜ˆ: ë§¤ì‹œê°„)"""

    # 1. 24ì‹œê°„ ì´ìƒëœ ë¯¸í•´ê²° ê·¸ë£¹ ìš°ì„  ì²˜ë¦¬
    old_groups = find_groups_older_than(hours=24)

    # 2. ë‹¤ì–‘í•œ í•´ê²° ì „ëµ ì ìš©
    for group_id in old_groups:
        resolution_strategies = [
            resolve_from_adjacent_candles,
            resolve_from_higher_timeframe,
            resolve_from_market_patterns,
        ]

        for strategy in resolution_strategies:
            if strategy(group_id):
                break
```

#### ì‹œë‚˜ë¦¬ì˜¤ C: ê³¼ê±° ë°ì´í„° ë°±í•„ ì‹œ
```python
def backfill_gap_resolution(symbol: str, timeframe: str,
                          start_date: datetime, end_date: datetime):
    """ê³¼ê±° êµ¬ê°„ ë°ì´í„° ë³´ì™„ ì‹œ ê·¸ë£¹ í•´ê²°"""

    # 1. í•´ë‹¹ ê¸°ê°„ì˜ ëª¨ë“  ë¯¸í•´ê²° ê·¸ë£¹ ì¡°íšŒ
    groups_in_range = find_groups_in_timerange(
        symbol, timeframe, start_date, end_date
    )

    # 2. ìƒˆë¡œ ìˆ˜ì§‘ëœ ë°ì´í„°ì™€ ë§¤ì¹­í•˜ì—¬ í•´ê²°
    for group_id in groups_in_range:
        if new_data_can_resolve(group_id):
            resolve_gap_group_with_verification(group_id)
```

### 2. í•´ê²° ìš°ì„ ìˆœìœ„ ë° ì‹ ë¢°ë„

```python
class ResolutionStrategy:
    """ì°¸ì¡°ì  í•´ê²° ì „ëµ ë° ìš°ì„ ìˆœìœ„"""

    STRATEGIES = {
        # ìš°ì„ ìˆœìœ„ 1: í™•ì‹¤í•œ ì°¸ì¡°ì  (ì‹ ë¢°ë„ 100%)
        'EXACT_MATCH': {
            'description': 'ë™ì¼ ì‹¬ë³¼/íƒ€ì„í”„ë ˆì„ì˜ ì‹¤ì œ ìº”ë“¤ ë°ì´í„°',
            'confidence': 1.0,
            'auto_resolve': True
        },

        # ìš°ì„ ìˆœìœ„ 2: ì¶”ë¡  ê°€ëŠ¥í•œ ì°¸ì¡°ì  (ì‹ ë¢°ë„ 80-99%)
        'TIMEFRAME_INFERENCE': {
            'description': 'ìƒìœ„ íƒ€ì„í”„ë ˆì„ ë°ì´í„° ê¸°ë°˜ ê³„ì‚°',
            'confidence': 0.85,
            'auto_resolve': True
        },

        # ìš°ì„ ìˆœìœ„ 3: íŒ¨í„´ ê¸°ë°˜ ì°¸ì¡°ì  (ì‹ ë¢°ë„ 60-79%)
        'PATTERN_BASED': {
            'description': 'ì‹œì¥ íŒ¨í„´ ë° ì¸ì ‘ ë°ì´í„° ê¸°ë°˜ ì¶”ë¡ ',
            'confidence': 0.70,
            'auto_resolve': False,  # ê²€í†  í•„ìš”
        },

        # ìš°ì„ ìˆœìœ„ 4: ìˆ˜ë™ ì²˜ë¦¬ (ì‹ ë¢°ë„ < 60%)
        'MANUAL_REVIEW': {
            'description': 'ìˆ˜ë™ ê²€í†  ë° ì²˜ë¦¬ í•„ìš”',
            'confidence': 0.0,
            'auto_resolve': False
        }
    }
```

---

## ğŸ” ê²€ì¶œ ë° ì²˜ë¦¬ ë¡œì§

### 1. ë¯¸í•´ê²° ê·¸ë£¹ ê²€ì¶œ
```sql
-- ë¯¸í•´ê²° ê·¸ë£¹ ì¡°íšŒ ì¿¼ë¦¬ (ë¬¸ìì—´ ê¸°ë°˜)
SELECT
    SUBSTRING(empty_copy_from_utc, 6) as gap_group_uuid,
    symbol,
    timeframe,
    COUNT(*) as gap_count,
    MIN(candle_date_time_utc) as gap_start,
    MAX(candle_date_time_utc) as gap_end,
    MAX(created_at) as last_updated
FROM candles
WHERE empty_copy_from_utc LIKE 'none_%'
GROUP BY SUBSTRING(empty_copy_from_utc, 6), symbol, timeframe
ORDER BY last_updated DESC;
```

### 2. ì°¸ì¡°ì  í›„ë³´ íƒì§€
```python
def find_reference_candidates(gap_group_id: str) -> List[dict]:
    """íŠ¹ì • ê·¸ë£¹ì˜ ì°¸ì¡°ì  í›„ë³´ íƒì§€"""

    group_info = get_gap_group_info(gap_group_id)
    candidates = []

    # ì „ëµ 1: ì‹œê°„ì  ì¸ì ‘ ìº”ë“¤
    adjacent_candles = find_adjacent_real_candles(
        symbol=group_info['symbol'],
        timeframe=group_info['timeframe'],
        gap_start=group_info['gap_start'],
        gap_end=group_info['gap_end']
    )

    # ì „ëµ 2: ìƒìœ„ íƒ€ì„í”„ë ˆì„ ë°ì´í„°
    if group_info['timeframe'] in ['1m', '3m', '5m']:
        higher_tf_data = find_higher_timeframe_data(
            symbol=group_info['symbol'],
            target_timeframes=['15m', '1h', '4h'],
            time_range=(group_info['gap_start'], group_info['gap_end'])
        )
        candidates.extend(higher_tf_data)

    # ì „ëµ 3: ì‹œì¥ íŒ¨í„´ ê¸°ë°˜ ì¶”ë¡ 
    market_patterns = infer_from_market_schedule(
        symbol=group_info['symbol'],
        gap_period=(group_info['gap_start'], group_info['gap_end'])
    )

    return candidates
```

### 3. ì¼ê´„ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
```python
def resolve_gap_group(gap_group_id: str, reference_state: str,
                     confidence: float = 1.0) -> bool:
    """ê·¸ë£¹ ë‹¨ìœ„ ì¼ê´„ ì°¸ì¡°ì  í•´ê²° (ë¬¸ìì—´ ê¸°ë°˜)"""

    try:
        # 1. íŠ¸ëœì­ì…˜ ì‹œì‘
        with database_transaction():

            # 2. ë°±ì—… ìƒì„± (ì‹ ë¢°ë„ < 1.0ì¸ ê²½ìš°)
            if confidence < 1.0:
                backup_gap_group_state(gap_group_id)

            # 3. ì¼ê´„ ì—…ë°ì´íŠ¸ ì‹¤í–‰ (ë¬¸ìì—´ ì§ì ‘ ì²˜ë¦¬)
            update_query = """
                UPDATE candles
                SET empty_copy_from_utc = %s,
                    updated_at = CURRENT_TIMESTAMP
                WHERE empty_copy_from_utc = %s
            """
            execute_query(update_query, (reference_state, f"none_{gap_group_id}"))

            # 4. ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
            if not verify_group_integrity(gap_group_id, reference_time):
                raise IntegrityError("ì°¸ì¡°ì  í•´ê²° í›„ ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ ì‹¤íŒ¨")

            # 5. ì„±ê³µ ë¡œê¹…
            log_resolution_success(gap_group_id, reference_time, confidence)

        return True

    except Exception as e:
        log_resolution_failure(gap_group_id, str(e))
        return False
```

---

## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ë©”íŠ¸ë¦­

### 1. í•µì‹¬ ì§€í‘œ
```python
class GapResolutionMetrics:
    """ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ê´€ë ¨ ë©”íŠ¸ë¦­"""

    def __init__(self):
        self.metrics = {
            'total_gap_groups': 0,           # ì „ì²´ ë¯¸í•´ê²° ê·¸ë£¹ ìˆ˜
            'resolved_today': 0,             # ê¸ˆì¼ í•´ê²°ëœ ê·¸ë£¹ ìˆ˜
            'avg_resolution_time': 0.0,      # í‰ê·  í•´ê²° ì‹œê°„ (ì‹œê°„)
            'resolution_success_rate': 0.0,  # í•´ê²° ì„±ê³µë¥ 
            'auto_resolution_rate': 0.0,     # ìë™ í•´ê²°ë¥ 
        }

    def generate_daily_report(self) -> dict:
        """ì¼ì¼ ì²˜ë¦¬ í˜„í™© ë¦¬í¬íŠ¸"""

        return {
            'date': datetime.now().date(),
            'summary': {
                'new_gaps_detected': self.get_new_gaps_count(),
                'gaps_resolved': self.get_resolved_gaps_count(),
                'gaps_pending': self.get_pending_gaps_count(),
                'oldest_pending_age': self.get_oldest_pending_age(),
            },
            'resolution_methods': {
                'exact_match': self.get_method_count('EXACT_MATCH'),
                'timeframe_inference': self.get_method_count('TIMEFRAME_INFERENCE'),
                'pattern_based': self.get_method_count('PATTERN_BASED'),
                'manual_review': self.get_method_count('MANUAL_REVIEW'),
            },
            'performance': {
                'avg_resolution_time_ms': self.get_avg_resolution_time(),
                'success_rate_percent': self.get_success_rate(),
            }
        }
```

### 2. ì•Œë¦¼ ë° ê²½ê³  ì‹œìŠ¤í…œ
```python
class GapAlertSystem:
    """ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ ì•Œë¦¼ ì‹œìŠ¤í…œ"""

    ALERT_CONDITIONS = {
        'CRITICAL': {
            'pending_groups_over_100': 100,
            'oldest_pending_over_days': 7,
            'resolution_failure_rate_over': 0.1,
        },
        'WARNING': {
            'pending_groups_over_50': 50,
            'oldest_pending_over_hours': 24,
            'resolution_failure_rate_over': 0.05,
        }
    }

    def check_and_alert(self):
        """ì¡°ê±´ í™•ì¸ ë° ì•Œë¦¼ ë°œì†¡"""

        current_status = self.get_current_status()

        for level, conditions in self.ALERT_CONDITIONS.items():
            if self.meets_alert_conditions(current_status, conditions):
                self.send_alert(level, current_status)
```

---

## ğŸ› ï¸ êµ¬í˜„ ê°€ì´ë“œë¼ì¸

### 1. ì½”ë“œ êµ¬ì¡°
```
upbit_auto_trading/infrastructure/market_data/candle/
â”œâ”€â”€ empty_candle_detector.py           # ê¸°ì¡´ ë¹ˆ ìº”ë“¤ ê²€ì¶œê¸°
â”œâ”€â”€ reference_point_manager.py         # ìƒˆë¡œìš´ ì°¸ì¡°ì  ê´€ë¦¬ì
â”œâ”€â”€ gap_resolution_service.py          # ê·¸ë£¹ í•´ê²° ì„œë¹„ìŠ¤
â”œâ”€â”€ resolution_strategies/             # í•´ê²° ì „ëµë“¤
â”‚   â”œâ”€â”€ exact_match_strategy.py
â”‚   â”œâ”€â”€ timeframe_inference_strategy.py
â”‚   â””â”€â”€ pattern_based_strategy.py
â””â”€â”€ monitoring/                        # ëª¨ë‹ˆí„°ë§
    â”œâ”€â”€ gap_metrics.py
    â””â”€â”€ gap_alerts.py
```

### 2. ì„¤ì • ê´€ë¦¬
```python
# config/gap_resolution_config.py
GAP_RESOLUTION_CONFIG = {
    'auto_resolve_threshold': 0.8,      # ìë™ í•´ê²° ì‹ ë¢°ë„ ì„ê³„ì¹˜
    'batch_process_interval': 3600,     # ë°°ì¹˜ ì²˜ë¦¬ ê°„ê²© (ì´ˆ)
    'max_gap_age_for_auto': 86400,      # ìë™ ì²˜ë¦¬ ìµœëŒ€ ë‚˜ì´ (ì´ˆ)
    'backup_low_confidence': True,      # ë‚®ì€ ì‹ ë¢°ë„ ì‹œ ë°±ì—… ìƒì„±
    'alert_thresholds': {
        'critical_pending_count': 100,
        'warning_pending_age_hours': 24,
    }
}
```

### 3. í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
```python
class TestGapResolution:
    """ë¹ˆ ìº”ë“¤ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤"""

    def test_gap_group_creation(self):
        """ì—°ì† ë¹ˆ ìº”ë“¤ ê·¸ë£¹ ìƒì„± í…ŒìŠ¤íŠ¸"""
        pass

    def test_exact_match_resolution(self):
        """ì •í™•í•œ ì°¸ì¡°ì  í•´ê²° í…ŒìŠ¤íŠ¸"""
        pass

    def test_batch_resolution(self):
        """ë°°ì¹˜ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        pass

    def test_rollback_on_failure(self):
        """ì‹¤íŒ¨ ì‹œ ë¡¤ë°± í…ŒìŠ¤íŠ¸"""
        pass

    def test_performance_under_load(self):
        """ëŒ€ìš©ëŸ‰ ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        pass
```

---

## ğŸ”® í–¥í›„ ê°œì„  ê³„íš

### Phase 1: ê¸°ë³¸ êµ¬í˜„ (1-2ì£¼)
- [x] í˜„ì¬ ìƒí™© ë¶„ì„ ë° ì„¤ê³„ ì™„ë£Œ
- [ ] `none_` + UUID íŒ¨í„´ êµ¬í˜„
- [ ] ê¸°ë³¸ ê·¸ë£¹ í•´ê²° ë¡œì§ êµ¬í˜„
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

### Phase 2: ê³ ë„í™” (3-4ì£¼)
- [ ] ë‹¤ì–‘í•œ í•´ê²° ì „ëµ êµ¬í˜„
- [ ] ë°°ì¹˜ ì²˜ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•
- [ ] ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ
- [ ] ì„±ëŠ¥ ìµœì í™”

### Phase 3: ì§€ëŠ¥í™” (5-6ì£¼)
- [ ] ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ íŒ¨í„´ ì¸ì‹
- [ ] ì‹œì¥ ë°ì´í„° ê¸°ë°˜ ìë™ ì¶”ë¡ 
- [ ] ì˜ˆì¸¡ ê¸°ë°˜ ì„ ì œì  ì²˜ë¦¬
- [ ] ê³ ê¸‰ ë¶„ì„ ë„êµ¬

---

## ğŸ“š ì°¸ê³  ìë£Œ

### ì—…ê³„ ëª¨ë²” ì‚¬ë¡€
- **Apache Kafka**: ì˜¤í”„ì…‹ ê¸°ë°˜ ë³µêµ¬ì™€ tombstone íŒ¨í„´
- **InfluxDB**: ì‹œê³„ì—´ ë°ì´í„° Gap Detection ì „ëµ
- **TimescaleDB**: ì—°ì†ì„± ê¸°ë°˜ ë°±í•„ ì²˜ë¦¬
- **ê¸ˆìœµ ë°ì´í„° ì²˜ë¦¬**: Sentinel Valuesì™€ ì°¸ì¡° ë¬´ê²°ì„±

### ê´€ë ¨ ë¬¸ì„œ
- `docs/DB_SCHEMA.md` - ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ìƒì„¸
- `docs/ARCHITECTURE_GUIDE.md` - ì „ì²´ ì•„í‚¤í…ì²˜ ê°€ì´ë“œ
- `docs/COMPLEX_SYSTEM_TESTING_GUIDE.md` - ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ

---

## ğŸ“ ì—°ë½ì²˜

**ë‹´ë‹¹ì**: ê°œë°œíŒ€
**ë¬¸ì˜**: GitHub Issues ë˜ëŠ” ë‚´ë¶€ ì±„ë„
**ìµœì¢… ìˆ˜ì •**: 2025ë…„ 9ì›” 20ì¼

---

> **ì£¼ì˜ì‚¬í•­**: ë³¸ ì„¤ê³„ì„œëŠ” ì§€ì†ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ë©°, ì‹¤ì œ êµ¬í˜„ ì‹œ ì„¸ë¶€ì‚¬í•­ì€ ë³€ê²½ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
