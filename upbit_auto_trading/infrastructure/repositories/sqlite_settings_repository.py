#!/usr/bin/env python3
"""
SQLite Í∏∞Î∞ò ÏÑ§Ï†ï Repository Íµ¨ÌòÑ (ÏùΩÍ∏∞ Ï†ÑÏö©)
=============================================

settings.sqlite3 Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Î•º ÏúÑÌïú ÏùΩÍ∏∞ Ï†ÑÏö© Repository Íµ¨ÌòÑÏûÖÎãàÎã§.
Îß§Îß§ Î≥ÄÏàò Ï†ïÏùò, ÌååÎùºÎØ∏ÌÑ∞, Ìò∏ÌôòÏÑ± Í∑úÏπô Îì±Ïóê ÎåÄÌïú Domain Repository Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î•º Íµ¨ÌòÑÌï©ÎãàÎã§.

Features:
- ÏùΩÍ∏∞ Ï†ÑÏö©: settings.sqlite3Ïùò Î∂àÎ≥ÄÏÑ± Î≥¥Ïû•
- Ï∫êÏã± ÏßÄÏõê: ÏûêÏ£º Ï°∞ÌöåÎêòÎäî Îç∞Ïù¥ÌÑ∞Ïùò ÏÑ±Îä• ÏµúÏ†ÅÌôî
- DDD Îß§Ìïë: Domain Entity/Value ObjectÎ°ú Î≥ÄÌôò
- Mock Ìò∏Ìôò: Domain Layer ÏôÑÏÑ± Ï†ÑÍπåÏßÄ Ìò∏ÌôòÏÑ± Î≥¥Ïû•

Tables Mapped:
- tv_trading_variables: Îß§Îß§ Î≥ÄÏàò Ï†ïÏùò
- tv_variable_parameters: Î≥ÄÏàòÎ≥Ñ ÌååÎùºÎØ∏ÌÑ∞
- tv_indicator_categories: Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ïÎ≥¥
- cfg_app_settings: Ïï± ÏÑ§Ï†ï
"""

import json
import logging
from typing import List, Dict, Any, Optional

from upbit_auto_trading.domain.repositories.settings_repository import SettingsRepository
from upbit_auto_trading.domain.entities.trigger import TradingVariable
from upbit_auto_trading.domain.value_objects.compatibility_rules import ComparisonGroupRules
from upbit_auto_trading.infrastructure.database.database_manager import DatabaseManager

class SqliteSettingsRepository(SettingsRepository):
    """SQLite Í∏∞Î∞ò Settings Repository Íµ¨ÌòÑ (ÏùΩÍ∏∞ Ï†ÑÏö©)"""

    def __init__(self, db_manager: DatabaseManager):
        self._db = db_manager
        self._logger = logging.getLogger(__name__)
        self._cache: Dict[str, Any] = {}  # ÏÑ±Îä•ÏùÑ ÏúÑÌïú Ï∫êÏãú

    def get_trading_variables(self) -> List[TradingVariable]:
        """Îß§Îß§ Î≥ÄÏàò Ï†ïÏùò Î™©Î°ù Ï°∞Ìöå"""
        if 'trading_variables' in self._cache:
            self._logger.debug("üìã Ï∫êÏãúÏóêÏÑú Îß§Îß§ Î≥ÄÏàò Î™©Î°ù Î∞òÌôò")
            return self._cache['trading_variables']

        query = """
        SELECT
            tv.variable_id,
            tv.display_name_ko,
            tv.display_name_en,
            tv.purpose_category,
            tv.chart_category,
            tv.comparison_group,
            tv.description,
            tv.source,
            tv.parameter_required,
            tv.is_active
        FROM tv_trading_variables tv
        WHERE tv.is_active = 1
        ORDER BY tv.variable_id
        """

        try:
            rows = self._db.execute_query('settings', query)
            variables = []

            for row in rows:
                row_dict = dict(row)

                # TradingVariable ÏÉùÏÑ±
                variable = TradingVariable(
                    variable_id=row_dict['variable_id'],
                    display_name=row_dict.get('display_name_ko', row_dict['variable_id']),
                    purpose_category=row_dict['purpose_category'],
                    chart_category=row_dict['chart_category'],
                    comparison_group=row_dict['comparison_group']
                )
                variables.append(variable)

            # Ï∫êÏãú Ï†ÄÏû•
            self._cache['trading_variables'] = variables

            self._logger.info(f"‚úÖ Îß§Îß§ Î≥ÄÏàò {len(variables)}Í∞ú Î°úÎìú ÏôÑÎ£å")
            return variables

        except Exception as e:
            self._logger.error(f"‚ùå Îß§Îß§ Î≥ÄÏàò Ï°∞Ìöå Ïã§Ìå®: {e}")
            raise

    def find_trading_variable_by_id(self, variable_id: str) -> Optional[TradingVariable]:
        """Î≥ÄÏàò IDÎ°ú Îß§Îß§ Î≥ÄÏàò Ï°∞Ìöå"""
        variables = self.get_trading_variables()

        for variable in variables:
            if variable.variable_id == variable_id:
                return variable

        self._logger.debug(f"üîç Î≥ÄÏàò ID '{variable_id}' Ï°∞Ìöå Í≤∞Í≥º: None")
        return None

    def get_trading_variables_by_category(self, purpose_category: str) -> List[TradingVariable]:
        """Î™©Ï†Å Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Îß§Îß§ Î≥ÄÏàò Ï°∞Ìöå"""
        variables = self.get_trading_variables()

        filtered_variables = [
            var for var in variables
            if var.purpose_category == purpose_category
        ]

        self._logger.debug(f"üìä Î™©Ï†Å Ïπ¥ÌÖåÍ≥†Î¶¨ '{purpose_category}': {len(filtered_variables)}Í∞ú Î≥ÄÏàò")
        return filtered_variables

    def get_trading_variables_by_chart_category(self, chart_category: str) -> List[TradingVariable]:
        """Ï∞®Ìä∏ Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Îß§Îß§ Î≥ÄÏàò Ï°∞Ìöå"""
        variables = self.get_trading_variables()

        filtered_variables = [
            var for var in variables
            if var.chart_category == chart_category
        ]

        self._logger.debug(f"üìà Ï∞®Ìä∏ Ïπ¥ÌÖåÍ≥†Î¶¨ '{chart_category}': {len(filtered_variables)}Í∞ú Î≥ÄÏàò")
        return filtered_variables

    def get_trading_variables_by_comparison_group(self, comparison_group: str) -> List[TradingVariable]:
        """ÎπÑÍµê Í∑∏Î£πÎ≥Ñ Îß§Îß§ Î≥ÄÏàò Ï°∞Ìöå"""
        variables = self.get_trading_variables()

        filtered_variables = [
            var for var in variables
            if var.comparison_group == comparison_group
        ]

        self._logger.debug(f"üîó ÎπÑÍµê Í∑∏Î£π '{comparison_group}': {len(filtered_variables)}Í∞ú Î≥ÄÏàò")
        return filtered_variables

    def get_compatible_variables(self, variable_id: str) -> List[TradingVariable]:
        """ÌäπÏ†ï Î≥ÄÏàòÏôÄ Ìò∏Ìôò Í∞ÄÎä•Ìïú Î™®Îì† Î≥ÄÏàò Ï°∞Ìöå"""
        base_variable = self.find_trading_variable_by_id(variable_id)
        if not base_variable:
            self._logger.warning(f"‚ö†Ô∏è Í∏∞Ï§Ä Î≥ÄÏàò '{variable_id}' Ï°∞Ìöå Ïã§Ìå®")
            return []

        # Í∞ôÏùÄ comparison_groupÏùò Î™®Îì† Î≥ÄÏàò Ï°∞Ìöå
        compatible_variables = self.get_trading_variables_by_comparison_group(
            base_variable.comparison_group
        )

        # ÏûêÍ∏∞ ÏûêÏã† Ï†úÏô∏
        compatible_variables = [
            var for var in compatible_variables
            if var.variable_id != variable_id
        ]

        self._logger.debug(f"ü§ù '{variable_id}'ÏôÄ Ìò∏Ìôò Í∞ÄÎä•Ìïú Î≥ÄÏàò: {len(compatible_variables)}Í∞ú")
        return compatible_variables

    def get_variable_parameters(self, variable_id: str) -> List[Dict[str, Any]]:
        """ÌäπÏ†ï Î≥ÄÏàòÏùò ÌååÎùºÎØ∏ÌÑ∞ Ï†ïÏùò Ï°∞Ìöå"""
        cache_key = f"parameters_{variable_id}"
        if cache_key in self._cache:
            return self._cache[cache_key]

        query = """
        SELECT
            parameter_name,
            parameter_type,
            default_value,
            min_value,
            max_value,
            enum_values,
            is_required,
            display_name_ko,
            display_name_en,
            description,
            display_order
        FROM tv_variable_parameters
        WHERE variable_id = ?
        ORDER BY display_order
        """

        try:
            rows = self._db.execute_query('settings', query, (variable_id,))
            parameters = []

            for row in rows:
                param = dict(row)

                # enum_values JSON ÌååÏã±
                if param.get('enum_values'):
                    try:
                        param['enum_values'] = json.loads(param['enum_values'])
                    except json.JSONDecodeError:
                        # JSON ÌòïÏãùÏù¥ ÏïÑÎãå Í≤ΩÏö∞ ÌååÏù¥ÌîÑ(|)Î°ú Î∂ÑÌï†
                        param['enum_values'] = param['enum_values'].split('|')

                # ÌÉÄÏûÖ Î≥ÄÌôò
                if param.get('min_value'):
                    try:
                        param['min_value'] = float(param['min_value'])
                    except (ValueError, TypeError):
                        param['min_value'] = None

                if param.get('max_value'):
                    try:
                        param['max_value'] = float(param['max_value'])
                    except (ValueError, TypeError):
                        param['max_value'] = None

                parameters.append(param)

            # Ï∫êÏãú Ï†ÄÏû•
            self._cache[cache_key] = parameters

            self._logger.debug(f"üìã Î≥ÄÏàò '{variable_id}' ÌååÎùºÎØ∏ÌÑ∞ {len(parameters)}Í∞ú Î°úÎìú")
            return parameters

        except Exception as e:
            self._logger.error(f"‚ùå Î≥ÄÏàò ÌååÎùºÎØ∏ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®: {variable_id} - {e}")
            raise

    def get_comparison_group_rules(self) -> ComparisonGroupRules:
        """ÎπÑÍµê Í∑∏Î£πÎ≥Ñ Ìò∏ÌôòÏÑ± Í∑úÏπô Ï°∞Ìöå"""
        if 'comparison_group_rules' in self._cache:
            return self._cache['comparison_group_rules']

        # Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ïÎ≥¥ Ï°∞Ìöå
        category_query = """
        SELECT
            category_type,
            category_key,
            category_name_ko,
            description
        FROM tv_indicator_categories
        WHERE is_active = 1
        ORDER BY category_type, display_order
        """

        try:
            rows = self._db.execute_query('settings', category_query)

            purpose_categories = {}
            chart_categories = {}
            comparison_groups = {}

            for row in rows:
                row_dict = dict(row)
                category_type = row_dict['category_type']
                category_key = row_dict['category_key']
                category_info = {
                    'name': row_dict['category_name_ko'],
                    'description': row_dict.get('description', '')
                }

                if category_type == 'purpose':
                    purpose_categories[category_key] = category_info
                elif category_type == 'chart':
                    chart_categories[category_key] = category_info
                elif category_type == 'comparison':
                    comparison_groups[category_key] = category_info

            # Ìò∏ÌôòÏÑ± Îß§Ìä∏Î¶≠Ïä§ Íµ¨ÏÑ± (Í∏∞Î≥∏ Í∑úÏπô)
            compatibility_matrix = {
                'price_comparable': ['price_comparable'],
                'percentage_comparable': ['percentage_comparable'],
                'zero_centered': ['zero_centered'],
                'volume_comparable': ['volume_comparable']
            }

            # ComparisonGroupRules ÏÉùÏÑ± (Mock Î∞©ÏãùÏúºÎ°ú Í∞ÑÎã®Ìûà Íµ¨ÌòÑ)
            # Ïã§Ï†ú Domain Value ObjectÍ∞Ä ÏôÑÏÑ±ÎêòÎ©¥ ÍµêÏ≤¥
            rules = {
                'purpose_categories': purpose_categories,
                'chart_categories': chart_categories,
                'comparison_groups': comparison_groups,
                'compatibility_matrix': compatibility_matrix
            }

            # Ï∫êÏãú Ï†ÄÏû•
            self._cache['comparison_group_rules'] = rules

            self._logger.info("‚úÖ Ìò∏ÌôòÏÑ± Í∑úÏπô Î°úÎìú ÏôÑÎ£å")
            return rules

        except Exception as e:
            self._logger.error(f"‚ùå Ìò∏ÌôòÏÑ± Í∑úÏπô Ï°∞Ìöå Ïã§Ìå®: {e}")
            raise

    def get_indicator_categories(self) -> Dict[str, Dict[str, Any]]:
        """ÏßÄÌëú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        if 'indicator_categories' in self._cache:
            return self._cache['indicator_categories']

        query = """
        SELECT
            category_type,
            category_key,
            category_name_ko,
            category_name_en,
            description,
            icon,
            color_code,
            display_order
        FROM tv_indicator_categories
        WHERE is_active = 1
        ORDER BY category_type, display_order
        """

        try:
            rows = self._db.execute_query('settings', query)
            categories = {}

            for row in rows:
                row_dict = dict(row)
                category_type = row_dict['category_type']

                if category_type not in categories:
                    categories[category_type] = {}

                categories[category_type][row_dict['category_key']] = {
                    'name_ko': row_dict['category_name_ko'],
                    'name_en': row_dict.get('category_name_en'),
                    'description': row_dict.get('description'),
                    'icon': row_dict.get('icon'),
                    'color_code': row_dict.get('color_code'),
                    'display_order': row_dict.get('display_order', 0)
                }

            # Ï∫êÏãú Ï†ÄÏû•
            self._cache['indicator_categories'] = categories

            self._logger.info(f"‚úÖ ÏßÄÌëú Ïπ¥ÌÖåÍ≥†Î¶¨ Î°úÎìú ÏôÑÎ£å: {len(categories)}Í∞ú ÌÉÄÏûÖ")
            return categories

        except Exception as e:
            self._logger.error(f"‚ùå ÏßÄÌëú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï°∞Ìöå Ïã§Ìå®: {e}")
            raise

    def get_app_setting(self, key: str, default_value: Any = None) -> Any:
        """Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏÑ§Ï†ïÍ∞í Ï°∞Ìöå"""
        query = """
        SELECT value FROM cfg_app_settings
        WHERE key = ?
        """

        try:
            rows = self._db.execute_query('settings', query, (key,))

            if rows:
                value = rows[0]['value']

                # JSON ÌòïÌÉúÏù∏ Í≤ΩÏö∞ ÌååÏã± ÏãúÎèÑ
                if value and isinstance(value, str):
                    if value.startswith('{') or value.startswith('['):
                        try:
                            return json.loads(value)
                        except json.JSONDecodeError:
                            pass

                return value
            else:
                self._logger.debug(f"üîç Ïï± ÏÑ§Ï†ï '{key}' Ï°∞Ìöå Í≤∞Í≥º: Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                return default_value

        except Exception as e:
            self._logger.error(f"‚ùå Ïï± ÏÑ§Ï†ï Ï°∞Ìöå Ïã§Ìå®: {key} - {e}")
            return default_value

    def clear_cache(self) -> None:
        """Ï∫êÏãú Ï¥àÍ∏∞Ìôî"""
        cache_size = len(self._cache)
        self._cache.clear()
        self._logger.info(f"üßπ ÏÑ§Ï†ï Ï∫êÏãú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (Ïù¥Ï†Ñ Ï∫êÏãú: {cache_size}Í∞ú Ìï≠Î™©)")

    def get_cache_info(self) -> Dict[str, Any]:
        """Ï∫êÏãú Ï†ïÎ≥¥ Ï°∞Ìöå (ÎîîÎ≤ÑÍπÖ/Î™®ÎãàÌÑ∞ÎßÅÏö©)"""
        return {
            'cache_size': len(self._cache),
            'cached_keys': list(self._cache.keys()),
            'memory_usage_estimate': sum(
                len(str(value)) for value in self._cache.values()
            )
        }

    # ===================================
    # ÎàÑÎùΩÎêú Ï∂îÏÉÅ Î©îÏÑúÎìú Íµ¨ÌòÑ (Ïä§ÌÖÅ)
    # ===================================

    def get_app_settings(self) -> Dict[str, Any]:
        """Ïï± ÏÑ§Ï†ï Ï†ÑÏ≤¥ Ï°∞Ìöå"""
        # TODO: cfg_app_settings ÌÖåÏù¥Î∏î Íµ¨ÌòÑ ÌïÑÏöî
        return {}

    def get_available_categories(self) -> Dict[str, List[str]]:
        """ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù Ï°∞Ìöå"""
        return {
            'purpose': ['trend', 'momentum', 'volatility', 'volume', 'price'],
            'chart': ['overlay', 'subplot'],
            'comparison': [
                'price_comparable', 'percentage_comparable', 'zero_centered',
                'volume_comparable', 'volatility_comparable'
            ]
        }

    def get_category_metadata(self, category_type: str, category_key: str) -> Optional[Dict[str, Any]]:
        """Ïπ¥ÌÖåÍ≥†Î¶¨ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        return {
            'type': category_type,
            'key': category_key,
            'description': f'{category_type} Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò {category_key}'
        }

    def get_comparison_groups(self) -> Dict[str, Dict[str, Any]]:
        """ÎπÑÍµê Í∑∏Î£π Ï†ïÎ≥¥ Ï°∞Ìöå"""
        return {
            'price_comparable': {'variables': ['SMA', 'EMA', 'price'], 'description': 'Í∞ÄÍ≤© ÎπÑÍµê Í∞ÄÎä•'},
            'percentage_comparable': {'variables': ['RSI', 'STOCH', 'CCI'], 'description': 'Î∞±Î∂ÑÏú® ÎπÑÍµê Í∞ÄÎä•'},
            'zero_centered': {'variables': ['MACD', 'MACD_signal'], 'description': 'ÏòÅÏ†ê Ï§ëÏã¨'},
            'volume_comparable': {'variables': ['volume', 'OBV'], 'description': 'Í±∞ÎûòÎüâ ÎπÑÍµê Í∞ÄÎä•'},
            'volatility_comparable': {'variables': ['ATR', 'BB_width'], 'description': 'Î≥ÄÎèôÏÑ± ÎπÑÍµê Í∞ÄÎä•'}
        }

    def get_parameter_definition(self, variable_id: str, parameter_name: str) -> Optional[Dict[str, Any]]:
        """ÌååÎùºÎØ∏ÌÑ∞ Ï†ïÏùò Ï°∞Ìöå"""
        return None

    def get_parameter_help_text(self, variable_id: str, parameter_name: str) -> Optional[str]:
        """ÌååÎùºÎØ∏ÌÑ∞ ÎèÑÏõÄÎßê ÌÖçÏä§Ìä∏ Ï°∞Ìöå"""
        return None

    def get_required_parameters(self, variable_id: str) -> List[str]:
        """ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞ Î™©Î°ù Ï°∞Ìöå"""
        return []

    def get_system_settings(self) -> Dict[str, Any]:
        """ÏãúÏä§ÌÖú ÏÑ§Ï†ï Ï°∞Ìöå"""
        return {}

    def get_variable_help_text(self, variable_id: str) -> Optional[str]:
        """Î≥ÄÏàò ÎèÑÏõÄÎßê ÌÖçÏä§Ìä∏ Ï°∞Ìöå"""
        return None

    def get_variable_placeholder_text(self, variable_id: str, parameter_name: Optional[str] = None) -> Optional[str]:
        """Î≥ÄÏàò ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî ÌÖçÏä§Ìä∏ Ï°∞Ìöå"""
        return None

    def get_variable_source(self, variable_id: str) -> Optional[str]:
        """Î≥ÄÏàò ÏÜåÏä§ Ï†ïÎ≥¥ Ï°∞Ìöå"""
        return 'database'

    def get_variables_count(self) -> int:
        """Ï¥ù Î≥ÄÏàò Í∞úÏàò Ï°∞Ìöå"""
        return len(self.get_trading_variables())

    def get_variables_count_by_category(self, purpose_category: str) -> int:
        """Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î≥ÄÏàò Í∞úÏàò Ï°∞Ìöå"""
        return len(self.get_trading_variables_by_category(purpose_category))

    def is_variable_active(self, variable_id: str) -> bool:
        """Î≥ÄÏàò ÌôúÏÑ±Ìôî ÏÉÅÌÉú ÌôïÏù∏"""
        return self.find_trading_variable_by_id(variable_id) is not None

    def requires_parameters(self, variable_id: str) -> bool:
        """ÌååÎùºÎØ∏ÌÑ∞ ÌïÑÏöî Ïó¨Î∂Ä ÌôïÏù∏"""
        return len(self.get_required_parameters(variable_id)) > 0

    def search_variables(self, query: str) -> List[TradingVariable]:
        """Î≥ÄÏàò Í≤ÄÏÉâ"""
        all_variables = self.get_trading_variables()
        query_lower = query.lower()
        return [
            var for var in all_variables
            if query_lower in var.variable_id.lower() or query_lower in var.display_name.lower()
        ]

    def get_compatibility_rules(self) -> ComparisonGroupRules:
        """Ìò∏ÌôòÏÑ± Í∑úÏπô Ï°∞Ìöå - get_comparison_group_rules ÏúÑÏûÑ"""
        return self.get_comparison_group_rules()

    def is_variable_compatible_with(self, variable_id1: str, variable_id2: str) -> bool:
        """Î≥ÄÏàò Í∞Ñ Ìò∏ÌôòÏÑ± ÌôïÏù∏"""
        # Í∞ÑÎã®Ìïú Íµ¨ÌòÑ: Í∞ôÏùÄ comparison_groupÏù¥Î©¥ Ìò∏Ìôò
        var1 = self.find_trading_variable_by_id(variable_id1)
        var2 = self.find_trading_variable_by_id(variable_id2)

        if not var1 or not var2:
            self._logger.debug(f"üîç Ìò∏ÌôòÏÑ± Í≤ÄÏ¶ù Ïã§Ìå®: Î≥ÄÏàò Ï°∞Ìöå Î∂àÍ∞Ä ({variable_id1}, {variable_id2})")
            return False

        is_compatible = var1.comparison_group == var2.comparison_group
        self._logger.debug(f"üîç Ìò∏ÌôòÏÑ± Í≤ÄÏ¶ù: {variable_id1} ‚Üî {variable_id2} = {is_compatible}")
        return is_compatible
