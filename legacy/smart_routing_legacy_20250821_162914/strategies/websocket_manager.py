"""
WebSocket Íµ¨ÎèÖ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú

WebSocket Ïó∞Í≤∞Ïùò ÏÉùÎ™ÖÏ£ºÍ∏∞Î•º ÏûêÏú®Ï†ÅÏúºÎ°ú Í¥ÄÎ¶¨ÌïòÍ≥†
Ìö®Ïú®Ï†ÅÏù∏ Íµ¨ÎèÖ Ï†ïÏ±ÖÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
"""

import asyncio
import json
import uuid
from typing import Dict, List, Set, Optional, Callable, Any
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import logging

from ..models import TradingSymbol
from .rate_limit_mapper import IntegratedRateLimiter, RateLimitType
from upbit_auto_trading.infrastructure.external_apis.upbit.upbit_websocket_quotation_client import (
    UpbitWebSocketQuotationClient,
    WebSocketDataType,
    WebSocketMessage
)


class SubscriptionState(Enum):
    """Íµ¨ÎèÖ ÏÉÅÌÉú"""
    PENDING = "pending"        # Íµ¨ÎèÖ ÏöîÏ≤≠Îê®
    ACTIVE = "active"          # ÌôúÏÑ± Íµ¨ÎèÖ Ï§ë
    PAUSED = "paused"          # ÏùºÏãú Ï†ïÏßÄ
    CANCELLED = "cancelled"    # Ï∑®ÏÜåÎê®
    ERROR = "error"           # Ïò§Î•ò ÏÉÅÌÉú


class ConnectionState(Enum):
    """Ïó∞Í≤∞ ÏÉÅÌÉú"""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    RECONNECTING = "reconnecting"
    FAILED = "failed"


@dataclass
class SubscriptionInfo:
    """Íµ¨ÎèÖ Ï†ïÎ≥¥"""

    subscription_id: str
    symbol: TradingSymbol
    data_types: List[str]
    callback: Callable[[Dict[str, Any]], None]
    created_at: datetime
    state: SubscriptionState = SubscriptionState.PENDING
    last_data_time: Optional[datetime] = None
    error_count: int = 0
    total_messages: int = 0

    @property
    def is_active(self) -> bool:
        """ÌôúÏÑ± ÏÉÅÌÉú Ïó¨Î∂Ä"""
        return self.state == SubscriptionState.ACTIVE

    @property
    def idle_duration(self) -> timedelta:
        """ÎßàÏßÄÎßâ Îç∞Ïù¥ÌÑ∞ Ïù¥ÌõÑ Í≤ΩÍ≥º ÏãúÍ∞Ñ"""
        if self.last_data_time:
            return datetime.now() - self.last_data_time
        return datetime.now() - self.created_at


@dataclass
class ConnectionMetrics:
    """Ïó∞Í≤∞ Î©îÌä∏Î¶≠"""

    connection_attempts: int = 0
    successful_connections: int = 0
    disconnection_count: int = 0
    last_connection_time: Optional[datetime] = None
    last_disconnection_time: Optional[datetime] = None
    total_messages_received: int = 0
    total_errors: int = 0
    uptime_seconds: float = 0.0

    @property
    def connection_success_rate(self) -> float:
        """Ïó∞Í≤∞ ÏÑ±Í≥µÎ•†"""
        if self.connection_attempts == 0:
            return 0.0
        return self.successful_connections / self.connection_attempts

    @property
    def avg_session_duration(self) -> float:
        """ÌèâÍ∑† ÏÑ∏ÏÖò ÏßÄÏÜç ÏãúÍ∞Ñ (Ï¥à)"""
        if self.successful_connections == 0:
            return 0.0
        return self.uptime_seconds / self.successful_connections


class WebSocketSubscriptionManager:
    """WebSocket Íµ¨ÎèÖ Í¥ÄÎ¶¨Ïûê

    Ï£ºÏöî Í∏∞Îä•:
    1. ÏûêÎèô Ïó∞Í≤∞ Í¥ÄÎ¶¨ Î∞è Ïû¨Ïó∞Í≤∞
    2. Íµ¨ÎèÖ ÏÉùÎ™ÖÏ£ºÍ∏∞ Í¥ÄÎ¶¨
    3. Ïú†Ìú¥ Íµ¨ÎèÖ ÏûêÎèô Ï†ïÎ¶¨
    4. Ïò§Î•ò Î≥µÍµ¨ Î∞è Î∞±Ïò§ÌîÑ
    5. ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ
    """

    def __init__(
        self,
        websocket_url: str = "wss://api.upbit.com/websocket/v1",
        max_connections: int = 5,
        max_subscriptions_per_connection: int = 10,
        idle_timeout_minutes: int = 30,
        reconnect_max_attempts: int = 5,
        reconnect_base_delay: float = 1.0
    ):
        self.websocket_url = websocket_url
        self.max_connections = max_connections
        self.max_subscriptions_per_connection = max_subscriptions_per_connection
        self.idle_timeout_minutes = idle_timeout_minutes
        self.reconnect_max_attempts = reconnect_max_attempts
        self.reconnect_base_delay = reconnect_base_delay

        # Rate Limiting ÌÜµÌï©
        self.rate_limiter = IntegratedRateLimiter()

        # Íµ¨ÎèÖ Í¥ÄÎ¶¨
        self.subscriptions: Dict[str, SubscriptionInfo] = {}
        self.symbol_to_subscriptions: Dict[str, Set[str]] = {}

        # Ïó∞Í≤∞ Í¥ÄÎ¶¨
        self.connections: Dict[str, UpbitWebSocketQuotationClient] = {}  # connection_id -> websocket_client
        self.connection_states: Dict[str, ConnectionState] = {}
        self.connection_metrics: Dict[str, ConnectionMetrics] = {}
        self.connection_subscriptions: Dict[str, Set[str]] = {}  # connection_id -> subscription_ids

        # ÏûêÎèô Í¥ÄÎ¶¨ ÌÉúÏä§ÌÅ¨
        self.management_tasks: Set[asyncio.Task] = set()
        self.is_running = False

        self.logger = logging.getLogger(self.__class__.__name__)

    async def start(self) -> None:
        """Íµ¨ÎèÖ Í¥ÄÎ¶¨Ïûê ÏãúÏûë"""
        if self.is_running:
            return

        self.is_running = True

        # ÏûêÎèô Í¥ÄÎ¶¨ ÌÉúÏä§ÌÅ¨ ÏãúÏûë
        self.management_tasks.add(
            asyncio.create_task(self._cleanup_task())
        )
        self.management_tasks.add(
            asyncio.create_task(self._health_monitor_task())
        )

        self.logger.info("WebSocket Íµ¨ÎèÖ Í¥ÄÎ¶¨Ïûê ÏãúÏûëÎê®")

    async def stop(self) -> None:
        """Íµ¨ÎèÖ Í¥ÄÎ¶¨Ïûê Ï¢ÖÎ£å"""
        if not self.is_running:
            return

        self.is_running = False

        # Î™®Îì† Íµ¨ÎèÖ Ï∑®ÏÜå
        for subscription_id in list(self.subscriptions.keys()):
            await self.unsubscribe(subscription_id)

        # Î™®Îì† Ïó∞Í≤∞ Ï¢ÖÎ£å
        for connection_id in list(self.connections.keys()):
            await self._close_connection(connection_id)

        # Í¥ÄÎ¶¨ ÌÉúÏä§ÌÅ¨ Ï¢ÖÎ£å
        for task in self.management_tasks:
            if not task.done():
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass

        self.management_tasks.clear()

        self.logger.info("WebSocket Íµ¨ÎèÖ Í¥ÄÎ¶¨Ïûê Ï¢ÖÎ£åÎê®")

    async def subscribe(
        self,
        symbol: TradingSymbol,
        data_types: List[str],
        callback: Callable[[Dict[str, Any]], None]
    ) -> str:
        """Îç∞Ïù¥ÌÑ∞ Íµ¨ÎèÖ (Rate Limiting Ï†ÅÏö©)"""

        if not self.is_running:
            await self.start()

        # WebSocket Ïó∞Í≤∞/Î©îÏãúÏßÄ Ï†ÑÏÜ°Ïóê ÎåÄÌïú Rate Limiting ÌôïÏù∏
        if not await self.rate_limiter.wait_for_availability(RateLimitType.WEBSOCKET, timeout_seconds=5.0):
            self.logger.warning(f"WebSocket rate limitÏúºÎ°ú Íµ¨ÎèÖ Ïã§Ìå®: {symbol}")
            raise Exception(f"WebSocket rate limit exceeded for subscription: {symbol}")

        subscription_id = str(uuid.uuid4())

        # Íµ¨ÎèÖ Ï†ïÎ≥¥ ÏÉùÏÑ±
        subscription = SubscriptionInfo(
            subscription_id=subscription_id,
            symbol=symbol,
            data_types=data_types,
            callback=callback,
            created_at=datetime.now()
        )

        self.subscriptions[subscription_id] = subscription

        # Ïã¨Î≥ºÎ≥Ñ Ïù∏Îç±Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ - ÏóÖÎπÑÌä∏ ÌòïÏãùÏúºÎ°ú ÌÜµÏùº
        symbol_key = symbol.to_upbit_symbol()  # KRW-BTC ÌòïÏãù
        if symbol_key not in self.symbol_to_subscriptions:
            self.symbol_to_subscriptions[symbol_key] = set()
        self.symbol_to_subscriptions[symbol_key].add(subscription_id)

        self.logger.debug(f"üîó Ïã¨Î≥º Îß§Ìïë ÏÉùÏÑ±: {symbol_key} -> {subscription_id}")

        # Ï†ÅÏ†àÌïú Ïó∞Í≤∞Ïóê Ìï†Îãπ
        connection_id = await self._assign_to_connection(subscription_id)

        if connection_id:
            # WebSocket Íµ¨ÎèÖ Î©îÏãúÏßÄ Ï†ÑÏÜ°
            await self._send_subscribe_message(connection_id, subscription)
            subscription.state = SubscriptionState.ACTIVE

            self.logger.info(f"Íµ¨ÎèÖ ÏÉùÏÑ±Îê®: {subscription_id} -> {symbol} {data_types}")
        else:
            subscription.state = SubscriptionState.ERROR
            self.logger.error(f"Íµ¨ÎèÖ Ïã§Ìå®: ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïó∞Í≤∞ ÏóÜÏùå - {subscription_id}")

        return subscription_id

    async def unsubscribe(self, subscription_id: str) -> bool:
        """Íµ¨ÎèÖ Ìï¥Ï†ú"""

        if subscription_id not in self.subscriptions:
            return False

        subscription = self.subscriptions[subscription_id]

        # Ïó∞Í≤∞ÏóêÏÑú Íµ¨ÎèÖ Ï†úÍ±∞
        connection_id = self._find_connection_for_subscription(subscription_id)
        if connection_id:
            await self._send_unsubscribe_message(connection_id, subscription)
            self.connection_subscriptions[connection_id].discard(subscription_id)

        # Íµ¨ÎèÖ Ï†ïÎ≥¥ Ï†úÍ±∞
        subscription.state = SubscriptionState.CANCELLED
        del self.subscriptions[subscription_id]

        # Ïã¨Î≥ºÎ≥Ñ Ïù∏Îç±Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ - ÏóÖÎπÑÌä∏ ÌòïÏãùÏúºÎ°ú ÌÜµÏùº
        symbol_key = subscription.symbol.to_upbit_symbol()  # KRW-BTC ÌòïÏãù
        if symbol_key in self.symbol_to_subscriptions:
            self.symbol_to_subscriptions[symbol_key].discard(subscription_id)
            if not self.symbol_to_subscriptions[symbol_key]:
                del self.symbol_to_subscriptions[symbol_key]

        self.logger.info(f"Íµ¨ÎèÖ Ìï¥Ï†úÎê®: {subscription_id}")
        return True

    async def pause_subscription(self, subscription_id: str) -> bool:
        """Íµ¨ÎèÖ ÏùºÏãú Ï†ïÏßÄ"""

        if subscription_id not in self.subscriptions:
            return False

        subscription = self.subscriptions[subscription_id]
        if subscription.state == SubscriptionState.ACTIVE:
            subscription.state = SubscriptionState.PAUSED

            # Ïó∞Í≤∞ÏóêÏÑú ÏùºÏãúÏ†ÅÏúºÎ°ú Íµ¨ÎèÖ Ìï¥Ï†ú
            connection_id = self._find_connection_for_subscription(subscription_id)
            if connection_id:
                await self._send_unsubscribe_message(connection_id, subscription)

            self.logger.info(f"Íµ¨ÎèÖ ÏùºÏãúÏ†ïÏßÄ: {subscription_id}")
            return True

        return False

    async def resume_subscription(self, subscription_id: str) -> bool:
        """Íµ¨ÎèÖ Ïû¨Í∞ú"""

        if subscription_id not in self.subscriptions:
            return False

        subscription = self.subscriptions[subscription_id]
        if subscription.state == SubscriptionState.PAUSED:
            # Ïó∞Í≤∞Ïóê Îã§Ïãú Íµ¨ÎèÖ
            connection_id = await self._assign_to_connection(subscription_id)
            if connection_id:
                await self._send_subscribe_message(connection_id, subscription)
                subscription.state = SubscriptionState.ACTIVE

                self.logger.info(f"Íµ¨ÎèÖ Ïû¨Í∞ú: {subscription_id}")
                return True

        return False

    def get_subscription_stats(self) -> Dict[str, Any]:
        """Íµ¨ÎèÖ ÌÜµÍ≥Ñ Ï†ïÎ≥¥"""

        active_count = sum(1 for s in self.subscriptions.values() if s.is_active)

        # ÏÉÅÌÉúÎ≥Ñ Í∞úÏàò
        state_counts = {}
        for state in SubscriptionState:
            count = sum(1 for s in self.subscriptions.values() if s.state == state)
            state_counts[state.value] = count

        # Ïó∞Í≤∞ ÌÜµÍ≥Ñ
        connection_stats = {}
        for conn_id, metrics in self.connection_metrics.items():
            connection_stats[conn_id] = {
                "state": self.connection_states.get(conn_id, ConnectionState.DISCONNECTED).value,
                "subscriptions": len(self.connection_subscriptions.get(conn_id, set())),
                "success_rate": metrics.connection_success_rate,
                "total_messages": metrics.total_messages_received,
                "uptime_seconds": metrics.uptime_seconds
            }

        return {
            "total_subscriptions": len(self.subscriptions),
            "active_subscriptions": active_count,
            "subscription_states": state_counts,
            "total_connections": len(self.connections),
            "connection_stats": connection_stats,
            "symbols_monitored": len(self.symbol_to_subscriptions)
        }

    async def _assign_to_connection(self, subscription_id: str) -> Optional[str]:
        """Íµ¨ÎèÖÏùÑ Ï†ÅÏ†àÌïú Ïó∞Í≤∞Ïóê Ìï†Îãπ"""

        # Í∏∞Ï°¥ Ïó∞Í≤∞ Ï§ë Ïó¨Ïú†Í∞Ä ÏûàÎäî Í≤É Ï∞æÍ∏∞
        for conn_id, sub_ids in self.connection_subscriptions.items():
            if (len(sub_ids) < self.max_subscriptions_per_connection and
                self.connection_states.get(conn_id) == ConnectionState.CONNECTED):

                sub_ids.add(subscription_id)
                return conn_id

        # ÏÉà Ïó∞Í≤∞ ÏÉùÏÑ± ÌïÑÏöî
        if len(self.connections) < self.max_connections:
            return await self._create_new_connection()

        # Ïó∞Í≤∞ Ï†úÌïú ÎèÑÎã¨
        self.logger.warning("ÏµúÎåÄ Ïó∞Í≤∞ ÏàòÏóê ÎèÑÎã¨Ìï®")
        return None

    async def _create_new_connection(self) -> Optional[str]:
        """ÏÉà WebSocket Ïó∞Í≤∞ ÏÉùÏÑ± (Rate Limiting Ï†ÅÏö©)"""

        # WebSocket Ïó∞Í≤∞ ÏöîÏ≤≠Ïóê ÎåÄÌïú Rate Limiting ÌôïÏù∏
        if not await self.rate_limiter.wait_for_availability(RateLimitType.WEBSOCKET, timeout_seconds=3.0):
            self.logger.warning("WebSocket rate limitÏúºÎ°ú Ïó∞Í≤∞ ÏÉùÏÑ± Ïã§Ìå®")
            return None

        connection_id = str(uuid.uuid4())

        try:
            # Ïã§Ï†ú WebSocket ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ±
            client = UpbitWebSocketQuotationClient()

            # Î©îÏãúÏßÄ Ìï∏Îì§Îü¨ Îì±Î°ù
            client.add_message_handler(WebSocketDataType.TICKER, self._handle_websocket_message)
            client.add_message_handler(WebSocketDataType.ORDERBOOK, self._handle_websocket_message)
            client.add_message_handler(WebSocketDataType.TRADE, self._handle_websocket_message)

            self.connection_states[connection_id] = ConnectionState.CONNECTING
            self.connection_metrics[connection_id] = ConnectionMetrics()
            self.connection_subscriptions[connection_id] = set()

            # Ïã§Ï†ú Ïó∞Í≤∞ ÏàòÌñâ
            await client.connect()

            # Ïó∞Í≤∞ ÏÑ±Í≥µ
            self.connections[connection_id] = client
            self.connection_states[connection_id] = ConnectionState.CONNECTED
            self.connection_metrics[connection_id].successful_connections += 1
            self.connection_metrics[connection_id].last_connection_time = datetime.now()

            # Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà ÏãúÏûë (Î∞±Í∑∏ÎùºÏö¥Îìú)
            asyncio.create_task(self._message_listener(connection_id, client))

            self.logger.info(f"‚úÖ Ïã§Ï†ú WebSocket Ïó∞Í≤∞ ÏÉùÏÑ±: {connection_id}")
            return connection_id

        except Exception as e:
            self.logger.error(f"‚ùå WebSocket Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            if connection_id in self.connection_states:
                self.connection_states[connection_id] = ConnectionState.FAILED
            return None

    async def _message_listener(self, connection_id: str, client: UpbitWebSocketQuotationClient):
        """WebSocket Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà"""
        try:
            async for message in client.listen():
                # Î©îÏãúÏßÄÎäî Ìï∏Îì§Îü¨ÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®
                if connection_id in self.connection_metrics:
                    self.connection_metrics[connection_id].total_messages_received += 1
        except Exception as e:
            self.logger.error(f"‚ùå Î©îÏãúÏßÄ Î¶¨Ïä§ÎÑà Ïò§Î•ò ({connection_id}): {e}")
            if connection_id in self.connection_states:
                self.connection_states[connection_id] = ConnectionState.FAILED

    def _handle_websocket_message(self, message: WebSocketMessage):
        """WebSocket Î©îÏãúÏßÄ Ï≤òÎ¶¨"""
        try:
            # Ìï¥Îãπ Ïã¨Î≥ºÏùò Íµ¨ÎèÖÎì§ÏùÑ Ï∞æÏïÑÏÑú ÏΩúÎ∞± Ìò∏Ï∂ú
            symbol_key = message.market  # KRW-BTC ÌòïÏãù

            if symbol_key in self.symbol_to_subscriptions:
                # ÌôúÏÑ± Íµ¨ÎèÖÏù¥ ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå Ï≤òÎ¶¨
                active_subscriptions = []
                for sub_id in list(self.symbol_to_subscriptions[symbol_key]):
                    if sub_id in self.subscriptions:
                        subscription = self.subscriptions[sub_id]
                        if subscription.state == SubscriptionState.ACTIVE:
                            active_subscriptions.append(subscription)
                        else:
                            # ÎπÑÌôúÏÑ± Íµ¨ÎèÖÏùÄ Ïã¨Î≥º Îß§ÌïëÏóêÏÑú Ï†úÍ±∞
                            self.symbol_to_subscriptions[symbol_key].discard(sub_id)

                # ÌôúÏÑ± Íµ¨ÎèÖÏù¥ ÏóÜÏúºÎ©¥ Ïã¨Î≥º Îß§Ìïë Ï†ïÎ¶¨
                if not active_subscriptions:
                    if symbol_key in self.symbol_to_subscriptions:
                        del self.symbol_to_subscriptions[symbol_key]
                    self.logger.debug(f"üîç ÎπÑÌôúÏÑ± Ïã¨Î≥º Îß§Ìïë Ï†ïÎ¶¨: {symbol_key}")
                    return

                # ÌôúÏÑ± Íµ¨ÎèÖÎì§ÏóêÍ≤å Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
                for subscription in active_subscriptions:
                    subscription.last_data_time = datetime.now()
                    subscription.total_messages += 1

                    try:
                        subscription.callback(message.data)
                        self.logger.debug(f"üìä Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨: {symbol_key} -> {subscription.subscription_id}")
                    except Exception as e:
                        self.logger.error(f"‚ùå ÏΩúÎ∞± Ïò§Î•ò: {e}")
                        subscription.error_count += 1
            else:
                # Íµ¨ÎèÖÏù¥ ÏóÜÎäî Í≤ΩÏö∞ ÎîîÎ≤ÑÍ∑∏ Î†àÎ≤®Î°úÎßå Î°úÍ∑∏ (Í≤ΩÍ≥† ÏàòÏ§Ä ÎÇÆÏ∂§)
                self.logger.debug(f"üîç ÎØ∏Íµ¨ÎèÖ Ïã¨Î≥º Î©îÏãúÏßÄ: {symbol_key}")

        except Exception as e:
            self.logger.error(f"‚ùå Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")

    async def _send_subscribe_message(
        self,
        connection_id: str,
        subscription: SubscriptionInfo
    ) -> None:
        """Íµ¨ÎèÖ Î©îÏãúÏßÄ Ï†ÑÏÜ°"""

        if connection_id not in self.connections:
            self.logger.error(f"‚ùå Ïó∞Í≤∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå: {connection_id}")
            return

        client = self.connections[connection_id]
        symbol_code = subscription.symbol.to_upbit_symbol()

        try:
            # Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖÏóê Îî∞Îùº Íµ¨ÎèÖ
            success = False
            for data_type in subscription.data_types:
                if data_type == "ticker":
                    success = await client.subscribe_ticker([symbol_code])
                elif data_type == "orderbook":
                    success = await client.subscribe_orderbook([symbol_code])
                elif data_type == "trade":
                    success = await client.subscribe_trade([symbol_code])

                if success:
                    self.logger.info(f"‚úÖ Ïã§Ï†ú Íµ¨ÎèÖ ÏÑ±Í≥µ: {symbol_code} ({data_type})")
                else:
                    self.logger.error(f"‚ùå Íµ¨ÎèÖ Ïã§Ìå®: {symbol_code} ({data_type})")

        except Exception as e:
            self.logger.error(f"‚ùå Íµ¨ÎèÖ Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®: {e}")

    async def _send_unsubscribe_message(
        self,
        connection_id: str,
        subscription: SubscriptionInfo
    ) -> None:
        """Íµ¨ÎèÖ Ìï¥Ï†ú Î©îÏãúÏßÄ Ï†ÑÏÜ°"""

        # ÏóÖÎπÑÌä∏Îäî Î™ÖÏãúÏ†Å Íµ¨ÎèÖ Ìï¥Ï†ú Î©îÏãúÏßÄÍ∞Ä ÏóÜÏúºÎØÄÎ°ú
        # Ïó∞Í≤∞ Î†àÎ≤®ÏóêÏÑú Í¥ÄÎ¶¨
        self.logger.debug(f"Íµ¨ÎèÖ Ìï¥Ï†ú Ï≤òÎ¶¨: {connection_id} -> {subscription.subscription_id}")

    def _find_connection_for_subscription(self, subscription_id: str) -> Optional[str]:
        """Íµ¨ÎèÖÏù¥ ÏÜçÌïú Ïó∞Í≤∞ Ï∞æÍ∏∞"""

        for conn_id, sub_ids in self.connection_subscriptions.items():
            if subscription_id in sub_ids:
                return conn_id
        return None

    async def _close_connection(self, connection_id: str) -> None:
        """Ïó∞Í≤∞ Ï¢ÖÎ£å (ÏûêÎèô Ïû¨Ïó∞Í≤∞ ÎπÑÌôúÏÑ±Ìôî)"""

        if connection_id in self.connections:
            try:
                # Ïã§Ï†ú WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú (ÏûêÎèô Ïû¨Ïó∞Í≤∞ ÎπÑÌôúÏÑ±Ìôî)
                client = self.connections[connection_id]
                client.auto_reconnect = False  # ÏûêÎèô Ïû¨Ïó∞Í≤∞ ÎπÑÌôúÏÑ±Ìôî
                await client.disconnect()
                self.logger.info(f"‚úÖ WebSocket Ïó∞Í≤∞ Ìï¥Ï†ú: {connection_id}")
            except Exception as e:
                self.logger.error(f"‚ùå Ïó∞Í≤∞ Ìï¥Ï†ú Ïò§Î•ò: {e}")
            finally:
                del self.connections[connection_id]

        if connection_id in self.connection_states:
            self.connection_states[connection_id] = ConnectionState.DISCONNECTED

        # Ìï¥Îãπ Ïó∞Í≤∞Ïùò Î™®Îì† Íµ¨ÎèÖÏùÑ Ïò§Î•ò ÏÉÅÌÉúÎ°ú
        if connection_id in self.connection_subscriptions:
            for sub_id in self.connection_subscriptions[connection_id]:
                if sub_id in self.subscriptions:
                    self.subscriptions[sub_id].state = SubscriptionState.ERROR
            del self.connection_subscriptions[connection_id]

        self.logger.info(f"Ïó∞Í≤∞ Ï¢ÖÎ£å ÏôÑÎ£å: {connection_id}")

    async def _cleanup_task(self) -> None:
        """Ïú†Ìú¥ Íµ¨ÎèÖ Ï†ïÎ¶¨ ÌÉúÏä§ÌÅ¨"""

        while self.is_running:
            try:
                await asyncio.sleep(60)  # 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨

                current_time = datetime.now()
                idle_threshold = timedelta(minutes=self.idle_timeout_minutes)

                # Ïú†Ìú¥ Íµ¨ÎèÖ Ï∞æÍ∏∞
                idle_subscriptions = []
                for sub_id, subscription in self.subscriptions.items():
                    if subscription.idle_duration > idle_threshold:
                        idle_subscriptions.append(sub_id)

                # Ïú†Ìú¥ Íµ¨ÎèÖ Ï†úÍ±∞
                for sub_id in idle_subscriptions:
                    await self.unsubscribe(sub_id)
                    self.logger.info(f"Ïú†Ìú¥ Íµ¨ÎèÖ Ï†ïÎ¶¨: {sub_id}")

            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"Ï†ïÎ¶¨ ÌÉúÏä§ÌÅ¨ Ïò§Î•ò: {e}")

    async def _health_monitor_task(self) -> None:
        """Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ ÌÉúÏä§ÌÅ¨"""

        while self.is_running:
            try:
                await asyncio.sleep(30)  # 30Ï¥àÎßàÎã§ Ï≤¥ÌÅ¨

                # Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
                for conn_id in list(self.connection_states.keys()):
                    state = self.connection_states[conn_id]

                    if state == ConnectionState.FAILED:
                        # Ïã§Ìå®Ìïú Ïó∞Í≤∞Ïùò Íµ¨ÎèÖÎì§ÏùÑ Îã§Î•∏ Ïó∞Í≤∞Î°ú Ïù¥Ï†Ñ
                        await self._migrate_subscriptions_from_failed_connection(conn_id)
                        await self._close_connection(conn_id)

            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}")

    async def _migrate_subscriptions_from_failed_connection(
        self,
        failed_connection_id: str
    ) -> None:
        """Ïã§Ìå®Ìïú Ïó∞Í≤∞Ïùò Íµ¨ÎèÖÎì§ÏùÑ Îã§Î•∏ Ïó∞Í≤∞Î°ú Ïù¥Ï†Ñ"""

        if failed_connection_id not in self.connection_subscriptions:
            return

        sub_ids = list(self.connection_subscriptions[failed_connection_id])

        for sub_id in sub_ids:
            if sub_id in self.subscriptions:
                subscription = self.subscriptions[sub_id]

                # ÏÉà Ïó∞Í≤∞Ïóê Ìï†Îãπ ÏãúÎèÑ
                new_connection_id = await self._assign_to_connection(sub_id)

                if new_connection_id:
                    await self._send_subscribe_message(new_connection_id, subscription)
                    subscription.state = SubscriptionState.ACTIVE
                    self.logger.info(f"Íµ¨ÎèÖ Ïù¥Ï†Ñ ÏôÑÎ£å: {sub_id} -> {new_connection_id}")
                else:
                    subscription.state = SubscriptionState.ERROR
                    self.logger.error(f"Íµ¨ÎèÖ Ïù¥Ï†Ñ Ïã§Ìå®: {sub_id}")
