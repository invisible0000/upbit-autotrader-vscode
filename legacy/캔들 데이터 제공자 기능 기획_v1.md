# 캔들 데이터 제공자 기능 기획 v1.0
> 현재 구현 상황 반영 및 단계별 구현 계획

## 🎯 요구 기능

### 핵심 기능 (최소 구현 - Phase 1)
1. **캔들 데이터 수집**: 업비트 API에서 캔들 데이터 조회
2. **캔들 데이터 저장**: SQLite DB에 안전하게 저장 (기존 SqliteCandleRepository 활용)
3. **캔들 데이터 제공**: 서브시스템에게 데이터 제공 (CandleDataResponse 형태)
4. **기본 캐시**: 중복 요청 방지를 위한 간단한 메모리 캐시 (60초 TTL)

### 확장 기능 (Phase 2)
1. **청크 처리**: 200개 초과 요청시 자동 분할
2. **오버랩 분석**: 기존 OverlapAnalyzer 활용한 최적화
3. **연속성 보장**: 청크 간 시간 연속성 검증
4. **다양한 파라미터**: to, end 파라미터 지원

### 부가정보
- `datetime.now(timezone.utc)` 기준 사용 환경 시간 따름 (사용자 책임)
- 기존 컴포넌트 최대한 활용: TimeUtils, CandleModels, SqliteCandleRepository
- DDD 아키텍처 준수: Infrastructure Layer 서비스로 구현

## 📋 동작 상세

### 시스템 요청 정보 관리
모든 요청은 내부적으로 표준화된 RequestInfo 구조로 관리:
```python
@dataclass
class RequestInfo:
    symbol: str          # 거래 심볼 (예: 'KRW-BTC')
    timeframe: str       # 타임프레임 (예: '5m', '1h', '1d')
    count: int           # 캔들 개수
    start_time: datetime # 시작 시간 (정렬된 시간)
    end_time: datetime   # 종료 시간 (정렬된 시간)

    # 상호 배타적: count 또는 end_time 중 하나만 사용
    # count가 있으면 start_time + count로 end_time 계산
    # end_time이 있으면 start_time과 end_time으로 count 계산
```

### 요청 정규화 (Normalize)
모든 요청은 다음과 같이 정규화됨:

1. **시간 정렬**: TimeUtils를 활용하여 타임프레임에 맞는 정렬된 시간으로 변환
2. **기본 start_time 생성**: to 파라미터가 없으면 `datetime.now(timezone.utc)`를 기준으로 생성
3. **청크 분할**: TimeUtils 기반으로 200개 단위 청크로 분할
4. **청크별 범위**: 각 청크는 고유한 start_time, end_time을 가짐

```python
# 예시: 정규화 과정
# 입력: get_candles("KRW-BTC", "5m", 500)
# 1. 현재 시간 기준 start_time 생성 및 정렬
# 2. count=500 → 3개 청크로 분할 (200 + 200 + 100)
# 3. 각 청크별 start_time, end_time 계산
```

### 청크 처리 메커니즘

#### Phase 1 (최소 구현)
- **200개 이하**: 단일 청크로 처리, 오버랩 분석 없이 단순 처리
- **200개 초과**: NotImplementedError (Phase 2에서 구현)

#### Phase 2 (확장 구현)
각 청크 처리시 다음과 같은 연속성 보장 메커니즘 적용:

1. **오버랩 분석**: 기존 OverlapAnalyzer를 청크별 요청에 대해 사용
2. **응답 검증**: 실제 업비트 응답의 마지막 `candle_date_time_utc` 확인
3. **연속성 조정**:
   - 조건: `응답 마지막 시간 - timeframe간격 == 다음 청크 start_time`
   - 불일치시: 차이만큼 다음 청크의 start_time과 end_time 조정
4. **최종 검증**: 모든 청크 처리 후 전체 범위의 DB 데이터 개수와 요청 개수 비교
   - 초기 검증용 (시스템 안정화 후 제거 가능)

## 🔧 get_candles 파라미터별 동작

### 1. count만 (200개 이하) - Phase 1 구현
```python
# 사용법
response = await provider.get_candles("KRW-BTC", "5m", 100)

# 동작 방식: 청크 기반 (기본)
```
**처리 순서:**
1. 현재 시간(`datetime.now(timezone.utc)`)을 start_time으로 설정
2. TimeUtils로 정렬된 시간으로 변환
3. start_time에서 count개만큼 과거로 end_time 계산
4. 단일 청크로 처리 (200개 이하)
5. 캐시 확인 → DB 조회 → API 요청 → 저장 순서

### 2. count만 (200개 초과) - Phase 2 구현
```python
# 사용법
response = await provider.get_candles("KRW-BTC", "5m", 500)

# 동작 방식: 다중 청크 기반
```
**처리 순서:**
1. 500개를 200개씩 3개 청크로 분할
2. 각 청크별로 OverlapAnalyzer 사용
3. 청크 간 연속성 보장 메커니즘 적용
4. 모든 청크 결과를 합쳐서 반환

### 3. count, to - Phase 2 구현
```python
# 사용법
to_time = datetime(2025, 9, 11, 14, 30, tzinfo=timezone.utc)
response = await provider.get_candles("KRW-BTC", "5m", count=100, to=to_time)

# 동작 방식
```
**처리 순서:**
1. `to`를 start_time으로 설정
2. TimeUtils로 정렬된 시간으로 변환
3. start_time에서 count개만큼 과거로 end_time 계산
4. 청크 기반 처리 (200개 초과시 분할)

### 4. to, end - Phase 2 구현
```python
# 사용법
to_time = datetime(2025, 9, 11, 14, 30, tzinfo=timezone.utc)
end_time = datetime(2025, 9, 11, 10, 30, tzinfo=timezone.utc)
response = await provider.get_candles("KRW-BTC", "5m", to=to_time, end=end_time)

# 동작 방식
```
**처리 순서:**
1. `to`를 start_time, `end`를 end_time으로 설정
2. 두 시간 모두 TimeUtils로 정렬
3. TimeUtils.calculate_expected_count()로 count 계산
4. 청크 기반 처리

### 5. end만 - Phase 2 구현
```python
# 사용법
end_time = datetime(2025, 9, 11, 10, 30, tzinfo=timezone.utc)
response = await provider.get_candles("KRW-BTC", "5m", end=end_time)

# 동작 방식
```
**처리 순서:**
1. `datetime.now(timezone.utc)`를 start_time으로 설정
2. 제공된 `end`를 end_time으로 설정
3. 두 시간 모두 TimeUtils로 정렬
4. TimeUtils.calculate_expected_count()로 count 계산
5. 청크 기반 처리

## 🛠️ Direct 요청 기능 (필요성 검토 중)

### 개념
복잡한 청크 처리와 오버랩 분석을 건너뛰고 직접 API 요청하는 옵션

### 조건
- 200개 이하 요청만 가능
- `direct=True` 옵션 명시 필요 (기본값: False)
- 오버랩 분석기 사용하지 않음
- 바로 REST API로 요청 후 DB에 저장

### 사용법 (검토 중)
```python
# direct 요청 (오버랩 분석 생략)
response = await provider.get_candles("KRW-BTC", "5m", 100, direct=True)
```

### 필요성 검토 사항
1. **성능 이점**: 오버랩 분석 생략으로 얻는 성능 향상이 의미있는지?
2. **복잡성 증가**: API 복잡도 증가 대비 실용성은?
3. **사용 시나리오**: 실제로 direct 요청이 필요한 상황이 있는지?

**권장 결정**: Phase 1에서는 제외하고, Phase 2에서 실제 필요성이 확인되면 추가

## 📊 구현 우선순위

### Phase 1 (최소 동작 버전)
- [x] 기존 컴포넌트 활용 (TimeUtils, CandleModels, SqliteCandleRepository)
- [ ] count만 지원 (200개 이하)
- [ ] 기본 캐시 구현
- [ ] 파라미터 검증
- [ ] 단일 청크 처리
- [ ] 기본 에러 처리

### Phase 2 (확장 기능)
- [ ] 다중 청크 처리 (200개 초과)
- [ ] OverlapAnalyzer 통합
- [ ] to, end 파라미터 지원
- [ ] 청크 간 연속성 보장
- [ ] 고급 에러 처리

### Phase 3 (최적화)
- [ ] direct 요청 기능 (필요시)
- [ ] 성능 최적화
- [ ] 통계 수집
- [ ] 모니터링 기능

## 🧪 검증 기준

### Phase 1 완성 기준
```python
# 기본 요청 동작
response = await provider.get_candles("KRW-BTC", "5m", 100)
assert response.success == True
assert len(response.candles) == 100
assert response.data_source in ["cache", "db", "api"]

# 캐시 동작
response2 = await provider.get_candles("KRW-BTC", "5m", 100)
assert response2.data_source == "cache"

# 에러 처리
response3 = await provider.get_candles("INVALID", "5m", 100)
assert response3.success == False
```

### Phase 2 완성 기준
```python
# 대량 요청 (청크 분할)
response = await provider.get_candles("KRW-BTC", "5m", 500)
assert response.success == True
assert len(response.candles) == 500

# 시간 범위 요청
to_time = datetime.now(timezone.utc)
end_time = to_time - timedelta(hours=5)
response = await provider.get_candles("KRW-BTC", "5m", to=to_time, end=end_time)
assert response.success == True
```

## 📋 기술적 고려사항

### 1. 시간 처리 일관성
- 모든 시간은 UTC timezone 사용
- TimeUtils.align_time()으로 정렬 보장
- 업비트 API의 내림차순 응답 특성 고려

### 2. 메모리 관리
- 캐시 크기 제한 (기본 100MB)
- TTL 기반 자동 정리 (60초)
- 대량 요청시 메모리 사용량 모니터링

### 3. 에러 복구
- API 요청 실패시 DB 데이터로 대체 가능하면 부분 성공 처리
- 저장 실패해도 데이터 반환 (서비스 연속성 우선)
- 명확한 에러 메시지와 복구 가이드 제공

### 4. 확장성 고려
- RequestInfo 구조로 향후 파라미터 확장 용이
- 청크 처리 메커니즘으로 대량 요청 대응
- 컴포넌트 분리로 개별 최적화 가능

---

**이 문서는 현재 구현 상황을 반영하여 실용적이고 단계적인 구현을 목표로 작성되었습니다.**
**Phase 1 완성 후 실제 사용 패턴을 분석하여 Phase 2 기능의 우선순위를 조정할 예정입니다.**
