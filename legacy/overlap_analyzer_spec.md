# ğŸ¯ OverlapAnalyzer ìƒì„¸ ê¸°ëŠ¥ ëª…ì„¸ì„œ

## ğŸ“‹ **ê°œìš”**
OverlapAnalyzerëŠ” ìš”ì²­ëœ ìº”ë“¤ ë°ì´í„°ì™€ DB ê¸°ì¡´ ë°ì´í„° ê°„ì˜ ê²¹ì¹¨ì„ ë¶„ì„í•˜ì—¬ API í˜¸ì¶œì„ ìµœì í™”í•˜ëŠ” í•µì‹¬ ëª¨ë“ˆì…ë‹ˆë‹¤. ì—…ë¹„íŠ¸ APIì˜ 200ê°œ ì œí•œì„ ê³ ë ¤í•œ ì²­í¬ ê¸°ë°˜ ìµœì í™” ì „ëµì„ êµ¬í˜„í•©ë‹ˆë‹¤.

---

## ğŸ” **í•µì‹¬ ë¬¸ì œ ì •ì˜**

### **ì—…ë¹„íŠ¸ API ì œì•½ì‚¬í•­**
- **ìµœëŒ€ 200ê°œ**: í•œ ë²ˆì— ìµœëŒ€ 200ê°œ ìº”ë“¤ë§Œ ì¡°íšŒ ê°€ëŠ¥
- **Rate Limit**: 600req/min (ì´ˆë‹¹ 10req)
- **ì‹œê°„ ì—­ìˆœ**: ìµœì‹  ë°ì´í„°ë¶€í„° ê³¼ê±° ìˆœìœ¼ë¡œ ë°˜í™˜

### **DB íŒŒí¸í™” ì‹œë‚˜ë¦¬ì˜¤**
```
ìš”ì²­: KRW-BTC 1m 2024-01-01 09:00 ~ 09:30 (30ê°œ)
DB í˜„ì¬ ìƒíƒœ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 09:00â”‚09:01â”‚09:02â”‚     â”‚09:15â”‚09:16â”‚     â”‚09:28â”‚09:29â”‚ â”‚
â”‚  âœ“  â”‚  âœ“  â”‚  âœ“  â”‚ ... â”‚  âœ“  â”‚  âœ“  â”‚ ... â”‚  âœ“  â”‚  âœ“  â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     ì¡´ì¬    ì¡´ì¬    ëˆ„ë½      ì¡´ì¬   ëˆ„ë½      ì¡´ì¬   ëˆ„ë½

íŒŒí¸í™” ë¬¸ì œ:
1. 09:03~09:14 êµ¬ê°„ ëˆ„ë½ (12ê°œ)
2. 09:17~09:27 êµ¬ê°„ ëˆ„ë½ (11ê°œ)
3. 09:30 ëˆ„ë½ (1ê°œ)
```

### **ìµœì í™” ì „ëµ ì„ íƒ**
1. **ê°œë³„ ìš”ì²­**: 3ë²ˆ API í˜¸ì¶œ (ë¹„íš¨ìœ¨)
2. **ì „ì²´ ìš”ì²­**: 200ê°œ ìš”ì²­ í›„ í•„í„°ë§ (ê³¼ë„)
3. **ì§€ëŠ¥í˜• ì²­í¬**: ê²¹ì¹¨ ë¶„ì„ í›„ ìµœì  êµ¬ê°„ ê²°ì • â­

---

## ğŸ§  **ê²¹ì¹¨ ë¶„ì„ íŒ¨í„´ (6ê°€ì§€)**

### **Pattern 1: COMPLETE_OVERLAP (ì™„ì „ í¬í•¨)**
```
ìš”ì²­ êµ¬ê°„: [09:00 ~ 09:05]
DB ë°ì´í„°: [09:00, 09:01, 09:02, 09:03, 09:04, 09:05]
ê²°ê³¼: API í˜¸ì¶œ ë¶ˆí•„ìš” â†’ ìºì‹œ/DB ì‘ë‹µ
```

### **Pattern 2: NO_OVERLAP (ì™„ì „ ë¶„ë¦¬)**
```
ìš”ì²­ êµ¬ê°„: [09:00 ~ 09:05]
DB ë°ì´í„°: [10:00, 10:01, 10:02, ...]
ê²°ê³¼: ì „ì²´ API ìš”ì²­ í•„ìš”
```

### **Pattern 3: PARTIAL_OVERLAP_START (ì•ë¶€ë¶„ ê²¹ì¹¨)**
```
ìš”ì²­ êµ¬ê°„: [09:00 ~ 09:10]
DB ë°ì´í„°: [09:00, 09:01, 09:02]
ëˆ„ë½ êµ¬ê°„: [09:03 ~ 09:10]
ìµœì í™”: 09:03ë¶€í„° API ìš”ì²­
```

### **Pattern 4: PARTIAL_OVERLAP_END (ë’·ë¶€ë¶„ ê²¹ì¹¨)**
```
ìš”ì²­ êµ¬ê°„: [09:00 ~ 09:10]
DB ë°ì´í„°: [09:08, 09:09, 09:10]
ëˆ„ë½ êµ¬ê°„: [09:00 ~ 09:07]
ìµœì í™”: 09:00~09:07ë§Œ API ìš”ì²­
```

### **Pattern 5: PARTIAL_OVERLAP_MIDDLE (ì¤‘ê°„ ê²¹ì¹¨)**
```
ìš”ì²­ êµ¬ê°„: [09:00 ~ 09:10]
DB ë°ì´í„°: [09:03, 09:04, 09:05]
ëˆ„ë½ êµ¬ê°„: [09:00~09:02] + [09:06~09:10]
ìµœì í™”: 2ê°œ êµ¬ê°„ ê°œë³„ ìš”ì²­ vs ì „ì²´ ìš”ì²­ ë¹„êµ
```

### **Pattern 6: FRAGMENTED_OVERLAP (íŒŒí¸í™” ê²¹ì¹¨)**
```
ìš”ì²­ êµ¬ê°„: [09:00 ~ 09:20]
DB ë°ì´í„°: [09:00, 09:02, 09:05, 09:18, 09:20]
ëˆ„ë½ êµ¬ê°„: [09:01, 09:03~09:04, 09:06~09:17, 09:19]
ìµœì í™”: ì²­í¬ ë¶„í•  vs ì „ì²´ ìš”ì²­ ë¹„êµ ê²°ì •
```

---

## âš™ï¸ **ìµœì í™” ê²°ì • ì•Œê³ ë¦¬ì¦˜**

### **Step 1: ìš”ì²­ ë¶„ì„**
```python
class RequestAnalysis:
    requested_range: TimeRange      # ìš”ì²­ëœ ì‹œê°„ êµ¬ê°„
    requested_count: int            # ìš”ì²­ëœ ìº”ë“¤ ê°œìˆ˜
    interval_minutes: int           # ìº”ë“¤ ê°„ê²© (1m=1, 5m=5)
    max_api_limit: int = 200        # ì—…ë¹„íŠ¸ API ì œí•œ
```

### **Step 2: DB í˜„í™© ë¶„ì„**
```python
class DBAnalysis:
    existing_candles: List[datetime]    # DBì— ì´ë¯¸ ìˆëŠ” ìº”ë“¤ ì‹œê°„ë“¤
    missing_ranges: List[TimeRange]     # ëˆ„ë½ëœ ì‹œê°„ êµ¬ê°„ë“¤
    fragmentation_ratio: float          # íŒŒí¸í™” ë¹„ìœ¨ (0.0~1.0)
    total_gaps: int                     # ì „ì²´ ëˆ„ë½ ê°œìˆ˜
```

### **Step 3: ë¹„ìš© ê³„ì‚°**
```python
class CostAnalysis:
    individual_requests: int        # ê°œë³„ ìš”ì²­ì‹œ API í˜¸ì¶œ ìˆ˜
    bulk_request_cost: int         # ì „ì²´ ìš”ì²­ì‹œ ë¹„ìš© (ì¤‘ë³µ ë°ì´í„° í¬í•¨)
    optimal_strategy: str          # ìµœì  ì „ëµ
    estimated_savings: float       # ì˜ˆìƒ ì ˆì•½ë¥  (%)
```

### **Step 4: ì „ëµ ê²°ì •**
```python
def decide_strategy(request: RequestAnalysis, db: DBAnalysis) -> Strategy:
    # 1. ì™„ì „ í¬í•¨ ì²´í¬
    if db.fragmentation_ratio == 0.0:
        return Strategy.CACHE_ONLY

    # 2. ìš”ì²­ í¬ê¸°ê°€ 200ê°œ ì´í•˜ + íŒŒí¸í™” ì‹¬ê°
    if request.requested_count <= 200 and db.fragmentation_ratio > 0.7:
        return Strategy.BULK_REQUEST

    # 3. ëˆ„ë½ êµ¬ê°„ì´ ì—°ì†ì 
    if len(db.missing_ranges) <= 2:
        return Strategy.TARGETED_REQUESTS

    # 4. ë³µì¡í•œ íŒŒí¸í™” â†’ ë¹„ìš© ë¹„êµ
    return compare_costs(request, db)
```

---

## ğŸ”§ **êµ¬í˜„ í•µì‹¬ ë¡œì§**

### **1. ì‹œê°„ êµ¬ê°„ ë¶„ì„**
```python
def analyze_time_gaps(requested_times: List[datetime],
                     existing_times: List[datetime]) -> List[TimeRange]:
    """ëˆ„ë½ëœ ì‹œê°„ êµ¬ê°„ íƒì§€"""
    missing_ranges = []

    for req_time in requested_times:
        if req_time not in existing_times:
            # ì—°ì†ëœ ëˆ„ë½ êµ¬ê°„ìœ¼ë¡œ ë³‘í•©
            merge_or_create_range(missing_ranges, req_time)

    return missing_ranges
```

### **2. ì²­í¬ ë¶„í•  ìµœì í™”**
```python
def optimize_chunks(missing_ranges: List[TimeRange],
                   api_limit: int = 200) -> List[APIRequest]:
    """200ê°œ ì œí•œ ê³ ë ¤í•œ ìµœì  ì²­í¬ ë¶„í• """
    requests = []

    for range in missing_ranges:
        chunk_count = calculate_chunk_count(range)

        if chunk_count <= api_limit:
            # ë‹¨ì¼ ìš”ì²­ ê°€ëŠ¥
            requests.append(create_api_request(range))
        else:
            # ë¶„í•  í•„ìš”
            sub_chunks = split_range(range, api_limit)
            requests.extend(sub_chunks)

    return requests
```

### **3. ê²¹ì¹¨ ì²˜ë¦¬ ì „ëµ**
```python
def handle_overlap_strategy(existing_data: List[Candle],
                           new_data: List[Candle]) -> List[Candle]:
    """ê²¹ì¹˜ëŠ” ë°ì´í„° ì²˜ë¦¬ ë°©ì‹ ê²°ì •"""

    # ì „ëµ 1: ê¸°ì¡´ ë°ì´í„° ìš°ì„  (DB ì‹ ë¢°)
    if prefer_existing_data:
        return merge_prefer_existing(existing_data, new_data)

    # ì „ëµ 2: ì‹ ê·œ ë°ì´í„° ìš°ì„  (ìµœì‹ ì„± ë³´ì¥)
    if prefer_new_data:
        return merge_prefer_new(existing_data, new_data)

    # ì „ëµ 3: íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ì¤€ ì •í•©ì„± ê²€ì¦
    return merge_with_validation(existing_data, new_data)
```

---

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™” ì§€í‘œ**

### **ìµœì í™” íš¨ê³¼ ì¸¡ì •**
```python
@dataclass
class OptimizationMetrics:
    original_api_calls: int         # ê¸°ì¡´ ë°©ì‹ API í˜¸ì¶œ ìˆ˜
    optimized_api_calls: int        # ìµœì í™” í›„ API í˜¸ì¶œ ìˆ˜
    reduction_percentage: float     # ê°ì†Œìœ¨ (%)
    saved_requests: int             # ì ˆì•½ëœ ìš”ì²­ ìˆ˜
    processing_time_ms: float       # ë¶„ì„ ì²˜ë¦¬ ì‹œê°„
    cache_hit_improvement: float    # ìºì‹œ íˆíŠ¸ìœ¨ ê°œì„ 
```

### **ì„±ê³µ ê¸°ì¤€**
- **API í˜¸ì¶œ 50% ê°ì†Œ**: ê¸°ì¡´ ëŒ€ë¹„ ì ˆë°˜ ì´í•˜ í˜¸ì¶œ
- **ë¶„ì„ ì²˜ë¦¬ ì‹œê°„ < 50ms**: ì‹¤ì‹œê°„ ì‘ë‹µì„± ë³´ì¥
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ < 10MB**: ë¶„ì„ ê³¼ì • ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±
- **ì •í™•ë„ 100%**: ëˆ„ë½ ë°ì´í„° ì—†ëŠ” ì™„ì „í•œ ì»¤ë²„ë¦¬ì§€

---

## ğŸ§ª **í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤**

### **ì‹œë‚˜ë¦¬ì˜¤ 1: ì™„ì „ ìºì‹œ íˆíŠ¸**
```python
# Given: DBì— ìš”ì²­ êµ¬ê°„ ë°ì´í„° ì™„ì „ ì¡´ì¬
db_data = ["09:00", "09:01", "09:02", "09:03", "09:04"]
request = ("09:00", "09:04", count=5)

# When: OverlapAnalyzer ë¶„ì„
result = analyzer.analyze(request, db_data)

# Then: API í˜¸ì¶œ ì—†ìŒ
assert result.strategy == "CACHE_ONLY"
assert result.api_calls == 0
```

### **ì‹œë‚˜ë¦¬ì˜¤ 2: íŒŒí¸í™” ë°ì´í„° ìµœì í™”**
```python
# Given: íŒŒí¸í™”ëœ DB ë°ì´í„°
db_data = ["09:00", "09:02", "09:05", "09:07"]
request = ("09:00", "09:10", count=11)

# When: ìµœì í™” ë¶„ì„
result = analyzer.analyze(request, db_data)

# Then: ìµœì í™”ëœ ìš”ì²­ ìƒì„±
assert result.missing_ranges == [("09:01", "09:01"), ("09:03", "09:04"), ...]
assert result.api_calls < 3  # ê°œë³„ ìš”ì²­ë³´ë‹¤ íš¨ìœ¨ì 
```

### **ì‹œë‚˜ë¦¬ì˜¤ 3: ëŒ€ìš©ëŸ‰ ìš”ì²­ ì²˜ë¦¬**
```python
# Given: 500ê°œ ìš”ì²­ (200ê°œ ì œí•œ ì´ˆê³¼)
request = ("09:00", "17:00", count=480)  # 8ì‹œê°„ 1ë¶„ë´‰

# When: ì²­í¬ ë¶„í•  ìµœì í™”
result = analyzer.analyze(request, [])

# Then: ì ì ˆí•œ ì²­í¬ ë¶„í• 
assert len(result.api_requests) == 3  # 200+200+80 ë¶„í• 
assert all(req.count <= 200 for req in result.api_requests)
```

---

## âš ï¸ **ìœ„í—˜ ìš”ì†Œ ë° ëŒ€ì‘**

### **High Risk**
1. **ë³µì¡ë„ í­ì¦**
   - **ìœ„í—˜**: íŒŒí¸í™” íŒ¨í„´ ì¡°í•©ì´ ê¸°í•˜ê¸‰ìˆ˜ì  ì¦ê°€
   - **ëŒ€ì‘**: ìµœëŒ€ ë¶„ì„ ì‹œê°„ 50ms ì œí•œ, ì´ˆê³¼ì‹œ ê¸°ë³¸ ì „ëµ ì‚¬ìš©

2. **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê¸‰ì¦**
   - **ìœ„í—˜**: ëŒ€ìš©ëŸ‰ ì‹œê°„ êµ¬ê°„ ë¶„ì„ì‹œ ë©”ëª¨ë¦¬ ë¶€ì¡±
   - **ëŒ€ì‘**: ìŠ¤íŠ¸ë¦¬ë° ë°©ì‹ ë¶„ì„, 10MB ì œí•œ

### **Medium Risk**
1. **ì‹œê°„ ê³„ì‚° ì˜¤ë¥˜**
   - **ìœ„í—˜**: ìº”ë“¤ ê²½ê³„ ì •ë ¬ ì‹¤ìˆ˜ë¡œ ì¤‘ë³µ/ëˆ„ë½ ë°œìƒ
   - **ëŒ€ì‘**: time_utils.py ì² ì €í•œ í…ŒìŠ¤íŠ¸, ê²½ê³„ê°’ ê²€ì¦

2. **DB ìƒíƒœ ë³€í™”**
   - **ìœ„í—˜**: ë¶„ì„ ì¤‘ DB ë°ì´í„° ë³€ê²½ìœ¼ë¡œ ë¶„ì„ ê²°ê³¼ ë¬´íš¨í™”
   - **ëŒ€ì‘**: ë¶„ì„ ì‹œì  ìŠ¤ëƒ…ìƒ· ê³ ì •, ë‚™ê´€ì  ë½ ì ìš©

---

## ğŸ¯ **êµ¬í˜„ ìš°ì„ ìˆœìœ„**

### **Phase 1: ê¸°ë³¸ íŒ¨í„´ êµ¬í˜„** (2ì¼)
- COMPLETE_OVERLAP, NO_OVERLAP êµ¬í˜„
- ê¸°ë³¸ ì‹œê°„ êµ¬ê°„ ë¶„ì„ ë¡œì§
- ë‹¨ìˆœ ìµœì í™” ì „ëµ

### **Phase 2: ê³ ê¸‰ íŒ¨í„´ êµ¬í˜„** (2ì¼)
- PARTIAL_OVERLAP ë³€í˜•ë“¤ êµ¬í˜„
- ì²­í¬ ë¶„í•  ìµœì í™” ë¡œì§
- ë¹„ìš© ê³„ì‚° ì•Œê³ ë¦¬ì¦˜

### **Phase 3: íŒŒí¸í™” ì²˜ë¦¬** (1ì¼)
- FRAGMENTED_OVERLAP êµ¬í˜„
- ë³µì¡í•œ íŒŒí¸í™” ì‹œë‚˜ë¦¬ì˜¤ ì²˜ë¦¬
- ì„±ëŠ¥ ìµœì í™” ë° í…ŒìŠ¤íŠ¸

**ğŸ¯ ê²°ë¡ **: OverlapAnalyzerëŠ” API ë¹„ìš© 50% ì ˆê°ì˜ í•µì‹¬ì´ì§€ë§Œ, êµ¬í˜„ ë³µì¡ë„ê°€ ë†’ìœ¼ë¯€ë¡œ ë‹¨ê³„ì  ì ‘ê·¼ê³¼ ì² ì €í•œ í…ŒìŠ¤íŠ¸ê°€ í•„ìˆ˜ì…ë‹ˆë‹¤.
