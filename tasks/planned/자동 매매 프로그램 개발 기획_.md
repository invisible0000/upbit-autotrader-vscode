

# **업비트(Upbit) API 연동 자동매매 프로그램 개발 기획서: 전략 관리 시스템 중심의 리팩토링 및 구현 계획**

## **서문: 전략 중심 아키텍처로의 전환**

본 문서는 기계공학 박사 학위 소유의 비개발자가 Python, PyQt6, 그리고 업비트(Upbit) API를 활용하여 자동매매 프로그램을 개발하는 과정에서 얻은 핵심적인 통찰, 즉 \*\*"정교한 매매 전략 없이는 백테스팅을 포함한 모든 기능이 무의미하다"\*\*는 깨달음을 바탕으로 작성된 심층 개발 기획서입니다. 초기 개발 방향에서 선회하여, 이제 프로젝트의 최우선 순위는 강력하고 유연한 **'매매 전략 관리(Strategy Management)'** 시스템을 구축하는 것에 있습니다.

이러한 패러다임 전환에 따라, 본 기획서는 특히 strategy\_management 모듈의 핵심 구성요소인 \*\*'트리거 빌더(Trigger Builder)'\*\*와, 여기서 생성된 트리거 및 향후 조합될 전략의 유효성을 즉각적으로 검증할 수 있는 재사용 가능한 시각화 도구인 \*\*'미니 차트(Mini Chart)'\*\*의 설계와 구현에 집중합니다.

본 문서는 단순한 기능 명세를 넘어, 왜 특정 아키텍처와 디자인 패턴이 선택되었는지, 각 컴포넌트가 어떻게 상호작용하여 견고하고 확장 가능한 시스템을 구성하는지에 대한 근본적인 원리를 설명합니다. 이는 기술적 역량을 갖춘 프로젝트 오너가 직접 개발을 주도하는 상황에 맞춰, 단순한 "무엇(What)"을 넘어 "왜(Why)"와 "어떻게(How)"를 명확히 제시하는 기술 멘토링의 역할을 수행할 것입니다. 최종 목표는 이 문서 자체가 즉시 개발에 착수할 수 있는 실체적인 청사진(Blueprint on Canvas)이 되는 것입니다.

---

## **Part 1: 기초 아키텍처: 확장 가능한 알고리즘 트레이딩 프레임워크**

성공적인 애플리케이션은 단순히 기능의 집합이 아니라, 잘 설계된 뼈대 위에 세워집니다. 이 장에서는 전체 시스템의 안정성, 유지보수성, 확장성을 보장하는 핵심 소프트웨어 공학 원칙들을 정의합니다. 검증된 패턴을 적용함으로써, 향후 발생할 수 있는 복잡성 증가, UI 프리징, 로직 엉킴과 같은 일반적인 문제들을 사전에 방지하고 견고한 기반을 마련합니다.

### **1.1. 모델-뷰-컨트롤러(MVC) 패턴을 통한 애플리케이션 구조화**

복잡한 GUI 애플리케이션 개발 시 데이터(모델), 사용자 인터페이스(뷰), 그리고 이 둘을 연결하는 로직(컨트롤러)이 하나의 거대한 스크립트에 뒤섞이는 경향이 있습니다. 이는 코드의 재사용성을 저해하고 유지보수를 극도로 어렵게 만듭니다. MVC 패턴은 이러한 '관심사의 분리(Separation of Concerns)'를 통해 구조적인 해결책을 제시합니다.1 PyQt는 MVC의 변형으로, 종종 컨트롤러 로직이 뷰에 통합되는 실용적인 '모델/뷰(Model/View)' 아키텍처를 채택하고 있으며, 우리 프로젝트 역시 이 접근법을 따를 것입니다.3

* **모델 (Model):** 애플리케이션의 핵심 데이터와 비즈니스 로직을 포함하며, UI로부터 완전히 독립적입니다. 모델은 순수한 Python 클래스로 작성되어 UI 없이도 동작하고 테스트될 수 있어야 합니다.4  
  * Trigger: 전략의 가장 작은 원자 단위.  
  * Strategy: 하나 이상의 Trigger 조합으로 구성된 복합 객체.  
  * Position: Strategy와 자본에 연결된 실시간 거래 인스턴스.  
  * Portfolio: Position들의 집합.  
  * UpbitMarketData: API로부터 수신한 시장 데이터를 관리하는 모델.  
* **뷰 (View):** PyQt6로 구현되는 사용자 인터페이스 계층입니다. 뷰의 유일한 책임은 모델의 데이터를 시각적으로 표현하고 사용자 입력을 받는 것입니다. 최소한의 로직만을 포함해야 합니다.  
  * TriggerBuilderWindow(QWidget): 트리거 생성 및 편집 UI.  
  * StrategyMakerWindow(QWidget): 전략 조합 및 관리 UI.  
  * MiniChartWidget(QWidget): 재사용 가능한 시뮬레이션 차트 위젯.  
  * PortfolioDashboard(QMainWindow): 전체 포트폴리오 현황판.  
* **컨트롤러 (Controller):** 뷰로부터 사용자 입력을 받아 모델을 업데이트하고, 모델의 변경사항을 다시 뷰에 반영하도록 지시하는 중재자입니다. 이 로직은 메인 애플리케이션 클래스와 각 위젯 클래스 내부에 존재하며, UI 요소의 시그널(예: 버튼 클릭)을 특정 핸들러 메서드(슬롯)에 연결하는 방식으로 구현됩니다.3

이러한 MVC 구조를 선제적으로 도입하는 것은 단순한 코드 정리를 넘어섭니다. 예를 들어, Trigger 로직을 UI 버튼의 클릭 이벤트 핸들러 안에 직접 작성하는 대신, 순수한 Python 클래스(모델)로 분리하면 Trigger 자체의 재사용성이 극대화됩니다. 이렇게 분리된 Trigger는 UI 없이도 단위 테스트가 가능하고, 파일로 저장하거나 불러올 수 있으며, 향후 GUI 없이 서버에서만 동작하는 백엔드 트레이딩 엔진에서도 그대로 사용할 수 있습니다. 이는 개발 초기 단계의 현명한 아키텍처 결정이 미래에 발생할 수 있는 대규모 리팩토링 비용을 원천적으로 차단하는 대표적인 사례입니다.

### **1.2. 전략 디자인 패턴을 통한 유연한 로직 구현**

사용자 요구사항의 핵심은 다양한 조건(지표)과 트리거 조합을 동적으로 생성하고 실행하는 것입니다. 만약 모든 가능한 지표 비교 로직을 if/elif/else 구문으로 하드코딩한다면, 새로운 지표나 조건을 추가할 때마다 코드를 수정해야 하는 경직되고 유지보수가 불가능한 구조가 될 것입니다.

이 문제에 대한 가장 이상적인 해결책은 \*\*전략 디자인 패턴(Strategy Design Pattern)\*\*을 적용하는 것입니다. 이 패턴은 행위(behavioral) 디자인 패턴의 일종으로, 유사한 계열의 알고리즘들을 개별 클래스로 캡슐화하고, 이들을 동적으로 교체할 수 있게 만들어 줍니다.6

* **전략 인터페이스 (Strategy Interface):** execute()와 같은 공통 메서드를 가진 추상 기본 클래스(Abstract Base Class)를 정의합니다.  
* **구체적인 전략 (Concrete Strategies):** 사용자가 '전략 메이커'에서 생성하는 각각의 매매 전략(예: RSI\_Cross\_MA\_Strategy)은 이 인터페이스를 상속받아 자신만의 구체적인 실행 로직을 execute() 메서드 안에 구현합니다.  
* **컨텍스트 (Context):** Position 객체나 실제 거래를 수행하는 '트레이딩 엔진'이 컨텍스트의 역할을 합니다. 컨텍스트는 전략 객체에 대한 참조를 유지하며, 매매 결정을 내려야 할 때 전략의 구체적인 내용을 알 필요 없이 단지 strategy.execute(market\_data)를 호출합니다. 그러면 실제 로직 실행은 캡슐화된 전략 객체에 위임됩니다.7

더 나아가, 이 전략 패턴은 **트리거(Trigger) 레벨에서도 재귀적으로 적용**될 수 있습니다. 사용자가 정의한 '트리거'의 개념 자체가 사실은 하나의 작은 전략입니다. "RSI가 70을 상향 돌파"하는 조건은 하나의 알고리즘이고, "종가가 50일 이동평균선을 하향 돌파"하는 조건은 또 다른 알고리즘입니다. 따라서 AbstractCondition이라는 추상 클래스를 만들고 check(data) 메서드를 정의한 뒤, CrossesAboveCondition, CrossesBelowCondition 등을 구체적인 전략 클래스로 구현할 수 있습니다. 이렇게 되면 Trigger 객체는 이 Condition 객체를 품는 컨텍스트가 됩니다.

결과적으로 '트리거 빌더'는 작은 전략 객체(Condition)들을 조립하는 도구가 되고, '전략 메이커'는 이렇게 만들어진 트리거(작은 컨텍스트)들을 모아 더 큰 전략 객체를 조립하는 도구가 됩니다. 이처럼 패턴을 계층적으로 적용함으로써 시스템 전체가 근본부터 모듈화되고, 새로운 조건이나 로직을 추가하는 작업이 매우 용이해집니다.6

### **1.3. 반응성 높은 UI 보장: QThread를 이용한 비동기 처리**

자동매매 프로그램은 필연적으로 시간이 오래 걸리는 작업을 수행합니다. 과거 데이터 수신, 미니 시뮬레이션 실행, 업비트 API와의 실시간 통신 등이 대표적입니다. 만약 이러한 작업들을 메인 GUI 스레드에서 직접 처리하면, 작업이 끝날 때까지 애플리케이션 전체가 멈추는 'UI 프리징(Freezing)' 현상이 발생하여 사용자 경험을 심각하게 저해합니다.8

Qt 환경에서 이 문제를 해결하는 가장 올바르고 표준적인 방법은 QThread를 사용하여 시간이 오래 걸리는 작업을 백그라운드 스레드로 이전하는 것입니다. 여기서 중요한 점은, QThread 클래스 자체를 상속받아 run() 메서드를 재정의하는 방식보다, QObject를 상속받는 **워커(Worker) 객체를 생성한 후 .moveToThread() 메서드를 통해 QThread 인스턴스로 이동시키는 것이 권장되는 모범 사례**라는 것입니다.10

* **워커 클래스 (Worker Class):** SimulationWorker, ApiDataWorker와 같이 시간이 오래 걸리는 작업별로 QObject를 상속받는 워커 클래스를 만듭니다. 실제 작업 로직은 이 워커 클래스의 슬롯(slot) 안에 구현됩니다.10  
* **시그널/슬롯 통신 (Signal/Slot Communication):** 워커 스레드는 작업 결과를 pyqtSignal로 정의된 커스텀 시그널을 통해 메인 GUI 스레드로 안전하게 전달합니다. 예를 들어, SimulationWorker는 progressUpdated(int)나 resultsReady(dict) 같은 시그널을 발생(emit)시키고, 메인 윈도우는 이 시그널들을 프로그레스 바나 차트를 업데이트하는 슬롯에 연결합니다.12 이것이 스레드 간에 GUI를 안전하게 업데이트할 수 있는 유일한 방법입니다.14

Python의 기본 threading 라이브러리 대신 QThread와 moveToThread 패턴을 사용하는 이유는 단순히 코드를 백그라운드에서 실행하기 위함이 아닙니다. 이 패턴의 핵심은 워커가 이동한 백그라운드 스레드에 **새로운 Qt 이벤트 루프(Event Loop)를 생성**하는 데 있습니다. 워커 스레드에서 발생한 시그널이 메인 스레드의 슬롯으로 전달될 때, 이 연결은 '큐 연결(Queued Connection)' 방식으로 동작합니다.13 즉, 시그널은 메인 스레드의 이벤트 큐에 안전하게 등록된 후, 메인 스레드가 처리 준비가 되었을 때 순차적으로 실행됩니다. 이는 애플리케이션 전체가 Qt의 이벤트 기반 아키텍처를 존중하도록 보장하며, 단순한 비동기 실행을 넘어 스레드 안정성을 근본적으로 확보하는 매우 중요한 아키텍처 설계입니다.15

### **1.4. 전략의 영속성: YAML을 이용한 설정 관리**

사용자가 공들여 만든 트리거와 전략은 애플리케이션을 종료한 후에도 보존되어야 하며, 이를 위해 파일로 저장하고 다시 불러오는 기능이 필수적입니다. 이때 어떤 포맷을 사용하느냐는 사용성과 디버깅 편의성에 큰 영향을 미칩니다.

* **JSON (JavaScript Object Notation):** 기계가 읽기 좋은 포맷으로 널리 사용되지만, 주석을 지원하지 않으며 중괄호 {}와 쉼표 , 등으로 인해 사람이 직접 읽고 편집하기에는 다소 번거로울 수 있습니다.16  
* **YAML (YAML Ain't Markup Language):** 들여쓰기를 통해 계층 구조를 표현하여 사람이 읽고 쓰기에 매우 직관적입니다. 결정적으로, \# 기호를 사용하여 주석을 작성할 수 있다는 큰 장점을 가집니다.17

이 프로젝트의 목적을 고려할 때, **YAML이 월등히 우수한 선택**입니다. 그 이유는 YAML의 가독성과 주석 지원이 단순한 미적 편의 기능을 넘어, 이 시스템의 핵심 사용자인 '기술적 역량을 갖춘 프로젝트 오너'에게 강력한 **'Human-in-the-Loop' 도구**를 제공하기 때문입니다. 사용자는 저장된 .yaml 파일을 텍스트 편집기로 열어 복잡한 전략의 구조를 한눈에 파악하고, 주석으로 남겨둔 메모(예: \# 2023-10-27, 변동성 장세에 맞춰 최적화된 파라미터)를 통해 전략의 히스토리를 추적할 수 있습니다. 심지어는 파일을 직접 수정하여 미세 조정을 가할 수도 있습니다. 이처럼 설정 파일이 단순한 데이터 저장소를 넘어, 사람이 직접 검토하고 감사할 수 있는 투명한 산출물(artifact)이 된다는 것은 신뢰와 명확성이 무엇보다 중요한 트레이딩 시스템에서 매우 가치 있는 기능입니다.16

---

## **Part 2: 핵심 모듈 상세 설계: strategy\_management 패키지**

이 장에서는 프로젝트의 최우선 과제인 '트리거 빌더'와 그 기반이 되는 데이터 모델의 구체적인 청사진을 제시합니다. 사용자의 아이디어를 실제 코드로 변환하기 위한 상세한 설계가 포함됩니다.

### **2.1. 트리거와 조건의 데이터 모델**

사용자가 구상한 '트레이딩 변수', '조건', '트리거'와 같은 추상적인 개념들을 구체적이고 명확한 Python 클래스로 변환해야 합니다. 코드의 명료성과 불변성을 위해 dataclasses를 활용하는 것이 효과적입니다.

* class TradingVariable: '종가', 'RSI\_14', '거래량' 등 단일 데이터 시리즈를 표현합니다. 변수의 이름, 계산에 필요한 파라미터(예: 이동평균선의 기간), 그리고 계산된 실제 데이터(Pandas Series 객체)에 대한 참조를 속성으로 가집니다.  
* class Condition: 비교 로직 자체를 캡슐화합니다. 기준이 되는 base\_variable(TradingVariable 객체), '상향 돌파(crosses\_above)'와 같은 comparison\_operator(문자열), 그리고 비교 대상이 되는 target\_value(실수) 또는 target\_variable(또 다른 TradingVariable 객체)에 대한 참조를 포함합니다.  
* class Trigger: 사용자가 최종적으로 생성하고 관리하는 객체입니다. 고유한 이름(name), 핵심 로직을 담고 있는 Condition 객체, 그리고 '한 번만 발동(fire\_once)', '재장전 가능(re-armable)' 등 발동 규칙에 대한 메타데이터(behavior)를 가집니다. 이 구조는 1.2장에서 설명한 계층적 전략 패턴을 그대로 반영합니다.

### **2.2. Trigger\_Builder UI 설계 (PyQt6)**

사용자가 코딩 없이 직관적으로 Trigger 객체를 생성할 수 있도록, 데이터 모델과 직접적으로 매핑되는 사용자 인터페이스가 필요합니다. QWidget을 기반으로 QVBoxLayout, QGridLayout, QFormLayout 등을 활용하여 화면을 구성합니다.3 아래 표는 UI 컴포넌트와 데이터 모델 간의 명확한 연결 관계를 보여주는 구현 가이드입니다.

**표 2.2.1: 트리거 빌더 UI 컴포넌트 매핑**

| 기능/개념 | UI 요소 설명 | 권장 PyQt6 위젯 | 연결될 모델 속성 |
| :---- | :---- | :---- | :---- |
| 트리거 이름 | 생성된 트리거를 저장할 때 사용할 고유 이름 입력 필드 | QLineEdit | Trigger.name |
| 기준 변수 | 비교의 주체가 될 지표(RSI, MACD, 종가 등) 선택 드롭다운 | QComboBox | Condition.base\_variable |
| 비교 유형 | 논리 연산자(상향 돌파, 하향 돌파, \~보다 큼 등) 선택 드롭다운 | QComboBox | Condition.comparison\_operator |
| 비교 대상 유형 | 비교 대상을 '고정값'으로 할지 '외부 변수'로 할지 선택하는 라디오 버튼 | QButtonGroup과 QRadioButton | (컨트롤러 로직) |
| 고정값 입력 | 상수로 사용될 비교 값 입력 필드. 라디오 버튼 선택에 따라 활성/비활성화 | QDoubleSpinBox | Condition.target\_value |
| 외부 변수 | 비교 대상으로 사용될 두 번째 지표 선택 드롭다운. 라디오 버튼 선택에 따라 활성/비활성화 | QComboBox | Condition.target\_variable |
| 트리거 동작 방식 | 발동 규칙(한 번만, 연속, 특정 조건에 의해 재활성 등) 선택 | QCheckBox / QComboBox | Trigger.behavior |
| 트리거 저장/불러오기 | 설정된 트리거 구성을 YAML 파일로 저장하고 불러오는 버튼 | QPushButton | (컨트롤러 액션) |
| 트리거 테스트 | 현재 설정으로 '미니 차트'에서 간이 시뮬레이션을 실행하는 버튼 | QPushButton | (컨트롤러 액션) |

이 표는 개념적 요구사항, 시각적 UI 요소, 구현에 필요한 PyQt6 클래스, 그리고 이들이 조작할 데이터 모델 속성 간의 일대일 관계를 명확하게 정의합니다. 이는 개발자가 추측 없이 목적에 맞는 UI를 구축할 수 있도록 하는 직접적이고 실행 가능한 청사진 역할을 합니다.

### **2.3. Trigger\_Builder 컨트롤러 로직**

컨트롤러는 UI(뷰)와 데이터(모델)를 연결하는 '두뇌' 역할을 합니다. TriggerBuilderWindow 클래스 내에 핸들러 메서드(슬롯)를 구현하여 이 역할을 수행합니다.

* on\_save\_button\_clicked(): '저장' 버튼의 clicked 시그널에 연결될 슬롯입니다.  
  1. 모든 UI 위젯의 현재 상태(예: QLineEdit의 텍스트, QComboBox의 선택된 항목, QCheckBox의 체크 여부)를 읽습니다.  
  2. 이 데이터를 바탕으로 TradingVariable, Condition, Trigger 데이터 모델 객체를 인스턴스화합니다.  
  3. 별도로 구현된 YAML\_Persistence\_Manager를 호출하여 생성된 Trigger 객체를 .yaml 파일로 직렬화(serialize)하여 저장합니다.  
* on\_load\_button\_clicked(): '불러오기' 버튼에 연결될 슬롯입니다.  
  1. QFileDialog를 열어 사용자에게 .yaml 파일을 선택하게 합니다.3  
  2. YAML\_Persistence\_Manager를 사용해 선택된 파일을 Trigger 객체로 역직렬화(deserialize)합니다.  
  3. 불러온 Trigger 객체의 속성 값들을 사용하여 모든 UI 위젯의 상태를 업데이트하여 화면에 로드된 설정을 표시합니다.  
* on\_test\_button\_clicked(): '테스트' 버튼에 연결될 슬롯입니다.  
  1. 현재 UI에 설정된 값들을 바탕으로 임시 Trigger 객체를 메모리에 생성합니다.  
  2. 미리 로드된 과거 시장 데이터(예: 최근 1000개의 캔들)와 함께 이 Trigger 객체를 '미니 차트' 위젯으로 전달하여 시뮬레이션을 요청합니다.

---

## **Part 3: 재사용 가능한 Mini\_Chart: 시각적 트리거 테스트 캔버스**

이 장에서는 사용자의 반복적인 개발 프로세스의 핵심 도구인 '미니 차트'의 설계를 상세히 다룹니다. 이 차트는 단순한 시각화를 넘어, 전략의 유효성을 검증하는 동적인 시뮬레이션 캔버스로 기능해야 합니다.

### **3.1. 차트 라이브러리 선정 및 근거**

금융 데이터와 시뮬레이션 결과를 효과적으로 시각화하기 위해서는 성능과 유연성이 뛰어난 차트 라이브러리가 필수적입니다.

* **Matplotlib:** 강력한 라이브러리이지만, PyQt 애플리케이션에 내장(embedding)할 경우 네이티브한 느낌이 부족하며 실시간 데이터 업데이트 성능에 한계가 있을 수 있습니다. FigureCanvasQTAgg는 래퍼(wrapper)를 제공하지만, 렌더링이 Qt와 완전히 통합되지는 않습니다.18  
* **PyQt6-Charts:** Qt 네이티브 라이브러리로, 우수한 성능과 캔들스틱 차트와 같은 표준 차트 유형을 기본적으로 지원합니다.20 하지만 우리가 필요로 하는 동적인 트리거 마커와 같은 고도로 커스터마이징된 플롯 아이템을 생성하는 데에는 유연성이 다소 떨어질 수 있습니다.  
* **PyQtGraph:** **이 프로젝트를 위한 최적의 선택입니다.** 순수 Python으로 작성되었지만 NumPy와 Qt의 QGraphicsScene을 적극 활용하여 특히 실시간 데이터 처리에서 극도로 높은 성능을 보여줍니다.22 과학/공학 애플리케이션을 위해 설계되어 커스터마이징이 매우 용이합니다. 여러 개의 플롯 라인 추가 24, 커스텀 마커 생성 23, 플롯 아이템과의 프로그래밍 방식 상호작용이 자유롭습니다.  
  PlotWidget 형태로 PyQt 애플리케이션에 완벽하게 통합됩니다.25

PyQtGraph를 선택한 결정적인 이유는 단순한 차트 기능 때문이 아니라, **시뮬레이션 캔버스**라는 목적에 부합하는 아키텍처를 가졌기 때문입니다. PyQtGraph에서는 차트에 그려지는 모든 요소가 GraphicsObject라는 객체입니다.26 이는 우리가

TriggerMarkerItem(pg.GraphicsObject)와 같은 커스텀 클래스를 만들어, 단순히 모양을 표시하는 것을 넘어 그것을 생성한 트리거 이벤트에 대한 데이터를 내부에 품게 할 수 있음을 의미합니다. 사용자가 차트 위의 특정 마커를 클릭하면 27, 우리는 해당 객체에 저장된 데이터를 읽어와 상세 정보를 팝업으로 보여주는 등의 상호작용을 구현할 수 있습니다. 이처럼 깊이 있는 객체지향적 통합은 Matplotlib과 같은 래퍼 방식으로는 구현하기 어려우며, PyQtGraph를 선택하는 핵심적인 이유가 됩니다.

### **3.2. MiniChartWidget 아키텍처 설계**

미니 차트는 다른 부분에 종속되지 않고 독립적으로 재사용 가능한 컴포넌트로 설계되어야 합니다.

1. class MiniChartWidget(QWidget)를 생성합니다.  
2. \_\_init\_\_ 메서드 내에서 pg.PlotWidget 인스턴스를 생성하고 위젯의 레이아웃에 추가합니다.25  
3. OHLCV 데이터의 렌더링을 완벽하게 제어하기 위해, pg.GraphicsObject를 상속받는 커스텀 CandlestickItem 클래스를 구현합니다. 이는 StackOverflow에서 논의된 예제 코드에서 영감을 얻을 수 있습니다.26  
4. 외부에서 위젯을 쉽게 제어할 수 있도록 다음과 같은 공개 API(Public API) 메서드를 정의합니다.  
   * load\_market\_data(self, ohlcv\_dataframe): 차트를 초기화하고 전달받은 OHLCV 데이터프레임을 기반으로 기본 캔들스틱 차트를 그립니다.  
   * add\_indicator\_line(self, series, name, color): 이동평균선과 같은 보조지표를 plotWidget.plot() 메서드를 사용하여 새로운 라인으로 차트에 추가합니다.24  
   * show\_trigger\_event(self, timestamp, price, color, symbol): 트리거가 발동된 위치에 ScatterPlotItem이나 단일 포인트를 추가하여 시각적으로 표시합니다.23  
   * clear\_events(self): 기본 데이터는 그대로 둔 채, 표시된 모든 트리거 이벤트 마커만 제거합니다.

### **3.3. 트리거 이벤트의 시뮬레이션 및 시각화**

핵심 시뮬레이션 로직은 비동기적으로 실행되어 그 결과를 차트에 공급해야 합니다. 이는 QThread와 PyQtGraph를 통합하여 구현됩니다.

1. progress(int), result(dict), finished() 시그널을 가진 class SimulationWorker(QObject)를 생성합니다.  
2. Trigger\_Builder의 on\_test\_button\_clicked() 슬롯은 다음을 수행합니다:  
   a. SimulationWorker와 QThread를 인스턴스화합니다.  
   b. worker.moveToThread(thread)를 호출하여 워커를 스레드로 이동시킵니다.  
   c. 시그널을 슬롯에 연결합니다: worker.result.connect(self.mini\_chart\_widget.show\_trigger\_event).  
   d. 스레드 제어 시그널을 연결합니다: thread.started.connect(worker.run\_simulation).  
   e. thread.start()를 호출하여 스레드를 시작합니다.  
3. 워커의 run\_simulation() 슬롯은 Trigger 객체와 과거 데이터를 전달받습니다. 이 메서드는 데이터의 각 행(캔들)을 순회하며 trigger.condition.check(current\_row\_data)를 평가합니다.  
4. check() 메서드가 True를 반환하면, 워커는 self.result.emit({'timestamp':..., 'price':...,...})와 같이 결과 시그널을 발생시킵니다.  
5. 이 시그널에 연결된 MiniChartWidget의 show\_trigger\_event 슬롯이 메인 스레드에서 안전하게 실행되어, PlotWidget 위에 해당 마커를 그리게 됩니다. 이 과정을 통해 UI 프리징 없이 반응성이 뛰어난 시뮬레이션 환경이 완성됩니다.

---

## **Part 4: 시스템 통합 및 미래 확장성 확보**

마지막 장에서는 설계된 모든 컴포넌트들이 논리적으로 통합되는 방식을 검증하고, 향후 개발 목표를 지원할 수 있는 확장성을 갖추었는지 확인합니다. 이는 전체 시스템 아키텍처의 타당성을 최종적으로 입증하는 단계입니다.

### **4.1. Strategy\_Maker와 Mini\_Chart의 재사용성 검증**

사용자는 '미니 차트'가 '전략 메이커'에서도 재사용되어야 한다고 명시했습니다. 이 요구사항이 어떻게 충족되는지 구체적으로 설명합니다.

* **구현 계획:**  
  * '전략 메이커' UI는 사용자가 여러 개의 Trigger 객체(저장된 YAML 파일로부터)를 불러올 수 있는 인터페이스를 제공합니다.  
  * UI는 불러온 트리거들을 AND, OR 논리 연산자나 우선순위 설정을 통해 조합하여 하나의 Strategy 객체로 만들 수 있는 기능을 제공합니다.  
  * 생성된 Strategy 객체는 자신만의 check(data) 메서드를 가지며, 이 메서드는 내부적으로 구성된 트리거들을 정의된 논리에 따라 평가합니다.  
  * 사용자가 '전략 테스트' 버튼을 클릭하면, '전략 메이커'는 이렇게 조합된 Strategy 객체를 **'트리거 빌더'에서 사용했던 것과 동일한 MiniChartWidget 인스턴스**에 전달합니다. 시뮬레이션 워커는 이제 trigger.check(data) 대신 strategy.check(data)를 호출하게 됩니다. 차트에는 개별 트리거가 아닌, 완전한 전략에 의해 생성된 최종 진입/청산 신호가 표시됩니다. 이는 MiniChartWidget 컴포넌트의 성공적인 재사용을 명확히 보여줍니다.

### **4.2. 전체 데이터 흐름 및 상태 관리 검증**

트리거 생성부터 실제 포지션 관리에 이르기까지, 전체 시스템의 논리적 무결성을 확인해야 합니다. 이를 위해 Position 객체의 상태 변화와 데이터 흐름을 모델링합니다.

* **상태 머신 (State Machine):** Position 객체는 PENDING\_ENTRY(진입 대기), IN\_POSITION(포지션 보유), CLOSED(포지션 종료) 중 하나의 상태를 가집니다.  
* **데이터 흐름:**  
  1. **설정 (Setup):** Strategy와 할당된 자본으로 Position 객체가 생성됩니다. 초기 상태는 PENDING\_ENTRY입니다. 트레이딩 엔진은 이 Strategy의 *진입(entry)* 트리거들만 감시합니다.  
  2. **진입 (Entry):** 워커 스레드에서 실행되는 트레이딩 엔진은 업비트 API(pyupbit 29 또는  
     python-upbit-api 30 와 같은 래퍼 사용)로부터 실시간 데이터를 수신합니다. 이 데이터를  
     Strategy의 check\_entry() 메서드에 전달하여 평가합니다. 메서드가 True를 반환하면 매수 주문이 제출됩니다.  
  3. **관리 (Management):** 주문이 성공적으로 체결되면, 상태는 IN\_POSITION으로 전환됩니다. 엔진은 이제 진입 트리거들을 비활성화하고, 익절(take-profit)이나 손절(stop-loss)과 같은 *청산(exit)* 트리거들을 활성화합니다. 그리고 지속적으로 Strategy의 check\_exit() 메서드를 호출합니다.  
  4. **청산 (Exit):** 청산 트리거 중 하나가 발동되면 매도 주문이 제출됩니다. 주문 체결 시 상태는 CLOSED로 전환되고, 포지션 정보는 데이터베이스에 기록되며 모든 관련 트리거는 비활성화됩니다. 이 상태 기반 모델은 실시간 거래를 관리하기 위한 명확하고 견고한 프레임워크를 제공합니다.

### **4.3. 코드 청사진 및 설계도**

본 기획서를 즉시 실행 가능한 개발 문서로 만들기 위해, 핵심 클래스들의 스켈레톤 코드를 제공합니다. 이는 개발의 시작점을 명확히 하고 구조적 일관성을 보장합니다.

* **models/trigger\_models.py**  
  Python  
  from dataclasses import dataclass  
  from typing import Union, List, Any  
  import pandas as pd

  @dataclass  
  class TradingVariable:  
      name: str  
      params: dict  
      \# data: pd.Series \# 실제 데이터는 런타임에 계산되어 할당됨

  @dataclass  
  class Condition:  
      base\_variable: TradingVariable  
      comparison\_operator: str \# e.g., 'crosses\_above', 'is\_greater\_than'  
      target: Union

  @dataclass  
  class Trigger:  
      name: str  
      condition: Condition  
      behavior: str \# e.g., 'fire\_once', 'continuous'

      def check(self, market\_data\_slice: pd.DataFrame) \-\> bool:  
          """  
          주어진 시장 데이터 조각에 대해 트리거 조건을 평가합니다.  
          실제 로직은 여기에 구현됩니다.  
          """  
          \# Pseudo-code  
          \# 1\. base\_variable과 target (if variable)에 대한 지표 값을 계산합니다.  
          \# 2\. comparison\_operator에 따라 비교를 수행합니다.  
          \# 3\. 결과를 bool 값으로 반환합니다.  
          pass

* **models/strategy\_models.py**  
  Python  
  from dataclasses import dataclass, field  
  from typing import List  
  from.trigger\_models import Trigger

  @dataclass  
  class Strategy:  
      name: str  
      entry\_triggers: List  
      exit\_triggers: List  
      entry\_logic: str \= 'AND' \# 'AND', 'OR', or more complex logic  
      exit\_logic: str \= 'OR'

      def check\_entry(self, market\_data\_slice: pd.DataFrame) \-\> bool:  
          """진입 조건을 평가합니다."""  
          \# Pseudo-code  
          \# 1\. entry\_triggers 리스트를 순회하며 각 trigger.check()를 호출합니다.  
          \# 2\. entry\_logic에 따라 결과들을 조합합니다 (e.g., all() for AND, any() for OR).  
          \# 3\. 최종 진입 신호를 bool 값으로 반환합니다.  
          pass

      def check\_exit(self, market\_data\_slice: pd.DataFrame) \-\> bool:  
          """청산 조건을 평가합니다."""  
          \# Pseudo-code  
          \# 1\. exit\_triggers 리스트를 순회하며 각 trigger.check()를 호출합니다.  
          \# 2\. exit\_logic에 따라 결과들을 조합합니다.  
          \# 3\. 최종 청산 신호를 bool 값으로 반환합니다.  
          pass

  @dataclass  
  class Position:  
      strategy: Strategy  
      capital: float  
      state: str \= 'PENDING\_ENTRY' \# 'PENDING\_ENTRY', 'IN\_POSITION', 'CLOSED'  
      entry\_price: float \= 0.0  
      \#... 기타 포지션 관리 속성

* **ui/ui\_trigger\_builder.py**  
  Python  
  from PyQt6.QtWidgets import QWidget, QVBoxLayout, QPushButton, QLineEdit, QComboBox, QDoubleSpinBox  
  from PyQt6.QtCore import pyqtSlot

  class TriggerBuilderWindow(QWidget):  
      def \_\_init\_\_(self, parent=None):  
          super().\_\_init\_\_(parent)  
          self.setWindowTitle("트리거 빌더")

          \# \--- UI 위젯 선언 \---  
          self.trigger\_name\_edit \= QLineEdit()  
          self.base\_var\_combo \= QComboBox()  
          \#... (표 2.2.1에 명시된 모든 위젯 선언)  
          self.save\_button \= QPushButton("저장")  
          self.load\_button \= QPushButton("불러오기")  
          self.test\_button \= QPushButton("테스트")

          \# \--- 레이아웃 설정 \---  
          layout \= QVBoxLayout(self)  
          \#... (위젯들을 레이아웃에 추가)

          \# \--- 시그널-슬롯 연결 \---  
          self.save\_button.clicked.connect(self.on\_save\_button\_clicked)  
          self.load\_button.clicked.connect(self.on\_load\_button\_clicked)  
          self.test\_button.clicked.connect(self.on\_test\_button\_clicked)

      @pyqtSlot()  
      def on\_save\_button\_clicked(self):  
          print("저장 버튼 클릭됨")  
          \# 로직 구현  
          pass

      @pyqtSlot()  
      def on\_load\_button\_clicked(self):  
          print("불러오기 버튼 클릭됨")  
          \# 로직 구현  
          pass

      @pyqtSlot()  
      def on\_test\_button\_clicked(self):  
          print("테스트 버튼 클릭됨")  
          \# 로직 구현: SimulationWorker 생성 및 실행  
          pass

* **ui/ui\_mini\_chart.py**  
  Python  
  from PyQt6.QtWidgets import QWidget, QVBoxLayout  
  from PyQt6.QtCore import pyqtSlot  
  import pyqtgraph as pg

  class MiniChartWidget(QWidget):  
      def \_\_init\_\_(self, parent=None):  
          super().\_\_init\_\_(parent)  
          self.plot\_widget \= pg.PlotWidget()  
          layout \= QVBoxLayout(self)  
          layout.addWidget(self.plot\_widget)

      def load\_market\_data(self, ohlcv\_df):  
          \# CandlestickItem을 사용하여 데이터 플로팅  
          pass

      def add\_indicator\_line(self, series, name, color):  
          self.plot\_widget.plot(series.index, series.values, pen=pg.mkPen(color=color), name=name)

      @pyqtSlot(dict)  
      def show\_trigger\_event(self, event\_data):  
          \# event\_data: {'timestamp':..., 'price':..., 'color':..., 'symbol':...}  
          self.plot\_widget.plot(\[event\_data\['timestamp'\]\], \[event\_data\['price'\]\],  
                                pen=None, symbol=event\_data\['symbol'\], symbolBrush=event\_data\['color'\])

      def clear\_events(self):  
          \# 이벤트 마커들만 제거  
          pass

* **core/workers.py**  
  Python  
  from PyQt6.QtCore import QObject, pyqtSignal, pyqtSlot  
  from models.trigger\_models import Trigger

  class SimulationWorker(QObject):  
      \# 시그널 선언  
      result \= pyqtSignal(dict)  
      progress \= pyqtSignal(int)  
      finished \= pyqtSignal()

      def \_\_init\_\_(self, trigger, historical\_data):  
          super().\_\_init\_\_()  
          self.\_trigger \= trigger  
          self.\_data \= historical\_data

      @pyqtSlot()  
      def run\_simulation(self):  
          """시뮬레이션 루프 실행"""  
          total\_steps \= len(self.\_data)  
          for i in range(1, total\_steps):  
              \# 과거 데이터 조각(slice) 생성  
              data\_slice \= self.\_data.iloc\[:i\]

              if self.\_trigger.check(data\_slice):  
                  \# 트리거 발동 시 결과 시그널 발생  
                  event\_data \= {  
                      'timestamp': self.\_data.index\[i\],  
                      'price': self.\_data\['close'\].iloc\[i\],  
                      'color': 'r',  
                      'symbol': 't' \# triangle  
                  }  
                  self.result.emit(event\_data)

              \# 진행 상황 업데이트  
              if i % 10 \== 0: \# 10 스텝마다  
                  self.progress.emit(int(100 \* i / total\_steps))

          self.finished.emit()

#### **참고 자료**

1. Model-View-Controller (MVC) in Python Web Apps: Explained With Lego, 8월 2, 2025에 액세스, [https://realpython.com/lego-model-view-controller-python/](https://realpython.com/lego-model-view-controller-python/)  
2. Model/View Programming | Qt Widgets | Qt 6.9.1, 8월 2, 2025에 액세스, [https://doc.qt.io/qt-6/model-view-programming.html](https://doc.qt.io/qt-6/model-view-programming.html)  
3. PyQt Model/View Pattern \- Python Tutorial, 8월 2, 2025에 액세스, [https://www.pythontutorial.net/pyqt/pyqt-model-view/](https://www.pythontutorial.net/pyqt/pyqt-model-view/)  
4. Using the PyQt5 ModelView Architecture to build a simple Todo app \- Python GUIs, 8월 2, 2025에 액세스, [https://www.pythonguis.com/tutorials/modelview-architecture/](https://www.pythonguis.com/tutorials/modelview-architecture/)  
5. morefigs/Py-Qt-MVC: Python Model-View-Controller application generator for automating creation of PyQt and PySide applications. \- GitHub, 8월 2, 2025에 액세스, [https://github.com/morefigs/Py-Qt-MVC](https://github.com/morefigs/Py-Qt-MVC)  
6. Design Patterns in Python: Strategy | Medium, 8월 2, 2025에 액세스, [https://medium.com/@amirm.lavasani/design-patterns-in-python-strategy-7b14f1c4c162](https://medium.com/@amirm.lavasani/design-patterns-in-python-strategy-7b14f1c4c162)  
7. Strategy in Python / Design Patterns \- Refactoring.Guru, 8월 2, 2025에 액세스, [https://refactoring.guru/design-patterns/strategy/python/example](https://refactoring.guru/design-patterns/strategy/python/example)  
8. Multithreading PyQt6 applications with QThreadPool \- Python GUIs, 8월 2, 2025에 액세스, [https://www.pythonguis.com/tutorials/multithreading-pyqt6-applications-qthreadpool/](https://www.pythonguis.com/tutorials/multithreading-pyqt6-applications-qthreadpool/)  
9. Real Time Change of Widgets? — How to update the UI while in a loop \- Python GUIs, 8월 2, 2025에 액세스, [https://www.pythonguis.com/faq/real-time-change-of-widgets/](https://www.pythonguis.com/faq/real-time-change-of-widgets/)  
10. PyQt QThread \- Python Tutorial, 8월 2, 2025에 액세스, [https://www.pythontutorial.net/pyqt/pyqt-qthread/](https://www.pythontutorial.net/pyqt/pyqt-qthread/)  
11. Use PyQt's QThread to Prevent Freezing GUIs \- Real Python, 8월 2, 2025에 액세스, [https://realpython.com/python-pyqt-qthread/](https://realpython.com/python-pyqt-qthread/)  
12. Signals and Slots \- Qt for Python, 8월 2, 2025에 액세스, [https://doc.qt.io/qtforpython-6/tutorials/basictutorial/signals\_and\_slots.html](https://doc.qt.io/qtforpython-6/tutorials/basictutorial/signals_and_slots.html)  
13. PyQt: How to update progress without freezing the GUI? \- Stack Overflow, 8월 2, 2025에 액세스, [https://stackoverflow.com/questions/569650/pyqt-how-to-update-progress-without-freezing-the-gui](https://stackoverflow.com/questions/569650/pyqt-how-to-update-progress-without-freezing-the-gui)  
14. How to update GUI from a thread? \- Qt Centre Forum, 8월 2, 2025에 액세스, [https://www.qtcentre.org/threads/71493-How-to-update-GUI-from-a-thread](https://www.qtcentre.org/threads/71493-How-to-update-GUI-from-a-thread)  
15. How can I update PyQT widgets from within threads? : r/learnpython \- Reddit, 8월 2, 2025에 액세스, [https://www.reddit.com/r/learnpython/comments/822ibn/how\_can\_i\_update\_pyqt\_widgets\_from\_within\_threads/](https://www.reddit.com/r/learnpython/comments/822ibn/how_can_i_update_pyqt_widgets_from_within_threads/)  
16. YAML vs JSON \- Difference Between Data Serialization Formats \- AWS, 8월 2, 2025에 액세스, [https://aws.amazon.com/compare/the-difference-between-yaml-and-json/](https://aws.amazon.com/compare/the-difference-between-yaml-and-json/)  
17. Difference Between YAML and JSON \- GeeksforGeeks, 8월 2, 2025에 액세스, [https://www.geeksforgeeks.org/what-is-the-difference-between-yaml-and-json/](https://www.geeksforgeeks.org/what-is-the-difference-between-yaml-and-json/)  
18. Embed Matplotlib Graphs into PyQt6 Application \- CodersLegacy, 8월 2, 2025에 액세스, [https://coderslegacy.com/embed-matplotlib-graphs-into-pyqt6/](https://coderslegacy.com/embed-matplotlib-graphs-into-pyqt6/)  
19. Matplotlib plots in PyQt6, embedding charts in your GUI applications \- Python GUIs, 8월 2, 2025에 액세스, [https://www.pythonguis.com/tutorials/pyqt6-plotting-matplotlib/](https://www.pythonguis.com/tutorials/pyqt6-plotting-matplotlib/)  
20. PyQt6-Charts \- PyPI, 8월 2, 2025에 액세스, [https://pypi.org/project/PyQt6-Charts/](https://pypi.org/project/PyQt6-Charts/)  
21. Candlestick Chart Example \- Qt for Python, 8월 2, 2025에 액세스, [https://doc.qt.io/qtforpython-6.5/overviews/qtcharts-candlestickchart-example.html](https://doc.qt.io/qtforpython-6.5/overviews/qtcharts-candlestickchart-example.html)  
22. pyqtgraph/pyqtgraph: Fast data visualization and GUI tools for scientific / engineering applications \- GitHub, 8월 2, 2025에 액세스, [https://github.com/pyqtgraph/pyqtgraph](https://github.com/pyqtgraph/pyqtgraph)  
23. Plotting in PyQt \- Using PyQtGraph to create interactive plots in your GUI apps \- Python GUIs, 8월 2, 2025에 액세스, [https://www.pythonguis.com/tutorials/plotting-pyqtgraph/](https://www.pythonguis.com/tutorials/plotting-pyqtgraph/)  
24. Plotting in pyqtgraph \- Read the Docs, 8월 2, 2025에 액세스, [https://pyqtgraph.readthedocs.io/en/latest/getting\_started/plotting.html](https://pyqtgraph.readthedocs.io/en/latest/getting_started/plotting.html)  
25. Plotting in PySide — Using PyQtGraph to create interactive plots in your apps \- Python GUIs, 8월 2, 2025에 액세스, [https://www.pythonguis.com/tutorials/pyside-plotting-pyqtgraph/](https://www.pythonguis.com/tutorials/pyside-plotting-pyqtgraph/)  
26. how to set axis interval in candle stick using pyqtgraph with pyqt5? \- Stack Overflow, 8월 2, 2025에 액세스, [https://stackoverflow.com/questions/50095210/how-to-set-axis-interval-in-candle-stick-using-pyqtgraph-with-pyqt5](https://stackoverflow.com/questions/50095210/how-to-set-axis-interval-in-candle-stick-using-pyqtgraph-with-pyqt5)  
27. MouseClickEvent — pyqtgraph 0.14.0dev0 documentation, 8월 2, 2025에 액세스, [https://pyqtgraph.readthedocs.io/en/latest/api\_reference/graphicsscene/mouseclickevent.html](https://pyqtgraph.readthedocs.io/en/latest/api_reference/graphicsscene/mouseclickevent.html)  
28. python \- PyQt mousePressEvent \- get object that was clicked on? \- Stack Overflow, 8월 2, 2025에 액세스, [https://stackoverflow.com/questions/27222016/pyqt-mousepressevent-get-object-that-was-clicked-on](https://stackoverflow.com/questions/27222016/pyqt-mousepressevent-get-object-that-was-clicked-on)  
29. Pyupbit: Python Wrapper for Upbit API \- Read the Docs, 8월 2, 2025에 액세스, [https://pyupbit.readthedocs.io/en/latest/index.html](https://pyupbit.readthedocs.io/en/latest/index.html)  
30. python-upbit-api \- PyPI, 8월 2, 2025에 액세스, [https://pypi.org/project/python-upbit-api/](https://pypi.org/project/python-upbit-api/)  
31. python-upbit-api \- PyDigger, 8월 2, 2025에 액세스, [https://pydigger.com/pypi/python-upbit-api](https://pydigger.com/pypi/python-upbit-api)