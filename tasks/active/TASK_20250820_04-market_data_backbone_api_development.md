# 📋 TASK_20250820_04: Market Data Backbone API 개발

## 🎯 태스크 목표
- **주요 목표**: 3-Layer 아키텍처를 통합하여 전체 시스템에 단일 마켓 데이터 API 제공
- **완료 기준**: 스크리너, 백테스터, 차트뷰어 등이 하나의 API로 모든 데이터 요구사항 해결

## 📊 Backbone API의 역할 정의 (업데이트: 2025-08-20)

### ✅ **의존성 태스크 현재 상황**
- **TASK_20250820_01**: Phase 1 완료 ✅ (WebSocket 장애복구, 스냅샷/실시간 구분)
- **TASK_20250820_02**: Phase 1 준비 완료 ✅ (병행 개발 가능)
- **TASK_20250820_03**: Phase 1 준비 완료 ✅ (병행 개발 가능)
- **4번 태스크 시작 조건**: 1-3번 태스크 완료 시 통합 구현

### 🎯 핵심 책임
1. **순수 데이터 제공**: 마켓 데이터의 효율적 추상화된 API만 제공
2. **클라이언트 자율성**: 각 프로그램이 필요한 데이터를 스스로 요청하여 사용
3. **투명한 최적화**: 내부 3-Layer가 알아서 최적화, 사용자는 모름
4. **단순한 인터페이스**: 복잡한 사용 사례별 API 없이 기본 데이터 API만
5. **시스템 상태 조회**: 모니터링을 위한 읽기 전용 상태 API
6. **우선순위 기반 처리**: 실거래 우선순위 보장으로 시스템 안정성 확보
7. **WebSocket 장애복구 통합**: Smart Router의 3-Layer Fallback 시스템 활용

### 🔗 클라이언트별 사용 예시

#### 차트뷰어의 사용법
- 필요한 시간 범위의 캔들 데이터 직접 요청
- 실시간 업데이트를 위한 티커 데이터 주기적 요청
- 차트가 알아서 렌더링 및 메모리 관리

#### 스크리너의 사용법
- 다중 심볼의 티커 데이터 병렬 요청
- 받은 데이터로 스크리너가 알아서 분석 및 필터링
- 조건 만족 시 알림 처리

#### 백테스터의 사용법
- 필요한 기간의 캔들 데이터 요청 (낮은 우선순위)
- 대용량 데이터를 청크별로 자체 처리
- 시뮬레이션 결과 자체 관리

#### 실거래봇의 사용법
- 최고 우선순위로 긴급 데이터 요청
- 즉시 매매 신호 판단 및 실행
- 시스템 지연 없는 빠른 응답 보장

## 🛠️ 우선순위 기반 처리 전략

### 🎯 **우선순위 정의**
- **CRITICAL**: 실거래봇 데이터 요청 (최고 성능 보장)
- **HIGH**: 실시간 모니터링, 알림 시스템 (빠른 응답)
- **NORMAL**: 일반 스크리닝, 차트 로딩 (표준 처리)
- **LOW**: 백테스트, 대용량 데이터 분석 (시스템 보호)

### 🔄 **라우팅 전략**
- **Critical Path**: 긴급 요청은 직접 백본 접근으로 최고 성능
- **Standard Path**: 일반 요청은 표준 경로로 안정적 처리
- **Protected Path**: 리소스 집약적 요청은 시스템 부하 고려하여 제어

## 🛠️ 체계적 작업 절차 (업데이트)

### 📊 **Phase 1 시작 조건 확인**
- ✅ Smart Router Phase 1 완료 (WebSocket 장애복구 포함)
- ✅ Coordinator Phase 1 준비 완료 (병행 개발 시작 가능)
- ✅ Storage Phase 1 준비 완료 (병행 개발 시작 가능)
- 💡 **단계적 통합**: 각 Layer 완성 시점에 따라 점진적 통합 구현

### Phase 1: 기본 데이터 API 설계 📝 **준비 완료**
- [ ] 1.1 기본 데이터 API 인터페이스 정의 (캔들, 티커, 호가창, 체결)
- [ ] 1.2 우선순위 기반 요청 설계 (Priority.CRITICAL ~ LOW)
- [ ] 1.3 표준 데이터 모델 정의 (Candle, Ticker, Orderbook, Trade)
- [ ] 1.4 시스템 상태 조회 API 설계 (모니터링 전용)

### Phase 2: 3-Layer 통합 구현 (점진적)
- [ ] 2.1 내부 3-Layer 투명한 통합 (완성된 Layer부터 순차 통합)
- [ ] 2.2 우선순위별 라우팅 구현 (Critical/Standard/Protected Path)
- [ ] 2.3 자동 에러 복구 및 재시도 로직 (WebSocket 장애복구 연동)
- [ ] 2.4 시스템 부하 감지 및 보호 메커니즘

### Phase 3: 시스템 안정성 및 성능
- [ ] 3.1 실거래 시나리오 우선순위 테스트
- [ ] 3.2 시스템 과부하 상황 시뮬레이션
- [ ] 3.3 장애 상황 fallback 동작 검증
- [ ] 3.4 메모리 및 CPU 사용량 최적화

### Phase 4: 운영 및 모니터링
- [ ] 4.1 우선순위별 성능 메트릭 수집
- [ ] 4.2 시스템 상태 대시보드 구현
- [ ] 4.3 실거래 우선순위 보장 모니터링
- [ ] 4.4 자동 부하 조절 및 경고 시스템

## 🛠️ 핵심 구현 목표

### 1. MarketDataAPI - 메인 인터페이스
- **순수한 데이터 API**: 캔들, 티커, 호가창, 체결 4개 기본 API
- **우선순위 기반 라우팅**: Critical/High/Normal/Low 우선순위 처리
- **투명한 3-Layer 통합**: 사용자는 내부 복잡성을 모름
- **시스템 상태 조회**: 모니터링을 위한 읽기 전용 API

### 2. BackboneManager - 생명주기 관리
- **자동 초기화**: Layer 1 → 2 → 3 순서로 자동 시작 (완성된 Layer부터)
- **시스템 상태 모니터링**: 각 Layer 상태 추적 및 가용성 확인
- **우아한 종료**: Layer 3 → 2 → 1 순서로 정리
- **설정 자동 관리**: 사용자 개입 없는 최적 설정
- **점진적 통합**: Layer 완성 시점에 따른 단계적 기능 활성화

### 3. 우선순위 기반 처리
- **Critical Path**: 실거래봇 최고 성능 보장
- **Standard Path**: 일반 요청 안정적 처리
- **Protected Path**: 리소스 집약적 요청 제어
- **동적 부하 조절**: 시스템 상황에 따른 적응적 처리

## 🔗 Layer 간 협력 흐름 (점진적 통합)

### 현재 가능한 통합 시나리오 (Smart Router 우선)
```
클라이언트 (차트뷰어, 스크리너, 백테스터, 실거래봇)
    ↓ (필요한 데이터 + 우선순위 지정)
MarketDataAPI.get_xxx_data(symbol, ..., priority=Priority.XXX)
    ↓ (현재: Smart Router 직접 연동)
Smart Router (Layer 1) - WebSocket 장애복구 포함
    ↓ (향후: Coordinator/Storage 완성 시 통합)
Layer 2,3 (완성 시점에 따라 점진적 통합)
    ↓ (단순한 데이터 반환)
클라이언트 (받은 데이터로 알아서 비즈니스 로직 처리)
```

### 일반적인 데이터 요청 흐름 (우선순위 기반)
```
클라이언트 (차트뷰어, 스크리너, 백테스터, 실거래봇)
    ↓ (필요한 데이터 + 우선순위 지정)
MarketDataAPI.get_xxx_data(symbol, ..., priority=Priority.XXX)
    ↓ (우선순위 기반 라우팅)
┌─ CRITICAL/HIGH → DirectDataAccess (이벤트 버스 우회)
└─ NORMAL/LOW → EventBusDataAccess (리소스 관리)
    ↓ (투명한 3-Layer 처리)
Layer 1,2,3 (캐시/DB/API 자동 조합)
    ↓ (단순한 데이터 반환)
클라이언트 (받은 데이터로 알아서 비즈니스 로직 처리)
```

### 실거래 우선순위 보장 흐름 (Critical Path)
```
실거래봇
    ↓ (긴급 티커 데이터 요청 + priority=Priority.CRITICAL)
MarketDataAPI.get_ticker_data(symbol, priority=CRITICAL)
    ↓ (이벤트 버스 완전 우회)
DirectDataAccess → Layer 1,2,3 직접 접근
    ↓ (최고 성능, 지연 없음)
실거래봇 (즉시 매매 신호 판단)

vs

백테스터
    ↓ (대용량 캔들 데이터 요청 + priority=Priority.LOW)
MarketDataAPI.get_candle_data(symbol, timeframe, start, end, priority=LOW)
    ↓ (이벤트 버스 통과, 시스템 부하 체크)
EventBusDataAccess → 부하 허용 시에만 처리
    ↓ (시스템 보호, 실거래 방해 없음)
백테스터 (여유 있을 때 처리)
```

## 🎯 클라이언트별 최적화 (각자 알아서)

### 1. 차트뷰어 (자율적 데이터 관리)
- **자체 캐싱**: 차트가 필요한 만큼 데이터 요청하고 자체 캐싱
- **실시간 업데이트**: 필요시 ticker_data() 주기적 호출로 실시간 구현
- **메모리 관리**: 차트가 알아서 불필요한 데이터 정리
- **렌더링 최적화**: 받은 데이터로 차트가 알아서 부드러운 렌더링

### 2. 스크리너 (자율적 분석)
- **병렬 요청**: 여러 심볼 ticker_data() 동시 요청으로 성능 최적화
- **필터링 로직**: 받은 데이터로 스크리너가 알아서 조건 필터링
- **결과 캐싱**: 스크리너가 알아서 분석 결과 관리
- **알림 처리**: 조건 만족 시 스크리너가 알아서 알림 발송

### 3. 백테스터 (자율적 시뮬레이션)
- **청크 처리**: 대용량 데이터를 백테스터가 알아서 청크별 처리
- **메모리 효율**: 필요한 구간만 요청하여 메모리 절약
- **진행률 관리**: 백테스터가 알아서 사용자에게 진행률 표시
- **결과 저장**: 시뮬레이션 결과를 백테스터가 알아서 관리

## 🎯 성공 기준
- ✅ **극도의 단순화**: 기본 데이터 API 4개만 제공 (candle, ticker, orderbook, trade)
- ✅ **클라이언트 자율성**: 각 프로그램이 필요한 데이터를 스스로 요청하여 사용
- ✅ **실거래 우선순위**: CRITICAL/HIGH 우선순위로 이벤트 버스 우회, 최고 성능 보장
- ✅ **시스템 보호**: NORMAL/LOW 우선순위로 이벤트 버스 통과, 리소스 관리
- ✅ **투명한 최적화**: 내부 3-Layer가 알아서 최적화, 사용자는 존재도 모름
- ✅ **설정 제로**: 우선순위 매개변수 외 어떤 복잡한 설정도 필요 없음
- ✅ **하이브리드 통합**: 이벤트 버스 장점(리소스 관리) + 직접 접근 장점(성능)

## 🚀 개발 우선순위
1. **Phase 1**: 기본 데이터 API 4개 구현 (캔들, 티커, 호가창, 체결)
2. **Phase 2**: 내부 3-Layer 투명한 통합
3. **Phase 3**: 자동 최적화 및 에러 복구
4. **Phase 4**: 시스템 안정성 및 성능 검증
5. **Phase 5**: 모니터링 도구 (조회 전용)

---
**의존성**: ✅ TASK_20250820_01 Smart Routing Phase 1 완료 (WebSocket 장애복구 포함)
**시작 조건**: 기본 API 설계는 즉시 시작 가능, Layer 완성에 따라 점진적 통합
**통합 대상**: 모든 클라이언트가 단순한 4개 API로 자율적 사용
**예상 소요시간**: 1-2일 (기본 설계) + 각 Layer 완성 시점에 통합 작업
**핵심 가치**: 극도로 단순한 데이터 API + 클라이언트 완전 자율성
